<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>spring的作用 | Zmhaoo&#39;s Blog</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 6.1.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">Zmhaoo&#39;s Blog</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        spring的作用
    </div>
    <p class="sub">Apr 15 2022</p>
    <div class="post-content">
        <h2 id="Spring解耦"><a href="#Spring解耦" class="headerlink" title="Spring解耦"></a>Spring解耦</h2><p>Spring的一大作用就是能够降低代码耦合,让程序的扩展性更好.</p>
<h1 id="Spring的注解"><a href="#Spring的注解" class="headerlink" title="Spring的注解"></a>Spring的注解</h1><blockquote>
<ul>
<li><p>将自定义Bean交给Spring管理可以使用哪些注解？</p>
<p>@component  作用:把标注此注解的类交给Spring容器来创建对象</p>
<p>@Controller    作用:把标注此注解的类交给Spring容器来创建对象(用在controller层)</p>
<p>@Service         作用:把标注此注解的类交给Spring容器来创建对象(用在service层)</p>
<p>@Repository    作用:把标注此注解的类交给Spring容器来创建对象（都是由Spring内置的mybatis来创建所以基本不用）(用在dao层)</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>@Autowired和@Value注解有什么区别？</p>
<p>@Autowired    作用:从Spring容器中,根据成员变量类型找一个对象,然后赋值给该成员变量,可以使用在成员变量、成员set方法、构造方法参数上</p>
<p>@Value只能使用在成员变量，还可以结合EL表达式获取配置文件中的属性参数</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>用什么注解定义切面类？Spring通知有几种？</p>
<p>@Aspect                 作用:注解用来定义切面类</p>
<p>@Around                作用:环绕通知</p>
<p>@Before                  作用:前置通知，在目标方法执行前执行</p>
<p>@AfterReturning      作用:后置通知，在目标方法执行后，且没有异常时才执行</p>
<p>@AfterThrowing      作用:异常通知，在目标方法执行后，且出现异常时才执行</p>
<p>@After                     作用:最终通知，在目标方法执行后，且无论是否出现异常都执行</p>
</li>
</ul>
</blockquote>
<h1 id="AOP常用术语"><a href="#AOP常用术语" class="headerlink" title="AOP常用术语"></a>AOP常用术语</h1><p>1)切面:就是那些重复的,公共的,通用的功能称为切面,例如:日志,事务,权限</p>
<p>2)连接点:就是目标方法,因为在目标方法中要实现目标方法的功能和切面功能</p>
<p>3)切入点(Pointcut):来指定切入的位置,多个连接点构成切入点,切入点可以是一个目标方法,可以是一个类中所有方法,可以是某个包下的所有类中的方法.</p>
<p>4)目标对象:操作谁,谁就是目标对象.</p>
<p>5)通知(Advice):来指定切入的时机,是在目标方法执行前还是执行后还是出错时,还是环绕目标方法切入切面功能.</p>
<h1 id="什么是AspectJ框架"><a href="#什么是AspectJ框架" class="headerlink" title="什么是AspectJ框架"></a>什么是AspectJ框架</h1><p>AspectJ是一个优秀的面向切面的框架,它扩展了JAVA语言,提供了强大的切面实现.它因为是基于java语言开发的,所以无缝扩展.</p>
<h1 id="AspectJ常见通知类型"><a href="#AspectJ常见通知类型" class="headerlink" title="AspectJ常见通知类型"></a>AspectJ常见通知类型</h1><ul>
<li>AspectJ中常用的通知有四种类型:</li>
</ul>
<p>1)前置通知@Before</p>
<p>2)后置通知@AfterReturning</p>
<p>3)异常通知@AfterThrowing</p>
<p>4)环绕通知@Around</p>
<p>5)最终通知@After</p>
<p>6)定义切入点@Pointcut(了解) </p>
<h1 id="AspectJ-的切入点表达式（掌握）"><a href="#AspectJ-的切入点表达式（掌握）" class="headerlink" title="AspectJ 的切入点表达式（掌握）"></a>AspectJ 的切入点表达式（掌握）</h1><p>规范的公式：<br>execution(访问权限 方法返回值 方法声明（参数〉异常类型）<br>简化后的公式：<br>execution(方法返回值 方法声明（参数））<br>用到的符号：</p>
<p>*代码任意个任意的字符(通配符）<br>..如果出现在方法的参数中,则代表任意参数<br>如果出现在路径中,则代表本路径及其所有的子路径</p>
<h1 id="Bean的范围"><a href="#Bean的范围" class="headerlink" title="Bean的范围"></a>Bean的范围</h1><p>在类上使用@scope注解定义Bean的作用于,Spring支持五种作用域,后三种在web环境才生效.</p>
<ul>
<li><blockquote>
<p>@scope(“singleton”) - 容器内同 id 的 bean 只有一个实例（默认） </p>
</blockquote>
</li>
<li><blockquote>
<p>@scope(“prototype”) - 每次使用该 bean 时会创建新的实例</p>
</blockquote>
</li>
<li><p>@scope(“request”) - 在 web 环境中，每个请求范围内会创建新的实例</p>
</li>
<li><p>@scope(“session”) - 在 web 环境中，每个会话范围内会创建新的实例</p>
</li>
<li><p>@scope(“application”)- 在 web 环境中，每个应用范围内会创建新的实例</p>
<p>注:singleton单例模式默认是饿汉单例</p>
</li>
</ul>
<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><ul>
<li>标注了&#x3D;&#x3D;<strong>@PostConstruct</strong>&#x3D;&#x3D;的方法是初始化方法,会&#x3D;&#x3D;<strong>在bean被创建之后</strong>&#x3D;&#x3D;调用.</li>
<li>标注了**@PreDestroy** 的方法是销毁方法,**&#x3D;&#x3D;singleton范围的bean&#x3D;&#x3D;**的销毁方法会在Spring&#x3D;&#x3D;在容器关闭前被调用&#x3D;&#x3D;.</li>
<li>延迟初始化<ul>
<li>默认情况下singleton范围的bean是容器创建时就会&#x3D;&#x3D;<strong>创建</strong>&#x3D;&#x3D;</li>
<li>如果希望&#x3D;&#x3D;<strong>用到时才创建</strong>&#x3D;&#x3D;,可以使用 &#x3D;&#x3D;<strong>@Lazy</strong>&#x3D;&#x3D; 注解标注在类上来延迟创建(懒汉单例)</li>
</ul>
</li>
</ul>
<h1 id="扩展-返回数据库自增长键值注解"><a href="#扩展-返回数据库自增长键值注解" class="headerlink" title="扩展:返回数据库自增长键值注解"></a>扩展:返回数据库自增长键值注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span>  需要数据库自增长的键值</span><br></pre></td></tr></table></figure>

<h1 id="扩展-初始化库"><a href="#扩展-初始化库" class="headerlink" title="扩展:初始化库"></a>扩展:初始化库</h1><p>把DDL和DML的sql分别存储于resources下的schema.sql和data.sql这两个文件中,然后在application.properties中配置</p>
<blockquote>
<p>spring.sql.init.mode&#x3D;always</p>
<p>spring.sql.init.mode&#x3D;UTF-8 </p>
</blockquote>
<h2 id="Spring中编译异常导致事务回滚失效问题"><a href="#Spring中编译异常导致事务回滚失效问题" class="headerlink" title="Spring中编译异常导致事务回滚失效问题"></a>Spring中编译异常导致事务回滚失效问题</h2><p>为什么当我们用@Transactional注解来进行事务的管理的时候,如果出现编译时异常,发现事务还是提交了,没有回滚?</p>
<ul>
<li><p>原因:</p>
<p>–&gt; spring默认只有抛出运行时异常(即RuntimException及子类)或Error及子类时,才回回滚事务</p>
<p>–&gt; 如果抛出的是其他编译时期异常,则仍会提交事务</p>
<blockquote>
<p>解决方法:配置@Transaction(rollbackFor &#x3D; xxxException.class)</p>
</blockquote>
</li>
</ul>
<h1 id="Spring捕捉异常导致的回滚失效问题"><a href="#Spring捕捉异常导致的回滚失效问题" class="headerlink" title="Spring捕捉异常导致的回滚失效问题"></a>Spring捕捉异常导致的回滚失效问题</h1><ul>
<li><p>原因:</p>
<p>–&gt;事务提交,回滚,都是代理对象调用事务通知来完成的,如果代理对象不知道出现了异常,也就没有机会执行回滚操作</p>
<p>–&gt;自己try-catch异常,意味着代理对象认为[没有发生异常],因此也会提交事务</p>
<blockquote>
<p>解决方法:业务方法内不要捕获异常,或者将捕获的异常重新抛出</p>
</blockquote>
<h1 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h1><ul>
<li>当我们使用@Transactional开启事务的时候,如果事务内部需要调用另一个事务,那么他们用的是同一个事务吗?</li>
</ul>
<blockquote>
<p>如果没有设置参数,则默认是使用同一个事务,则一次事务创建(create new transaction),一次事务提交(commit)</p>
<ul>
<li>默认参数为:</li>
</ul>
<p>@Transactional(propagation &#x3D; propagation.REQUIRED)   有则加入,无则创建</p>
<ul>
<li>如果无论如何都想开启新事务,这是用以下参数:</li>
</ul>
<p>@Transactional(propagation &#x3D; propagation.REQUIRES_NEW) 总是需要一个新事物 </p>
</blockquote>
<h1 id="事务传播行为失效"><a href="#事务传播行为失效" class="headerlink" title="事务传播行为失效"></a>事务传播行为失效</h1><blockquote>
<p>事务传播行为失效是为在同一个类中,一个事务方法调另一个事务方法,此时被调用的方法实际上是this执行的,不是spring注入的代理对象,@Transactional底层是由spring创建的代理对象调用的AOP通知执行的事务逻辑,如果是this.方法名就不是代理对象调用了,而是被代理对象自己调用自己方法,所以被调用@Transaction事务注解也就不会生效了.</p>
</blockquote>
<blockquote>
<p>解决方法:底层原因跟循环依赖一样,只需要在配置文件配置:main.allow.circular&#x3D;reference&#x3D;true即可</p>
<p>注意:spring2.6.0之前的版本不需要配置,有spring自动处理</p>
</blockquote>
<h1 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h1><blockquote>
<p>Spring2.6.0之前的版本会自动解决</p>
</blockquote>
<blockquote>
<p>spring2.6.0及后版本需要在配置文件开启:main.allow.circular&#x3D;reference&#x3D;true</p>
</blockquote>
<h1 id="原子性与锁失效"><a href="#原子性与锁失效" class="headerlink" title="原子性与锁失效"></a>原子性与锁失效</h1><p>当我们开启一个事务的时候,这个时候如果有多个用户想通过事务来操作数据库,我们的数据库不上锁是非常危险的,会产生线程安全问题,这个时候我们应该想到上锁,但是上锁就能解决问题吗?</p>
<blockquote>
<p>答案是不一定,这个得取决于锁的位置,如果上锁的位置在@Transactional下的方法声明上,那么此锁会失效,应为我们在使用@Transactional创建事务的时候是通过通知+切点+通知的方式来实现的,如果在方法声明上上锁的话,那么有可能当一个客户端走完这个方法的时候,这个锁会打开,然后在提交事务之前(也就是后置通知执行前)有可能会让另一个用户进入到方法内部再次执行一遍事务流程,然后两个客户端同时提交,这个时候就会产生线程安全问题,也就是并发修改异常的现象,那么我们应该如何解决锁失效的问题呢?</p>
<ul>
<li><p>方式一:可以将锁上在整个事务代码的外面,也就是当serveci层的方法内部调用的时候,将整个调用过程前面上锁,就可以将,事务代码和业务代码一起包含在内了.</p>
</li>
<li><p>方式二:可以在sql修改语句后面加一个for update语句,加上了此语句之后,只要当前客户端不提交事务,其他客户端就无法访问当前客户端正在操作的信息,会锁在原地等待当前用户提交事务后才能进行下一步操作,这个锁也叫做悲观锁.</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="什么是IOC？什么是DI？"><a href="#什么是IOC？什么是DI？" class="headerlink" title="什么是IOC？什么是DI？"></a>什么是IOC？什么是DI？</h1><blockquote>
<p>IOC：控制反转，将Bean对象的创建权交给Spring，而后从Spring容器中获取Bean对象来使用</p>
</blockquote>
<blockquote>
<p> DI：依赖注入，给Bean的属性赋值</p>
</blockquote>
<h1 id="请指定什么是通知、连接点、切点、切面？"><a href="#请指定什么是通知、连接点、切点、切面？" class="headerlink" title="请指定什么是通知、连接点、切点、切面？"></a>请指定什么是通知、连接点、切点、切面？</h1><blockquote>
<p> 通知：抽取的相同业务逻辑的代码，用来增强目标方法</p>
<p>连接点：目标对象的所有方法均为连接点</p>
<p>切点：目标对象需要增强的方法为切点</p>
<p>切面：通知加切点</p>
</blockquote>
<h1 id="Spring整合MyBatis流程是什么？"><a href="#Spring整合MyBatis流程是什么？" class="headerlink" title="Spring整合MyBatis流程是什么？"></a>Spring整合MyBatis流程是什么？</h1><blockquote>
<p>第一步：创建SpringBoot工具，pom.xml文件中添加依赖</p>
</blockquote>
<blockquote>
<p>第二部：在application…配置文件中配置连接参数</p>
</blockquote>
<blockquote>
<p>第三部：定义Mapper接口，在接口上使用@Mapper注解</p>
</blockquote>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E8%A7%A3%E8%80%A6"><span class="toc-text">Spring解耦</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">Spring的注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOP%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-text">AOP常用术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAspectJ%E6%A1%86%E6%9E%B6"><span class="toc-text">什么是AspectJ框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AspectJ%E5%B8%B8%E8%A7%81%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">AspectJ常见通知类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AspectJ-%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">AspectJ 的切入点表达式（掌握）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">Bean的范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E9%95%BF%E9%94%AE%E5%80%BC%E6%B3%A8%E8%A7%A3"><span class="toc-text">扩展:返回数据库自增长键值注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%93"><span class="toc-text">扩展:初始化库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-text">Spring中编译异常导致事务回滚失效问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%9B%9E%E6%BB%9A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-text">Spring捕捉异常导致的回滚失效问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">事务的传播行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%A4%B1%E6%95%88"><span class="toc-text">事务传播行为失效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-text">循环依赖问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E9%94%81%E5%A4%B1%E6%95%88"><span class="toc-text">原子性与锁失效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIOC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFDI%EF%BC%9F"><span class="toc-text">什么是IOC？什么是DI？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%8C%87%E5%AE%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E7%9F%A5%E3%80%81%E8%BF%9E%E6%8E%A5%E7%82%B9%E3%80%81%E5%88%87%E7%82%B9%E3%80%81%E5%88%87%E9%9D%A2%EF%BC%9F"><span class="toc-text">请指定什么是通知、连接点、切点、切面？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Spring整合MyBatis流程是什么？</span></a>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
        
            <a class="next" href="/2022/04/04/%E7%BD%91%E9%A1%B5%E5%92%8CTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/">
                
                <span class="prev-text">浏览器和Tomcat服务器之间字符集乱码的问题怎么解决?</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Zmhaoo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
