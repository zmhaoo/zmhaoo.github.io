<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>Mysql锁的学习总结 | Zmhaoo&#39;s Blog</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 6.1.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">Zmhaoo&#39;s Blog</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        Mysql锁的学习总结
    </div>
    <p class="sub">May 16 2022</p>
    <div class="post-content">
        <h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL中的锁,按照锁的粒度分,分为以下三类:</p>
<p>1.全局锁:锁定数据库中所有表</p>
<p>2.表级锁:每次操作锁住整张表</p>
<p>3.行级锁:每次操作锁住对应的行数据</p>
<h1 id="全局锁-备份"><a href="#全局锁-备份" class="headerlink" title="全局锁(备份)"></a>全局锁(备份)</h1><p>全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态,后续的DML的写语句,DDL语句,已经更新操作的事务提交语句都将被阻塞</p>
<p>**其典型的使用场景是做全库的逻辑备份,**对所有的表进行锁定,从而获取一致性视图,保证数据的完整性</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a9nwsbtoj20sb0c4q3z.jpg" alt="image-20220516151501523"></p>
<p>加了全局锁后,在备份过程中,用户只能进行DQL查询操作,不能写入</p>
<h3 id="第一种备份操作-加全局锁"><a href="#第一种备份操作-加全局锁" class="headerlink" title="第一种备份操作,加全局锁"></a>第一种备份操作,加全局锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#第一步:进入mysql输入打开全局锁命令</span><br><span class="line">mysql&gt; flush tables with read lock;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第二步:打开第二个cmd窗口,此时不能关闭mysql窗口,不然全局锁失效</span><br><span class="line">#在第二个窗口执行备份语句 (在终端执行,不是mysql内部命令)</span><br><span class="line">zhangminghao@localhost blog % mysqldump -uroot -proot reggie &gt; /Users/zhangminghao/Desktop/SQL/emp.sql</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第三步:备份成功后返回第一个mysql窗口执行释放锁命令</span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>特点</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aackyaj6j20qu03jaah.jpg" alt="image-20220516153844161"></p>
<h3 id="第二种备份操作-不加全局锁"><a href="#第二种备份操作-不加全局锁" class="headerlink" title="第二种备份操作,不加全局锁"></a>第二种备份操作,不加全局锁</h3><p>在InnoDB引擎中,我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangminghao@localhost blog %   mysqldump --single-transaction -uroot -proot reggie &gt; /Users/zhangminghao/Desktop/SQL/reggie.sql</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure>

<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>表级锁,每次操作锁住整张表.锁定粒度大,发生锁冲突的概率最高,并发度最低</p>
<p>应用在MyISAM,InnoDB,BDB等存储引擎中</p>
<h3 id="1-1表锁"><a href="#1-1表锁" class="headerlink" title="1.1表锁"></a>1.1表锁</h3><h4 id="1-2对于表锁-分为两类"><a href="#1-2对于表锁-分为两类" class="headerlink" title="1.2对于表锁,分为两类"></a>1.2对于表锁,分为两类</h4><p>​    ①.表共享<strong>读锁</strong>(read lock):读锁不会阻塞开启读锁的客户端的写操作,但是会阻塞其他客户端的写操作,释放锁后才解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aau0dv7ij20kw04t0td.jpg" alt="image-20220516155528866"></p>
<p>   ②.表独占锁<strong>写锁</strong>(write lock):写锁不会阻塞上锁的客户端的读和写,但是会阻塞其他客户端的读和写,阻塞到客户端A释放锁,才能解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ab18a527j20kd04tq3i.jpg" alt="image-20220516160224869"></p>
<h4 id="1-3语法"><a href="#1-3语法" class="headerlink" title="1.3语法"></a>1.3语法</h4><p>​    1.加锁:lock tables 表名… read&#x2F;write</p>
<pre><code> 2.释放锁:unlock tables/客户端断开连接.
</code></pre>
<h3 id="2-1元数据锁"><a href="#2-1元数据锁" class="headerlink" title="2.1元数据锁"></a>2.1元数据锁</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acmvdflbj20wp08rq4r.jpg" alt="image-20220516165749161"></p>
<p>在MySQL 5.7中，针对MDL，引入了一张新表performance_schema.metadata_locks，该表可对外展示MDL的相关信息，包括其作用对象，类型及持有等待情况。</p>
<h4 id="2-2开启MDL的instrument"><a href="#2-2开启MDL的instrument" class="headerlink" title="2.2开启MDL的instrument"></a>2.2<strong>开启MDL的instrument</strong></h4><p>但是相关instrument并没有开启（MySQL 8.0是默认开启的），其可通过如下两种方式开启，</p>
<p><strong>临时生效</strong></p>
<p>修改<code>performance_schema.setup_instrume nts表</code>，但实例重启后，又会恢复为默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE  performance_schema.setup_instruments SET ENABLED = &#x27;YES&#x27;, TIMED = &#x27;YES&#x27; WHERE NAME = &#x27;wait/lock/metadata/sql/mdl&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>永久生效</strong></p>
<h4 id="2-3在配置文件中设置"><a href="#2-3在配置文件中设置" class="headerlink" title="2.3在配置文件中设置"></a>2.3在配置文件中设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">performance- schema -instrument= &#x27;wait/lock/metadata/sql/mdl=ON&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="2-4元数据锁的执行流程"><a href="#2-4元数据锁的执行流程" class="headerlink" title="2.4元数据锁的执行流程"></a>2.4元数据锁的执行流程</h4><p>第一步:通过performance_schema.metadata_locks查看元数据锁状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看元数据锁状态</span><br><span class="line">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| object_type | object_schema      | object_name    | lock_type   | lock_duration |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>第二步:<strong>开启事务</strong>后,写一条<strong>查询语句</strong>,元数据锁表中会增加一条共享读锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| object_type | object_schema      | object_name    | lock_type   | lock_duration |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| TABLE       | reggie             | employee       | SHARED_READ | TRANSACTION   |   --------------&gt;共享读锁</span><br><span class="line">| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果commit提交了事务,那么元数据中的共享读锁会消失</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abyhhqodj21430a6n0x.jpg" alt="image-20220516163422539"></p>
<p>第三步:如果在没有提交事务之前,在另一个客户端对该表进行修改,会增加排他锁,但是排他锁跟其他所都是互斥的,所以会造成阻塞.    </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aceptxmoj213c0dq0vz.jpg" alt="image-20220516164958973"></p>
<p>此时在左边客户端再次查询元数据</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acjams3nj217r0gw0wy.jpg" alt="image-20220516165423051"></p>
<p>提交事务后</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acl0vhj6j213j0f5dk5.jpg" alt="image-20220516165602410"></p>
<h3 id="3-1意向锁"><a href="#3-1意向锁" class="headerlink" title="3.1意向锁"></a>3.1意向锁</h3><h4 id="3-2为什么要加意向锁"><a href="#3-2为什么要加意向锁" class="headerlink" title="3.2为什么要加意向锁?"></a>3.2为什么要加意向锁?</h4><p>先看一下现象:</p>
<p>加入客户端A在修改表中数据时,开启事务后通过id来修改数据,因为id是主键,所以会自动上行锁</p>
<p>这个时候客户端B想对该表上表锁的时候,必须判断该表是否有表锁,就必须从第一条开始遍历检查,以及行锁的类型</p>
<p>来判断能不能加表锁,此时数据量大的时候,性能极底 ,如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ad1ve4xmj20w40a3gn7.jpg" alt="image-20220516171213695"></p>
<p><strong>所以为了避免DML执行时,加的行锁与表锁冲突,在InnoDB中引如了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表的检查.</strong></p>
<p>可以通过以下sql,查看意向锁及行锁的加锁情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<h4 id="3-3意向共享锁-IS"><a href="#3-3意向共享锁-IS" class="headerlink" title="3.3意向共享锁(IS)"></a>3.3意向共享锁(IS)</h4><p>与表锁共享锁(read)兼容,与表锁排他锁(write)互斥.</p>
<h4 id="3-4意向排他锁-IX"><a href="#3-4意向排他锁-IX" class="headerlink" title="3.4意向排他锁(IX)"></a>3.4意向排他锁(IX)</h4><p>与表锁共享锁(read)及排他锁(write)都互斥,意向锁之间不会互斥.</p>
<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>行级锁,每次操作锁住对应的行数据.锁定粒度最小,发生锁冲突的概率底,并发度最高.</p>
<p>应用在InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的**,行锁是通过对索引上的索引项来实现的**,而不是对记录加的锁.</p>
<p><strong>如果条件的字段没有索引那么行锁会升级为表锁🔒</strong></p>
<p>对于行级锁主要分为以下三类:</p>
<h3 id="1-行锁的分类"><a href="#1-行锁的分类" class="headerlink" title="1)行锁的分类"></a>1)行锁的分类</h3><h4 id="1-1行锁-Record-Lock"><a href="#1-1行锁-Record-Lock" class="headerlink" title="1.1行锁(Record Lock)"></a>1.1行锁(Record Lock)</h4><p>锁定单个行记录的锁,防止其他事务对此进行update和delete.在RC.RR隔离级别下都支持.</p>
<blockquote>
<p><strong>自己的理解:</strong></p>
<p><strong>行锁就是锁住聚集索引索引对应的行数据如果是从二级索引开始上锁</strong></p>
<p><strong>那么要通过索引对应的主键回表查询到聚集索引对应的行数据</strong></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afb9euuzj20mr03rmxt.jpg" alt="image-20220516183027448"></p>
<h4 id="1-2间隙锁-Gap-Lock"><a href="#1-2间隙锁-Gap-Lock" class="headerlink" title="1.2间隙锁(Gap Lock)"></a>1.2间隙锁(Gap Lock)</h4><p>锁定索引记录间隙(不含该记录),确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读.</p>
<p>在RR隔离级别下都支持</p>
<p>​       <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afehj6x7j20qo03kgmb.jpg" alt="image-20220516183333703"></p>
<h4 id="1-3临键锁-Next-Key-Lock"><a href="#1-3临键锁-Next-Key-Lock" class="headerlink" title="1.3临键锁(Next-Key Lock)"></a>1.3临键锁(Next-Key Lock)</h4><p>行锁和间隙锁组合,同时锁住数据,并锁住数据前面的间隙Gap.在RR隔离级别下支持**(行锁和间隙锁的组合)**</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2affu842oj20qo03qgmb.jpg" alt="image-20220516183451619"></p>
<h3 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2)行锁"></a>2)行锁</h3><p>InnoDB实现了一下两种类型的行锁:</p>
<h4 id="2-1共享锁-S"><a href="#2-1共享锁-S" class="headerlink" title="2.1共享锁(S)"></a>2.1共享锁(S)</h4><p>允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.</p>
<p>简单理解就是,共享锁之间是兼容的,共享锁和排他锁是互斥的</p>
<h4 id="2-2排他锁-X"><a href="#2-2排他锁-X" class="headerlink" title="2.2排他锁(X)"></a>2.2排他锁(X)</h4><p>允许获取排他锁的事务更新数据,组织其他事务获得相同的数据集的共享锁和排他锁. </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afl6o5dnj20nc055jrl.jpg" alt="image-20220516183959691"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afpo7dhqj20wg065mxu.jpg" alt="image-20220516184418623"></p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afysg3ltj20vs03k3z6.jpg" alt="image-20220516185304652"></p>
<hr>
<h4 id="3-间隙锁-x2F-临键锁-演示"><a href="#3-间隙锁-x2F-临键锁-演示" class="headerlink" title="3)间隙锁&#x2F;临键锁-演示"></a>3)间隙锁&#x2F;临键锁-演示</h4><hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag1wtzlvj20q303j3yx.jpg" alt="image-20220516185604366"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag21w7q8j20x8011t91.jpg" alt="image-20220516185612478"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2agddsvkuj20ji0exmyw.jpg" alt="image-20220516190705735"></p>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81-%E5%A4%87%E4%BB%BD"><span class="toc-text">全局锁(备份)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C-%E5%8A%A0%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">第一种备份操作,加全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C-%E4%B8%8D%E5%8A%A0%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">第二种备份操作,不加全局锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E8%A1%A8%E9%94%81"><span class="toc-text">1.1表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E5%AF%B9%E4%BA%8E%E8%A1%A8%E9%94%81-%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB"><span class="toc-text">1.2对于表锁,分为两类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E8%AF%AD%E6%B3%95"><span class="toc-text">1.3语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-text">2.1元数据锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%BC%80%E5%90%AFMDL%E7%9A%84instrument"><span class="toc-text">2.2开启MDL的instrument</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE"><span class="toc-text">2.3在配置文件中设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.4元数据锁的执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">3.1意向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">3.2为什么要加意向锁?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81-IS"><span class="toc-text">3.3意向共享锁(IS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E6%84%8F%E5%90%91%E6%8E%92%E4%BB%96%E9%94%81-IX"><span class="toc-text">3.4意向排他锁(IX)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A1%8C%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1)行锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E8%A1%8C%E9%94%81-Record-Lock"><span class="toc-text">1.1行锁(Record Lock)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E9%97%B4%E9%9A%99%E9%94%81-Gap-Lock"><span class="toc-text">1.2间隙锁(Gap Lock)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E4%B8%B4%E9%94%AE%E9%94%81-Next-Key-Lock"><span class="toc-text">1.3临键锁(Next-Key Lock)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%8C%E9%94%81"><span class="toc-text">2)行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%85%B1%E4%BA%AB%E9%94%81-S"><span class="toc-text">2.1共享锁(S)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E6%8E%92%E4%BB%96%E9%94%81-X"><span class="toc-text">2.2排他锁(X)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%B4%E9%9A%99%E9%94%81-x2F-%E4%B8%B4%E9%94%AE%E9%94%81-%E6%BC%94%E7%A4%BA"><span class="toc-text">3)间隙锁&#x2F;临键锁-演示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
        
            <a class="next" href="/2022/05/13/Mysql%E7%9A%84Sql%E4%BC%98%E5%8C%96/">
                
                <span class="prev-text">Mysql的Sql优化</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Zmhaoo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
