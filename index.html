<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>Zmhaoo&#39;s Blog</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 6.1.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">Zmhaoo&#39;s Blog</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
    <div class="posts-wrapper">
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/16/Mysql%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Mysql锁的学习总结</a>
            </div>
            <p class="sub">May 16 2022</p>
            <div class="post-content">
                
                    <h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL中的锁,按照锁的粒度分,分为以下三类:</p>
<p>1.全局锁:锁定数据库中所有表</p>
<p>2.表级锁:每次操作锁住整张表</p>
<p>3.行级锁:每次操作锁住对应的行数据</p>
<h1 id="全局锁-备份"><a href="#全局锁-备份" class="headerlink" title="全局锁(备份)"></a>全局锁(备份)</h1><p>全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态,后续的DML的写语句,DDL语句,已经更新操作的事务提交语句都将被阻塞</p>
<p>**其典型的使用场景是做全库的逻辑备份,**对所有的表进行锁定,从而获取一致性视图,保证数据的完整性</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a9nwsbtoj20sb0c4q3z.jpg" alt="image-20220516151501523"></p>
<p>加了全局锁后,在备份过程中,用户只能进行DQL查询操作,不能写入</p>
<h3 id="第一种备份操作-加全局锁"><a href="#第一种备份操作-加全局锁" class="headerlink" title="第一种备份操作,加全局锁"></a>第一种备份操作,加全局锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#第一步:进入mysql输入打开全局锁命令</span><br><span class="line">mysql&gt; flush tables with read lock;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第二步:打开第二个cmd窗口,此时不能关闭mysql窗口,不然全局锁失效</span><br><span class="line">#在第二个窗口执行备份语句 (在终端执行,不是mysql内部命令)</span><br><span class="line">zhangminghao@localhost blog % mysqldump -uroot -proot reggie &gt; /Users/zhangminghao/Desktop/SQL/emp.sql</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第三步:备份成功后返回第一个mysql窗口执行释放锁命令</span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>特点</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aackyaj6j20qu03jaah.jpg" alt="image-20220516153844161"></p>
<h3 id="第二种备份操作-不加全局锁"><a href="#第二种备份操作-不加全局锁" class="headerlink" title="第二种备份操作,不加全局锁"></a>第二种备份操作,不加全局锁</h3><p>在InnoDB引擎中,我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangminghao@localhost blog %   mysqldump --single-transaction -uroot -proot reggie &gt; /Users/zhangminghao/Desktop/SQL/reggie.sql</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure>

<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>表级锁,每次操作锁住整张表.锁定粒度大,发生锁冲突的概率最高,并发度最低</p>
<p>应用在MyISAM,InnoDB,BDB等存储引擎中</p>
<h3 id="1-1表锁"><a href="#1-1表锁" class="headerlink" title="1.1表锁"></a>1.1表锁</h3><h4 id="1-2对于表锁-分为两类"><a href="#1-2对于表锁-分为两类" class="headerlink" title="1.2对于表锁,分为两类"></a>1.2对于表锁,分为两类</h4><p>​    ①.表共享<strong>读锁</strong>(read lock):读锁不会阻塞开启读锁的客户端的写操作,但是会阻塞其他客户端的写操作,释放锁后才解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aau0dv7ij20kw04t0td.jpg" alt="image-20220516155528866"></p>
<p>   ②.表独占锁<strong>写锁</strong>(write lock):写锁不会阻塞上锁的客户端的读和写,但是会阻塞其他客户端的读和写,阻塞到客户端A释放锁,才能解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ab18a527j20kd04tq3i.jpg" alt="image-20220516160224869"></p>
<h4 id="1-3语法"><a href="#1-3语法" class="headerlink" title="1.3语法"></a>1.3语法</h4><p>​    1.加锁:lock tables 表名… read&#x2F;write</p>
<pre><code> 2.释放锁:unlock tables/客户端断开连接.
</code></pre>
<h3 id="2-1元数据锁"><a href="#2-1元数据锁" class="headerlink" title="2.1元数据锁"></a>2.1元数据锁</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acmvdflbj20wp08rq4r.jpg" alt="image-20220516165749161"></p>
<p>在MySQL 5.7中，针对MDL，引入了一张新表performance_schema.metadata_locks，该表可对外展示MDL的相关信息，包括其作用对象，类型及持有等待情况。</p>
<h4 id="2-2开启MDL的instrument"><a href="#2-2开启MDL的instrument" class="headerlink" title="2.2开启MDL的instrument"></a>2.2<strong>开启MDL的instrument</strong></h4><p>但是相关instrument并没有开启（MySQL 8.0是默认开启的），其可通过如下两种方式开启，</p>
<p><strong>临时生效</strong></p>
<p>修改<code>performance_schema.setup_instrume nts表</code>，但实例重启后，又会恢复为默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE  performance_schema.setup_instruments SET ENABLED = &#x27;YES&#x27;, TIMED = &#x27;YES&#x27; WHERE NAME = &#x27;wait/lock/metadata/sql/mdl&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>永久生效</strong></p>
<h4 id="2-3在配置文件中设置"><a href="#2-3在配置文件中设置" class="headerlink" title="2.3在配置文件中设置"></a>2.3在配置文件中设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">performance- schema -instrument= &#x27;wait/lock/metadata/sql/mdl=ON&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="2-4元数据锁的执行流程"><a href="#2-4元数据锁的执行流程" class="headerlink" title="2.4元数据锁的执行流程"></a>2.4元数据锁的执行流程</h4><p>第一步:通过performance_schema.metadata_locks查看元数据锁状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看元数据锁状态</span><br><span class="line">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| object_type | object_schema      | object_name    | lock_type   | lock_duration |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>第二步:<strong>开启事务</strong>后,写一条<strong>查询语句</strong>,元数据锁表中会增加一条共享读锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| object_type | object_schema      | object_name    | lock_type   | lock_duration |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">| TABLE       | reggie             | employee       | SHARED_READ | TRANSACTION   |   --------------&gt;共享读锁</span><br><span class="line">| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |</span><br><span class="line">+-------------+--------------------+----------------+-------------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果commit提交了事务,那么元数据中的共享读锁会消失</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abyhhqodj21430a6n0x.jpg" alt="image-20220516163422539"></p>
<p>第三步:如果在没有提交事务之前,在另一个客户端对该表进行修改,会增加排他锁,但是排他锁跟其他所都是互斥的,所以会造成阻塞.    </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aceptxmoj213c0dq0vz.jpg" alt="image-20220516164958973"></p>
<p>此时在左边客户端再次查询元数据</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acjams3nj217r0gw0wy.jpg" alt="image-20220516165423051"></p>
<p>提交事务后</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acl0vhj6j213j0f5dk5.jpg" alt="image-20220516165602410"></p>
<h3 id="3-1意向锁"><a href="#3-1意向锁" class="headerlink" title="3.1意向锁"></a>3.1意向锁</h3><h4 id="3-2为什么要加意向锁"><a href="#3-2为什么要加意向锁" class="headerlink" title="3.2为什么要加意向锁?"></a>3.2为什么要加意向锁?</h4><p>先看一下现象:</p>
<p>加入客户端A在修改表中数据时,开启事务后通过id来修改数据,因为id是主键,所以会自动上行锁</p>
<p>这个时候客户端B想对该表上表锁的时候,必须判断该表是否有表锁,就必须从第一条开始遍历检查,以及行锁的类型</p>
<p>来判断能不能加表锁,此时数据量大的时候,性能极底 ,如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ad1ve4xmj20w40a3gn7.jpg" alt="image-20220516171213695"></p>
<p><strong>所以为了避免DML执行时,加的行锁与表锁冲突,在InnoDB中引如了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表的检查.</strong></p>
<p>可以通过以下sql,查看意向锁及行锁的加锁情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<h4 id="3-3意向共享锁-IS"><a href="#3-3意向共享锁-IS" class="headerlink" title="3.3意向共享锁(IS)"></a>3.3意向共享锁(IS)</h4><p>与表锁共享锁(read)兼容,与表锁排他锁(write)互斥.</p>
<h4 id="3-4意向排他锁-IX"><a href="#3-4意向排他锁-IX" class="headerlink" title="3.4意向排他锁(IX)"></a>3.4意向排他锁(IX)</h4><p>与表锁共享锁(read)及排他锁(write)都互斥,意向锁之间不会互斥.</p>
<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>行级锁,每次操作锁住对应的行数据.锁定粒度最小,发生锁冲突的概率底,并发度最高.</p>
<p>应用在InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的**,行锁是通过对索引上的索引项来实现的**,而不是对记录加的锁.</p>
<p><strong>如果条件的字段没有索引那么行锁会升级为表锁🔒</strong></p>
<p>对于行级锁主要分为以下三类:</p>
<h3 id="1-行锁的分类"><a href="#1-行锁的分类" class="headerlink" title="1)行锁的分类"></a>1)行锁的分类</h3><h4 id="1-1行锁-Record-Lock"><a href="#1-1行锁-Record-Lock" class="headerlink" title="1.1行锁(Record Lock)"></a>1.1行锁(Record Lock)</h4><p>锁定单个行记录的锁,防止其他事务对此进行update和delete.在RC.RR隔离级别下都支持.</p>
<blockquote>
<p><strong>自己的理解:</strong></p>
<p><strong>行锁就是锁住聚集索引索引对应的行数据如果是从二级索引开始上锁</strong></p>
<p><strong>那么要通过索引对应的主键回表查询到聚集索引对应的行数据</strong></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afb9euuzj20mr03rmxt.jpg" alt="image-20220516183027448"></p>
<h4 id="1-2间隙锁-Gap-Lock"><a href="#1-2间隙锁-Gap-Lock" class="headerlink" title="1.2间隙锁(Gap Lock)"></a>1.2间隙锁(Gap Lock)</h4><p>锁定索引记录间隙(不含该记录),确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读.</p>
<p>在RR隔离级别下都支持</p>
<p>​       <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afehj6x7j20qo03kgmb.jpg" alt="image-20220516183333703"></p>
<h4 id="1-3临键锁-Next-Key-Lock"><a href="#1-3临键锁-Next-Key-Lock" class="headerlink" title="1.3临键锁(Next-Key Lock)"></a>1.3临键锁(Next-Key Lock)</h4><p>行锁和间隙锁组合,同时锁住数据,并锁住数据前面的间隙Gap.在RR隔离级别下支持**(行锁和间隙锁的组合)**</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2affu842oj20qo03qgmb.jpg" alt="image-20220516183451619"></p>
<h3 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2)行锁"></a>2)行锁</h3><p>InnoDB实现了一下两种类型的行锁:</p>
<h4 id="2-1共享锁-S"><a href="#2-1共享锁-S" class="headerlink" title="2.1共享锁(S)"></a>2.1共享锁(S)</h4><p>允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.</p>
<p>简单理解就是,共享锁之间是兼容的,共享锁和排他锁是互斥的</p>
<h4 id="2-2排他锁-X"><a href="#2-2排他锁-X" class="headerlink" title="2.2排他锁(X)"></a>2.2排他锁(X)</h4><p>允许获取排他锁的事务更新数据,组织其他事务获得相同的数据集的共享锁和排他锁. </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afl6o5dnj20nc055jrl.jpg" alt="image-20220516183959691"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afpo7dhqj20wg065mxu.jpg" alt="image-20220516184418623"></p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afysg3ltj20vs03k3z6.jpg" alt="image-20220516185304652"></p>
<hr>
<h4 id="3-间隙锁-x2F-临键锁-演示"><a href="#3-间隙锁-x2F-临键锁-演示" class="headerlink" title="3)间隙锁&#x2F;临键锁-演示"></a>3)间隙锁&#x2F;临键锁-演示</h4><hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag1wtzlvj20q303j3yx.jpg" alt="image-20220516185604366"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag21w7q8j20x8011t91.jpg" alt="image-20220516185612478"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2agddsvkuj20ji0exmyw.jpg" alt="image-20220516190705735"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/13/Mysql%E7%9A%84Sql%E4%BC%98%E5%8C%96/">Mysql的Sql优化</a>
            </div>
            <p class="sub">May 13 2022</p>
            <div class="post-content">
                
                    <h1 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h1><ul>
<li><p>insert优化</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5gdckvkj20ep0bzq3q.jpg" alt="image-20220513213453462"></p>
</li>
</ul>
<p>经量减少网络之间的I&#x2F;O传输,可以提高性能</p>
<ul>
<li>大批量插入数据</li>
</ul>
<p>如果需要一次性大批量插入数据,使用insert语句插入性能较低,此时可以使用MYSQL数据库提供的load指令进行插入.操作如下;</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g91h2dj20vn06ftar.jpg" alt="image-20220513213651727"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#客户端连接服务器时,加上参数 --local-infile</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line">#设置全局参数local_infile为1.开启从本地加载文件导入数据的开关(默认关闭的)</span><br><span class="line">set global local_infile = 1;</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@local_infile</span><br><span class="line">    -&gt; ;</span><br><span class="line">+----------------+</span><br><span class="line">| @@local_infile |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |     -------------&gt;设置为1</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">#执行load指令将准备好的数据,加载到表就诶够中</span><br><span class="line">load data local infeil &#x27;/root/sql.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line">					       #文件位置                     到那张表           字段用什么分隔              每一行用什么分隔</span><br></pre></td></tr></table></figure>

<p><strong>主键顺序插入性能高于乱序插入</strong></p>
<h1 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h1><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>​    在InnoDB存储引擎中,表数据都是根据主键顺序存放的,这种存储方式的表称为<strong>索引组织表</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g5lvquj20tg0ca75y.jpg" alt="image-20220516093022006"></p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,可以填充一半,也可以填充100%.每个页包含了2-N行数据(如果一行数据过多,会行溢出),根据主键排列</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fy2n63j20wj0580tf.jpg" alt="image-20220516093248234"></p>
<p>如果主键不是顺序插入,那么新插入过来的数据,会找出比自己小一级的那个页,截取50%的内容</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fva5qcj20uj0af0tf.jpg" alt="image-20220516093713899"></p>
<p>并开辟一个新的页空间,然后和截取的那一部分一同存入新的页空间中,最后被截取的那部分页再重新指向那段新的页空间.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fstyg2j20w808v757.jpg" alt="image-20220516093818505"></p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>当删除一行记录时,实际上记录并没有被屋里删除,只是记录被标记为删除,并且它的空间变得允许其他记录声明使用.</p>
<p>当页中删除的记录达到了MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找靠近的页(前或后)看看是否可以合并,以优化空间使用.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fo5ng1j20w10333z9.jpg" alt="image-20220516094302614"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fmeqh8j20ww058dgi.jpg" alt="image-20220516094319791"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fhtxesj20xs09gmyn.jpg" alt="image-20220516094410407"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加索引的时候设置(默认百分之50)</span><br><span class="line">create index ix_person_birthday on tempdb.person(birthday) comment &#x27;MERGE_THRESHOLD=48&#x27;</span><br><span class="line"></span><br><span class="line">#可以从information_schema中查询索引页的合并阀值</span><br><span class="line">select * from INNODB_INDEXES where name in (&#x27;ix_person_name&#x27;,&#x27;ix_person_birthday&#x27;) ;</span><br><span class="line">+----------+--------------------+----------+------+----------+---------+-------+-----------------+</span><br><span class="line">| INDEX_ID | NAME               | TABLE_ID | TYPE | N_FIELDS | PAGE_NO | SPACE | MERGE_THRESHOLD |</span><br><span class="line">+----------+--------------------+----------+------+----------+---------+-------+-----------------+</span><br><span class="line">|      147 | ix_person_name     |     1059 |    0 |        2 |       5 |     2 |              45 |</span><br><span class="line">|      148 | ix_person_birthday |     1059 |    0 |        2 |       6 |     2 |              48 |</span><br><span class="line">+----------+--------------------+----------+------+----------+---------+-------+-----------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h1 id="主键的设计原则"><a href="#主键的设计原则" class="headerlink" title="主键的设计原则"></a>主键的设计原则</h1><p>1.满足业务需求的情况下,尽量降低主键的长度,主键长度过长,当二级索引较多时,会占用大量的磁盘空间,而且在搜索的时候会耗费大量的磁盘IO,所以要尽量降低主键的长度</p>
<p>2.插入数据时,尽量选择顺序插入,选择使用AUTO_INCREMENT自增主键,如果不是顺序插入,可能会出现页分裂现象</p>
<p>3.尽量不要用UUID做主键或者其他自然主键,如身份证号,因为这些数据都是无序的,就会导致页分裂,数据过长,检索时间增加,也会增加磁盘IO</p>
<p>4.在业务操作时,避免对主键的修改,应为修改主键也会改变对应的索引结构,代价很大</p>
<h1 id="mysql8-0新特性——-gt-order-by优化"><a href="#mysql8-0新特性——-gt-order-by优化" class="headerlink" title="mysql8.0新特性——-&gt;order by优化"></a>mysql8.0新特性——-&gt;order by优化</h1><p>1.Using filesort:通过表的索引或全表扫描,读取满足条件的数据行,然后再排序缓冲区sort buffer中完成排序操作,所有不是通过索引直接返回结果的排序都叫FileSort排序</p>
<p>2,Using index:通过有序索引顺序扫描直接返回的有序数据,这种情况下即为Using index,不需要额外排序,操作小效率高</p>
<h3 id="新特性一-Backward-index-scan关键字"><a href="#新特性一-Backward-index-scan关键字" class="headerlink" title="新特性一:Backward  index scan关键字"></a>新特性一:Backward  <em>index</em> <em>scan</em>关键字</h3><p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong>Using index</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong><em>Backward</em> <em>index</em> <em>scan</em>,Using index</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Backward index scan,Using index |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在8.0中,对于反向扫描,有一个专门的词进行描述“<em><strong>Backward* <em>index</em> *scan</strong></em>“反向索引扫描,5.7版本没有</p>
<h3 id="新特性二-支持反向索引"><a href="#新特性二-支持反向索引" class="headerlink" title="新特性二:支持反向索引"></a>新特性二:支持反向索引</h3><p>当我们向通过一个字段升序ASC,一个字段降序DESC,或者反之,需要通过创建索引的时候指定,不然会出现全表扫描Using filesort关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select phone,id_number from employee order by phone asc  ,id_number desc;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">#按照上面需求创建降序联合索引</span><br><span class="line">create index  idx_phone_id_numbe on employee(phone asc,id_number desc); #-------&gt; 指定那个字段降序 </span><br><span class="line">#再次查询索引信息发现Collation字段A代表ASC,D代表DESC </span><br><span class="line">mysql&gt; show index from employee;</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| employee |          0 | PRIMARY              |                   1 | id         		 | A         |          15 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| employee |          1 | idx_phone_id_number  |            1 | phone      		 | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| employee |          1 | idx_phone_id_number  |            2 | id_number       | D        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-</span><br></pre></td></tr></table></figure>

<p>在<strong>Mysql5.7</strong>中支持此语法,但是设置降序索引时,还是创建的升序,并没有改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create index  idx_phone_id_numbe on employee(phone asc,id_number desc)</span><br><span class="line">mysql&gt; show index from employee;</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| employee |          0 | PRIMARY              |                   1 | id         		 | A         |          15 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| employee |          1 | idx_phone_id_number  |            1 | phone      		 | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| employee |          1 | idx_phone_id_number  |            2 | id_number       | A        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-</span><br></pre></td></tr></table></figure>

<p>图解:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5f3m94kj20wv074gms.jpg" alt="image-20220516105542348"></p>
<h3 id="ORDER-BY注意事项"><a href="#ORDER-BY注意事项" class="headerlink" title="ORDER BY注意事项"></a>ORDER BY注意事项</h3><p><strong>事项一</strong>:根据排序字段建立合适的索引,多字段排序时,<strong>应当遵循最左前缀法则</strong>,不然虽然会走索引但是会出现<strong>Using filesort</strong></p>
<p>降低了查询效率.<strong>(前提是索引覆盖)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select phone,id_number from employee order by id_number,phone ;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>事项二</strong>:如果没有遵循最左前缀也没有达到索引覆盖条件,则会全表扫描,<strong>索引尽量要索引覆盖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from employee order by id_number,phone ;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>事项三</strong>:多字段排序时,一个升序一个降序,此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)</p>
<p><strong>事项四</strong>:如果不可避免的出现filesort,大数据量排序时,<strong>可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</strong>,如果在排序时,占满了256k的排序缓冲区,则会涉及到磁盘文件当中进行排序,会降低性能,可以适量增大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#默认排序缓冲区大小sort_buffer_size为256k</span><br><span class="line">mysql&gt; show variables like &#x27;sort_buffer_size&#x27;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| sort_buffer_size | 262144 |</span><br><span class="line">+------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h1><p>1,在分组时,也可以通过索引来提高效率,如果没有索引则会出现 <strong>Using temporary</strong>临时表关键字,效率低下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select name,count(*) from employee group by name;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>2.分组操作时,索引的使用也是满足最左前缀法则的</p>
<p>情况一:索引没有满足最左前缀,但满足索引覆盖(Using index; Using temporary; Using filesort)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysql&gt; explain select  id_number,count(*) from employee group by id_number;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                                        |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>情况二:索引满足最左前缀,也满足索引覆盖(Using index )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select  phone,count(*) from employee group by phone;</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h1><p>一个常见有非常头疼的问题就是limit 200000,10 ,此时mysql排序前200000,10 记录,仅仅返回200000,200010的记录,其他记录丢弃,查询排序的代价非常大</p>
<p>优化思路:一般分页查询时,通过创建覆盖所以,能够比较好的提高性能,可以通过覆盖索引加子查询形式优化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_sku t,(select id from tb_sku order by id limit 200000,10)  a  where t.id = a.id;</span><br></pre></td></tr></table></figure>

<p>mysql官方给出的优化方案</p>
<h1 id="Count优化"><a href="#Count优化" class="headerlink" title="Count优化"></a>Count优化</h1><h3 id="COUNT的几种用法"><a href="#COUNT的几种用法" class="headerlink" title="COUNT的几种用法"></a>COUNT的几种用法</h3><p>![image-20220516113046371](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220516113046371.png)</p>
<h1 id="update优化-InnoDB中索引-行锁-表锁的关系"><a href="#update优化-InnoDB中索引-行锁-表锁的关系" class="headerlink" title="update优化(InnoDB中索引-行锁-表锁的关系)"></a>update优化(InnoDB中索引-行锁-表锁的关系)</h1><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p>Mysql中的InnoDB引擎<strong>默认是行级锁</strong>,当一个客户端通过主键id修改一个条数据时,这条数据会被锁上,另一个客户端通过<strong>同一个ID修改</strong>这个被锁住的数据时,就会堵塞**(如果是不同id则不会阻塞)**</p>
<p>客户端A:条件相同</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ewvch5j20jj078q43.jpg" alt="image-20220516114611297"></p>
<p>客户端B:条件相同</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ei8t8gj20l108j40e.jpg" alt="image-20220516114824459"></p>
<p>等待一段时间后会抛出:ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction(等待超时)</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>当一个客户端通过名字name修改一个条数据时,这条数据会被锁上,另一个客户端修改<strong>另一条数据</strong>通过<strong>另一个名字name修改,发现也会阻塞</strong>,这是为什么呢????</p>
<blockquote>
<p>因为InnoDB的行锁针对索引加锁,不是针对记录加的锁,并且改索引不能失效,否则会从行锁升级为表说</p>
<p>也就是只要你的条件不是索引字段,那么这一次操作则会锁住整张表</p>
</blockquote>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/12/Redis%E4%BD%BF%E7%94%A8/">Redis使用</a>
            </div>
            <p class="sub">May 12 2022</p>
            <div class="post-content">
                
                    <h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul>
<li>Redis入门</li>
<li>Redis数据类型</li>
<li>Redis常用命令</li>
<li>在Java中操作Redis</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis"></a>1.1 什么是Redis</h3><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件，它是「<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice」的首字母缩写，也就是「远程字典服务」。</p>
<ul>
<li><input disabled="" type="checkbox"> 基于内存存储，读写性能高</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sbs9ygj20b106v74l.jpg" alt="image-20210927090555559"></p>
<ul>
<li><input disabled="" type="checkbox"> 适合存储热点数据（热点商品、资讯、新闻）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5scrk8rj20bk07o0tn.jpg" alt="image-20210927090604994"></p>
<ul>
<li><input disabled="" type="checkbox"> 企业应用广泛</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sdng30j20c007o74l.jpg" alt="image-20210927090612540"></p>
<h3 id="1-2-使用Redis能做什么"><a href="#1-2-使用Redis能做什么" class="headerlink" title="1.2 使用Redis能做什么"></a>1.2 使用Redis能做什么</h3><ul>
<li>数据缓存</li>
<li>消息队列</li>
<li>注册中心</li>
<li>发布订阅</li>
</ul>
<h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-Redis简介"><a href="#2-1-Redis简介" class="headerlink" title="2.1 Redis简介"></a>2.1 Redis简介</h3><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. 翻译为：Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io</a></p>
<p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p>
<p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p>
<p>关系型数据库(RDBMS)：</p>
<ul>
<li>Mysql</li>
<li>Oracle</li>
<li>DB2</li>
<li>SQLServer</li>
</ul>
<p>非关系型数据库(NoSql)：</p>
<ul>
<li>Redis</li>
<li>Mongo db</li>
<li>MemCached</li>
</ul>
<h3 id="2-2-Redis下载与安装"><a href="#2-2-Redis下载与安装" class="headerlink" title="2.2 Redis下载与安装"></a>2.2 Redis下载与安装</h3><h4 id="2-2-1-Redis下载"><a href="#2-2-1-Redis下载" class="headerlink" title="2.2.1 Redis下载"></a>2.2.1 Redis下载</h4><p>Redis安装包分为windows版和Linux版：</p>
<ul>
<li>Windows版下载地址：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li>
<li>Linux版下载地址： <a target="_blank" rel="noopener" href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li>
</ul>
<p>下载后得到下面安装包：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sj9t3rj20ug02jq34.jpg" alt="image-20210927092053283"></p>
<h4 id="2-2-2-Redis安装"><a href="#2-2-2-Redis安装" class="headerlink" title="2.2.2 Redis安装"></a>2.2.2 Redis安装</h4><p><strong>1）在Linux中安装Redis</strong></p>
<p>在Linux系统安装Redis步骤：</p>
<ol>
<li>将Redis安装包上传到Linux</li>
<li>解压安装包，命令：&#x3D;&#x3D;tar -zxvf redis-4.0.0.tar.gz -C &#x2F;usr&#x2F;local&#x3D;&#x3D;</li>
<li>安装Redis的依赖环境gcc，命令：&#x3D;&#x3D;yum install -y gcc-c++&#x3D;&#x3D;</li>
<li>进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0，进行编译，命令：&#x3D;&#x3D;make&#x3D;&#x3D;</li>
<li>进入redis的src目录进行安装，命令：&#x3D;&#x3D;make install&#x3D;&#x3D;</li>
</ol>
<p>安装后重点文件说明：</p>
<blockquote>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-server：Redis服务启动脚本</p>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-cli：Redis客户端脚本</p>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;redis.conf：Redis配置文件</p>
</blockquote>
<p><strong>2）在Windows中安装Redis</strong></p>
<p>Redis的Windows版属于绿色软件，直接解压即可使用，解压后目录结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sl2swwj20sp0bqq48.jpg" alt="image-20210927093112281"></p>
<h3 id="2-3-Redis服务启动与停止"><a href="#2-3-Redis服务启动与停止" class="headerlink" title="2.3 Redis服务启动与停止"></a>2.3 Redis服务启动与停止</h3><p><strong>1）Linux系统中启动和停止Redis</strong></p>
<p>执行Redis服务启动脚本文件&#x3D;&#x3D;redis-server&#x3D;&#x3D;：</p>
<p><code>路径：</code></p>
<p><code>/usr/local/redis-4.0.0/src/redis-server</code></p>
<p><code>/usr/local/redis-4.0.0/src/redis-cli</code></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5spmhpoj216c0k4jxz.jpg" alt="image-20210927094452556"></p>
<p>通过启动日志可以看到，Redis默认端口号为&#x3D;&#x3D;6379&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p>
<p>通过&#x3D;&#x3D;redis-cli&#x3D;&#x3D;可以连接到本地的Redis服务，默认情况下不需要认证即可连接成功。</p>
<p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p>
<p><strong>2）Windows系统中启动和停止Redis</strong></p>
<p>Windows系统中启动Redis，直接双击redis-server.exe即可启动Redis服务，redis服务默认端口号为6379</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqhzd8j20xz0hrdix.jpg" alt="image-20210927100421213"></p>
<p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p>
<p>双击&#x3D;&#x3D;redis-cli.exe&#x3D;&#x3D;即可启动Redis客户端，默认连接的是本地的Redis服务，而且不需要认证即可连接成功。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqsuvzj20xz0hr0t8.jpg" alt="image-20210927100319016"></p>
<p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p>
<h3 id="2-4-Redis配置文件"><a href="#2-4-Redis配置文件" class="headerlink" title="2.4 Redis配置文件"></a>2.4 Redis配置文件</h3><p>前面我们已经启动了Redis服务，默认情况下Redis启动后是在前台运行，而且客户端不需要密码就可以连接到Redis服务。如果我们希望Redis服务启动后是在后台运行，同时希望客户端认证通过后才能连接到Redis服务，应该如果做呢？</p>
<p>此时就需要修改Redis的配置文件：</p>
<ul>
<li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li>
<li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li>
</ul>
<p><strong>通过修改Redis配置文件可以进行如下配置：</strong></p>
<p><strong>1）</strong>设置Redis服务后台运行</p>
<p>​    将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p>
<p>​    注意：Windows版的Redis不支持后台运行。</p>
<p><strong>2）</strong>设置Redis服务密码</p>
<p>​    将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p>
<p><strong>3）</strong>设置允许客户端远程连接Redis服务</p>
<p>​    Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p>
<p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p>
<p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p>
<p>requirepass：设置Redis的连接密码</p>
<p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p>
</blockquote>
<p><strong>注意</strong>：修改配置文件后需要重启Redis服务配置才能生效，&#x3D;&#x3D;并且&#x3D;&#x3D;启动Redis服务时需要显示的指定配置文件：</p>
<p>1）Linux中启动Redis服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入Redis安装目录</span><br><span class="line">cd /usr/local/redis-4.0.0</span><br><span class="line"># 启动Redis服务，指定使用的配置文件</span><br><span class="line">./src/redis-server ./redis.conf</span><br></pre></td></tr></table></figure>

<p>2）Windows中启动Redis服务</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ssqiloj20xz0e4dit.jpg" alt="image-20210927104929169"></p>
<p>由于Redis配置文件中开启了认证校验，即客户端连接时需要提供密码，此时客户端连接方式变为：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sti807j20ny09uq3j.jpg" alt="image-20210927105909600"></p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>-h：指定连接的Redis服务的ip地址</p>
<p>-p：指定连接的Redis服务的端口号</p>
<p>-a：指定连接的Redis服务的密码</p>
</blockquote>
<h2 id="3-Redis数据类型"><a href="#3-Redis数据类型" class="headerlink" title="3. Redis数据类型"></a>3. Redis数据类型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p>
<ul>
<li>字符串 string</li>
<li>哈希 hash</li>
<li>列表 list</li>
<li>集合 set</li>
<li>有序集合 sorted set &#x2F; zset</li>
</ul>
<h3 id="3-2-Redis-5种常用数据类型"><a href="#3-2-Redis-5种常用数据类型" class="headerlink" title="3.2 Redis 5种常用数据类型"></a>3.2 Redis 5种常用数据类型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5svuyd2j20od0e50tf.jpg" alt="image-20210927111819871"></p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>字符串(string)：普通字符串，常用</p>
<p>哈希(hash)：适合存储对象</p>
<p>列表(list)：按照插入顺序排序，可以有重复元素</p>
<p>集合(set)：无序集合，没有重复元素</p>
<p>有序集合(sorted set &#x2F; zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</p>
</blockquote>
<h2 id="4-Redis常用命令"><a href="#4-Redis常用命令" class="headerlink" title="4. Redis常用命令"></a>4. Redis常用命令</h2><h3 id="4-1-字符串string操作命令"><a href="#4-1-字符串string操作命令" class="headerlink" title="4.1 字符串string操作命令"></a>4.1 字符串string操作命令</h3><p>Redis 中字符串类型常用命令：</p>
<ul>
<li><strong>SET</strong> key value                              设置指定key的值</li>
<li><strong>GET</strong> key                                        获取指定key的值</li>
<li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li>
<li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li>
</ul>
<p>更多命令可以参考Redis中文网：<a target="_blank" rel="noopener" href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p>
<h3 id="4-2-哈希hash操作命令"><a href="#4-2-哈希hash操作命令" class="headerlink" title="4.2 哈希hash操作命令"></a>4.2 哈希hash操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p>
<ul>
<li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li>
<li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li>
<li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li>
<li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li>
<li><strong>HVALS</strong> key                              获取哈希表中所有值</li>
<li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t21hlmj20m503jmx3.jpg" alt="image-20210927113014567"></p>
<h3 id="4-3-列表list操作命令"><a href="#4-3-列表list操作命令" class="headerlink" title="4.3 列表list操作命令"></a>4.3 列表list操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p>
<ul>
<li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li>
<li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li>
<li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li>
<li><strong>LLEN</strong> key                                        获取列表长度</li>
<li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t3ub6oj20nh042t8n.jpg" alt="image-20210927113312384"></p>
<p>list特点：双端阻塞队列</p>
<p>操作技巧：FIFO，先进先出。</p>
<h3 id="4-4-集合set操作命令"><a href="#4-4-集合set操作命令" class="headerlink" title="4.4 集合set操作命令"></a>4.4 集合set操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p>
<ul>
<li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li>
<li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li>
<li><strong>SCARD</strong> key                                                  获取集合的成员数</li>
<li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li>
<li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li>
<li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li>
<li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t66f4mj20ma03xgli.jpg" alt="image-20210927113632472"></p>
<h3 id="4-5-有序集合sorted-set操作命令"><a href="#4-5-有序集合sorted-set操作命令" class="headerlink" title="4.5 有序集合sorted set操作命令"></a>4.5 有序集合sorted set操作命令</h3><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p>
<p>常用命令：</p>
<ul>
<li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li>
<li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li>
<li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li>
<li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t72qyej20ng04pt8n.jpg" alt="image-20210927114003383"></p>
<h3 id="4-6-通用命令"><a href="#4-6-通用命令" class="headerlink" title="4.6 通用命令"></a>4.6 通用命令</h3><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p>
<ul>
<li><p><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </p>
</li>
<li><p><strong>EXISTS</strong> key  检查给定 key 是否存在</p>
</li>
<li><p><strong>TYPE</strong> key  返回 key 所储存的值的类型</p>
</li>
<li><p><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</p>
</li>
<li><p><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</p>
<p><code>keys * 引发的宕机事故：</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014756578/article/details/91951793">https://blog.csdn.net/u014756578/article/details/91951793</a></p>
</li>
</ul>
<h2 id="5-在Java中操作Redis"><a href="#5-在Java中操作Redis" class="headerlink" title="5. 在Java中操作Redis"></a>5. 在Java中操作Redis</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p>
<p>Redis 的 Java 客户端很多，官方推荐的有三种：</p>
<ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p>
<h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p>
<p>maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 Jedis 操作 Redis 的步骤：</p>
<ol>
<li>获取连接</li>
<li>执行操作</li>
<li>关闭连接</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jedis操作Redis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 执行具体的操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis.del(&quot;username&quot;);</span></span><br><span class="line"></span><br><span class="line">        jedis.hset(<span class="string">&quot;myhash&quot;</span>,<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hValue</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;addr&quot;</span>);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-Spring-Data-Redis"><a href="#5-3-Spring-Data-Redis" class="headerlink" title="5.3 Spring Data Redis"></a>5.3 Spring Data Redis</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p>
<p>网址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tadff7j21810r67b7.jpg" alt="image-20210927143741458"></p>
<p>maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot提供了对应的Starter，maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p>
<ul>
<li>ValueOperations：简单K-V操作</li>
<li>SetOperations：set类型数据操作</li>
<li>ZSetOperations：zset类型数据操作</li>
<li>HashOperations：针对hash类型的数据操作</li>
<li>ListOperations：针对list类型的数据操作</li>
</ul>
<h4 id="5-3-2-使用方式"><a href="#5-3-2-使用方式" class="headerlink" title="5.3.2 使用方式"></a>5.3.2 使用方式</h4><h5 id="5-3-2-1-环境搭建"><a href="#5-3-2-1-环境搭建" class="headerlink" title="5.3.2.1 环境搭建"></a>5.3.2.1 环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataredis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：编写启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：配置application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springdataredis_demo</span></span><br><span class="line">  <span class="comment">#Redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#操作的是0号数据库</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="comment">#Redis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">4</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure>

<p>解释说明：</p>
<blockquote>
<p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p>
<p>可以通过修改Redis配置文件来指定数据库的数量。</p>
</blockquote>
<p>第四步：提供配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释说明：</p>
<blockquote>
<p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p>
</blockquote>
<p>第五步：提供测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-2-操作字符串类型数据"><a href="#5-3-2-2-操作字符串类型数据" class="headerlink" title="5.3.2.2 操作字符串类型数据"></a>5.3.2.2 操作字符串类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作String类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>,<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;city123&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，同时设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="number">10l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，如果存在则不执行任何操作</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;city1234&quot;</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    System.out.println(aBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-3-操作哈希类型数据"><a href="#5-3-2-3-操作哈希类型数据" class="headerlink" title="5.3.2.3 操作哈希类型数据"></a>5.3.2.3 操作哈希类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Hash类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有字段</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有值</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-4-操作列表类型数据"><a href="#5-3-2-4-操作列表类型数据" class="headerlink" title="5.3.2.4 操作列表类型数据"></a>5.3.2.4 操作列表类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作List类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    List&lt;String&gt; mylist = listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String value : mylist) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得列表长度 llen</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> size.intValue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">        <span class="comment">//出队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-5-操作集合类型数据"><a href="#5-3-2-5-操作集合类型数据" class="headerlink" title="5.3.2.5 操作集合类型数据"></a>5.3.2.5 操作集合类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Set类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-6-操作有序集合类型数据"><a href="#5-3-2-6-操作有序集合类型数据" class="headerlink" title="5.3.2.6 操作有序集合类型数据"></a>5.3.2.6 操作有序集合类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作ZSet类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">11.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">12.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">13.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改分数</span></span><br><span class="line">    zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-3-2-7-通用操作"><a href="#5-3-2-7-通用操作" class="headerlink" title="5.3.2.7 通用操作"></a>5.3.2.7 通用操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用操作，针对不同的数据类型都可以操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取Redis中所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个key是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">itcast</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定key</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定key对应的value的数据类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/12/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux的常用命令</a>
            </div>
            <p class="sub">May 12 2022</p>
            <div class="post-content">
                
                    <h4 id="停止防火墙"><a href="#停止防火墙" class="headerlink" title="#停止防火墙"></a>#停止防火墙</h4><p>systemctl stop firewalld</p>
<h4 id="禁用防火墙开机启动"><a href="#禁用防火墙开机启动" class="headerlink" title="#禁用防火墙开机启动"></a>#禁用防火墙开机启动</h4><p>systemctl disable firewalld</p>
<h4 id="停止网络管理器"><a href="#停止网络管理器" class="headerlink" title="#停止网络管理器"></a>#停止网络管理器</h4><p>systemctl stop NetworkManager</p>
<h4 id="禁止开机自启"><a href="#禁止开机自启" class="headerlink" title="#禁止开机自启"></a>#禁止开机自启</h4><p>systemctl disable NetworkManager</p>
<h4 id="加压jdk"><a href="#加压jdk" class="headerlink" title="#加压jdk"></a>#加压jdk</h4><p>tar -zxvf jdk-8u171-linux-x64.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="配置jdk的环境变量"><a href="#配置jdk的环境变量" class="headerlink" title="#配置jdk的环境变量"></a>#配置jdk的环境变量</h4><p>echo ‘JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p>
<h4 id="重新加载文件"><a href="#重新加载文件" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p>
<h4 id="查看jdk版本"><a href="#查看jdk版本" class="headerlink" title="#查看jdk版本"></a>#查看jdk版本</h4><p>java -version</p>
<h4 id="解压tomcat"><a href="#解压tomcat" class="headerlink" title="#解压tomcat"></a>#解压tomcat</h4><p>tar -zxvf apache-tomcat-7.0.57.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="卸载mariadb数据库"><a href="#卸载mariadb数据库" class="headerlink" title="#卸载mariadb数据库"></a>#卸载mariadb数据库</h4><p>rpm -e –nodeps  <code>rpm -qa | grep mariadb</code></p>
<h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="#创建文件夹"></a>#创建文件夹</h4><p>mkdir &#x2F;usr&#x2F;local&#x2F;mysql</p>
<h4 id="解压mysql"><a href="#解压mysql" class="headerlink" title="#解压mysql"></a>#解压mysql</h4><p>tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C &#x2F;usr&#x2F;local&#x2F;mysql</p>
<h4 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="#安装依赖环境"></a>#安装依赖环境</h4><p>yum install -y net-tools perl libaio openssl gcc pcre-devel zlib-devel openssl vim openssl-devel</p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="#安装mysql"></a>#安装mysql</h4><p>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-common-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-devel-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-client-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-server-5.7.25-1.el7.x86_64.rpm</p>
<h4 id="开启mysql服务"><a href="#开启mysql服务" class="headerlink" title="#开启mysql服务"></a>#开启mysql服务</h4><p>systemctl start mysqld</p>
<h4 id="查看临时密码"><a href="#查看临时密码" class="headerlink" title="#查看临时密码"></a>#查看临时密码</h4><p>cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</p>
<h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="#登录数据库"></a>#登录数据库</h4><p>mysql -uroot -p</p>
<pre><code>set global validate_password_length=4;
set global validate_password_policy=LOW;
set password = password(&#39;root&#39;);
grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;
flush privileges;
</code></pre>
<h4 id="修改MySQL编码"><a href="#修改MySQL编码" class="headerlink" title="#修改MySQL编码"></a>#修改MySQL编码</h4><p>vim &#x2F;etc&#x2F;my.cnf</p>
<pre><code>[client]
default_character_set=utf8

[mysql]
default_character_set=utf8

[mysqld]
character_set_server=utf8
</code></pre>
<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="#重启服务"></a>#重启服务</h4><p>systemctl restart mysqld</p>
<h4 id="查看数据库编码"><a href="#查看数据库编码" class="headerlink" title="#查看数据库编码"></a>#查看数据库编码</h4><p>mysql -uroot -proot -e “show variables like ‘%char%’;”</p>
<h4 id="安装git"><a href="#安装git" class="headerlink" title="#安装git"></a>#安装git</h4><p>yum install -y git</p>
<h4 id="解压maven"><a href="#解压maven" class="headerlink" title="#解压maven"></a>#解压maven</h4><p>tar -zxvf apache-maven-3.5.4-bin.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="配置maven环境变量"><a href="#配置maven环境变量" class="headerlink" title="#配置maven环境变量"></a>#配置maven环境变量</h4><p>echo ‘MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p>
<h4 id="重新加载文件-1"><a href="#重新加载文件-1" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p>
<h4 id="查看maven版本"><a href="#查看maven版本" class="headerlink" title="#查看maven版本"></a>#查看maven版本</h4><p>mvn -v</p>
<h4 id="删除settings文件"><a href="#删除settings文件" class="headerlink" title="#删除settings文件"></a>#删除settings文件</h4><p>rm -rf &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p>
<h4 id="拷贝settings文件"><a href="#拷贝settings文件" class="headerlink" title="#拷贝settings文件"></a>#拷贝settings文件</h4><p>cp &#x2F;root&#x2F;settings.xml  &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p>
<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="#本地仓库"></a>#本地仓库</h4><p>mv &#x2F;root&#x2F;repo &#x2F;usr&#x2F;local</p>
<h4 id="修改静态IP"><a href="#修改静态IP" class="headerlink" title="#修改静态IP"></a>#修改静态IP</h4><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32</p>
<p> BOOTPROTO&#x3D;static<br> IPADDR&#x3D;192.168.100.100<br> GATEWAY&#x3D;192.168.100.2<br> NETMASK&#x3D;255.255.255.0<br> DNS1&#x3D;8.8.8.8</p>
<h4 id="重启网卡"><a href="#重启网卡" class="headerlink" title="#重启网卡"></a>#重启网卡</h4><p>systemctl restart network</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/NGINX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">NEGINX学习总结</a>
            </div>
            <p class="sub">May 11 2022</p>
            <div class="post-content">
                
                    <h2 id="Nginx-概述"><a href="#Nginx-概述" class="headerlink" title="Nginx-概述"></a>Nginx-概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q6nrd7j206t01pgli.jpg" alt="image-20210829234142590"> </p>
<p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>Nginx是由<strong>伊戈尔·赛索耶夫</strong>为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://nginx.org/">https://nginx.org/</a></p>
<h3 id="4-2-下载和安装"><a href="#4-2-下载和安装" class="headerlink" title="4.2 下载和安装"></a>4.2 下载和安装</h3><h4 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h4><p>在Nginx的官网的下载页面中(<a target="_blank" rel="noopener" href="http://nginx.org/en/download.html)%EF%BC%8C%E5%B0%B1%E5%B1%95%E7%A4%BA%E4%BA%86%E5%BD%93%E5%89%8DNginx%E7%89%88%E6%9C%AC%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82">http://nginx.org/en/download.html)，就展示了当前Nginx版本，并提供了下载的连接。</a> 如下： </p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q8htihj217c0inwk1.jpg" alt="image-20210829234623737" style="zoom:80%;" /> 

<p>在本项目中，我们所学习的Nginx选择的是稳定版本的1.16这个版本，我们可以直接从官网下载</p>
<h4 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2 安装"></a>4.2.2 安装</h4><p><strong>1). 安装依赖包</strong></p>
<p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>



<p><strong>2). 下载Nginx安装包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br><span class="line">wget https://nginx.org/download/nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wget : </p>
<p>​    wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。</p>
</blockquote>
<p>执行完wget指令后，就会在当前所在目录看到下载下来的文件。</p>
<p><strong>3). 解压nginx压缩包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>



<p><strong>4). 配置Nginx编译环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.16.1</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure>

<p>说明: </p>
<p>​    –prefix 指定的目录，就是我们安装Nginx的目录。</p>
<p><strong>5). 编译&amp;安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="4-3-目录结构"><a href="#4-3-目录结构" class="headerlink" title="4.3 目录结构"></a>4.3 目录结构</h3><p>安装完Nginx后，我们可以切换到Nginx的安装目录(&#x2F;usr&#x2F;local&#x2F;nginx)，先来熟悉一下Nginx的目录结构，如下图：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qd1z0zj21310jl78b.jpg" alt="image-20210830000933352" style="zoom:90%;" /> 

<blockquote>
<p>备注： </p>
<p>​    上述我们用到的一个指令 tree，该指令可以将我们指定的目录以树状结构展示出来。如果没有这个指令，可以通过以下指令进行安装。</p>
<p>​    yum install tree</p>
</blockquote>
<p>重点目录和文件如下: </p>
<table>
<thead>
<tr>
<th>目录&#x2F;文件</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>配置文件的存放目录</td>
<td></td>
</tr>
<tr>
<td>conf&#x2F;nginx.conf</td>
<td>Nginx的核心配置文件</td>
<td>conf下有很多nginx的配置文件，我们主要操作这个核心配置文件</td>
</tr>
<tr>
<td>html</td>
<td>存放静态资源(html, css, )</td>
<td>部署到Nginx的静态资源都可以放在html目录中</td>
</tr>
<tr>
<td>logs</td>
<td>存放nginx日志(访问日志、错误日志等)</td>
<td></td>
</tr>
<tr>
<td>sbin&#x2F;nginx</td>
<td>二进制文件，用于启动、停止Nginx服务</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-Nginx-命令"><a href="#5-Nginx-命令" class="headerlink" title="5. Nginx-命令"></a>5. Nginx-命令</h2><h3 id="5-1-常用命令"><a href="#5-1-常用命令" class="headerlink" title="5.1 常用命令"></a>5.1 常用命令</h3><p>Nginx中，我们的二进制可执行文件(nginx)存放在sbin目录下，虽然只有一个可执行文件，但是我们可以通过该指令配合不同的参数达到更加强大的功能。接下来，我们就演示一下Nginx常见指令, 在执行下面的指令时,都需要在&#x3D;&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;&#x3D;&#x3D;目录下执行。</p>
<p><strong>1). 查看版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qdraafj213002d0t9.jpg" alt="image-20210830223435585"> </p>
<p><strong>2). 检查配置文件</strong></p>
<p>修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf&#x2F;nginx.conf文件配置的是否有错误，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qfj1shj211z03u75q.jpg" alt="image-20210830223511878"> </p>
<p><strong>3). 启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p>启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qglixpj2139036t9x.jpg" alt="image-20210830224019661"> </p>
<p>注意： nginx服务启动后，默认就会有两个进程。</p>
<p>启动之后，我们可以直接访问Nginx的80端口， <a target="_blank" rel="noopener" href="http://192.168.200.200/">http://192.168.200.200</a></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qiatq9j20wg07e0u8.jpg" alt="image-20210830224605952" style="zoom:80%;" /> 



<blockquote>
<p>注意：</p>
<p>​    要想正常访问Nginx，需要关闭防火墙或开放指定端口号，执行的指令如下： </p>
<p>​    A. 关闭防火墙</p>
<p>​        systemctl stop firewalld</p>
<p>​    B. 开放80端口</p>
<p>​        firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p>
<p>​        firewall-cmd –reload</p>
</blockquote>
<p><strong>4). 停止</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure>

<p>停止之后，我们可以查看nginx的进程： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qkle8hj21550330tk.jpg" alt="image-20210830224121489"> </p>
<p><strong>5). 重新加载</strong></p>
<p>当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>在上述我们在使用nginx命令在进行服务的启动、停止、重新加载时，都需要用到一个指令nginx，而这个指令是在nginx&#x2F;sbin目录下的，我们每一次使用这个指令都需要切换到sbin目录才可以，使用相对繁琐。那么我们能不能在任意目录下都可以执行该指令来操作nginx呢？答案是可以的，配置nginx的环境变量即可。</p>
<p>通过vim编辑器，打开&#x2F;etc&#x2F;profile文件, 在PATH环境变量中增加nginx的sbin目录，如下： </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qmhcirj20v302wt9b.jpg" alt="image-20210830225544343"> </p>
<p>修改完配置文件之后，需要执行 source &#x2F;etc&#x2F;profile 使文件生效。 接下来，我们就可以在任意目录下执行nginx的指令了，如： </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qoam9sj2127043t9y.jpg" alt="image-20210830225702899"> </p>
<h2 id="6-Nginx-应用"><a href="#6-Nginx-应用" class="headerlink" title="6. Nginx-应用"></a>6. Nginx-应用</h2><p>介绍了并安装了Nginx之后，本章节将要讲解的是Nginx的使用，我们主要从以下四个方面进行讲解。</p>
<h3 id="6-1-配置文件结构"><a href="#6-1-配置文件结构" class="headerlink" title="6.1 配置文件结构"></a>6.1 配置文件结构</h3><p>nginx的配置文件(conf&#x2F;nginx.conf)整体上分为三部分: 全局块、events块、http块。这三块的分别配置什么样的信息呢，看下表： </p>
<table>
<thead>
<tr>
<th>区域</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>全局块</td>
<td>配置和nginx运行相关的全局配置</td>
</tr>
<tr>
<td>events块</td>
<td>配置和网络连接相关的配置</td>
</tr>
<tr>
<td>http块</td>
<td>配置代理、缓存、日志记录、虚拟主机等配置</td>
</tr>
</tbody></table>
<p>具体结构图如下: </p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qun39kj20rf0k7dj8.jpg" alt="image-20210830230827686" style="zoom:80%;" /> 

<blockquote>
<p>在全局块、events块以及http块中，我们经常配置的是http块。</p>
<p>在http块中可以包含多个server块,每个server块可以配置多个location块。</p>
</blockquote>
<h3 id="6-2-部署静态资源"><a href="#6-2-部署静态资源" class="headerlink" title="6.2 部署静态资源"></a>6.2 部署静态资源</h3><h4 id="6-2-1-介绍"><a href="#6-2-1-介绍" class="headerlink" title="6.2.1 介绍"></a>6.2.1 介绍</h4><p><strong>Nginx可以作为静态web服务器来部署静态资源</strong>。这里所说的静态资源是指在服务端真实存在，并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p>
<p><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</strong></p>
<p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;				#监听端口	</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">localhost;	#服务器名称</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;			#匹配客户端请求url</span></span><br><span class="line">        <span class="attr">root</span> <span class="string">html;			#指定静态资源根目录</span></span><br><span class="line">        <span class="attr">index</span> <span class="string">index.html;	#指定默认首页</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-测试"><a href="#6-2-2-测试" class="headerlink" title="6.2.2 测试"></a>6.2.2 测试</h4><p>在资料中，我们提供了一个静态的html文件，我们需要将这个文件部署到nginx中，然后通过nginx访问html静态资源。</p>
<p><strong>1). 将静态资源上传到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html 目录</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r16sh0j213v04qmyi.jpg" alt="image-20210830232238402"> </p>
<p><strong>2). 启动nginx</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r27gfuj214609dadc.jpg" alt="image-20210830232419462"> </p>
<p><strong>3). 访问</strong></p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/hello.html">http://192.168.100.100/hello.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r4itx5j20g605daa9.jpg" alt="image-20220220180550093"> </p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a> ， 访问该地址，访问的是nginx的默认首页</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r6eu4aj20lv0a8ta8.jpg" alt="image-20220220180207165"></p>
<p><strong>4). 配置首页</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r5ooaij20lv0a8ta8.jpg" alt="image-20210830232720821"> </p>
<p>如果我们需要将hello.html作为nginx的首页，可以修改location的index指令，配置为hello.html，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r9td6ij214609dadc.jpg" alt="image-20210830233019489"> </p>
<p>配置完毕后，我们可以通过指令，来检查配置文件是否配置正确： nginx -t</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r82i9mj214609dadc.jpg" alt="image-20210830233122708"> </p>
<p>配置文件修改了，我们需要重新加载一下，才可以生效： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p><strong>5). 访问</strong></p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5radelvj20h4054weq.jpg" alt="image-20220220180805583"> </p>
<h3 id="6-3-反向代理"><a href="#6-3-反向代理" class="headerlink" title="6.3 反向代理"></a>6.3 反向代理</h3><h4 id="6-3-1-概念介绍"><a href="#6-3-1-概念介绍" class="headerlink" title="6.3.1 概念介绍"></a>6.3.1 概念介绍</h4><p>1). 正向代理</p>
<p>正向代理服务器是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p><strong>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径</strong>。</p>
<p>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rdb0ajj20h507imxi.jpg" alt="image-20210830233450415"> </p>
<p>2). 反向代理</p>
<p>反向代理服务器位于用户与目标服务器之间，<strong>但是对于用户而言，反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。<strong>用户不需要知道目标服务器的地址，也无须在用户端作任何设定，对于用户来说，访问反向代理服务器是完全无感知的。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rewzahj20of09o754.jpg" alt="image-20210830233634695"> </p>
<p>那么在本小节，我们就是要使用nginx来作为反向代理服务器使用。 在nginx中，我们可以在nginx.conf中配置反向代理: </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">localhost;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://192.168.100.200:8080; 	#反向代理配置，将请求转发到指定服务</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述配置的含义为: 当我们访问nginx的80端口时，</p>
<p>根据反向代理配置，会将请求转发到 <a target="_blank" rel="noopener" href="http://192.168.100.200:8080/">http://192.168.100.200:8080</a> 对应的服务上。</p>
<h4 id="6-3-2-测试"><a href="#6-3-2-测试" class="headerlink" title="6.3.2 测试"></a>6.3.2 测试</h4><p>需求: 在192.168.100.200这台服务器中部署了java应用，运行端口为8080，并提供了一个可访问的链接 &#x2F;hello。现在我们需要在访问nginx时，通过nginx将请求转发到192.168.100.200:8080的服务。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rgs9s9j20rc06vq3j.jpg" alt="image-20210830235803013" style="zoom:67%;" /> 



<p><strong>1). 在192.168.100.200 部署服务并启动</strong></p>
<p>将资料中提供的 helloworld-8080.jar 上传到服务器端，并通过指令 java -jar helloworld-8080.jar 运行服务。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rmlqi8j21g40hu48d.jpg" alt="image-20210831000152199"> </p>
<p><strong>2). 在192.168.100.100中的nginx.conf中配置反向代理</strong></p>
<p>进入nginx的安装目录，并编辑配置文件nginx.conf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf/</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">localhost;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://192.168.100.200:8080; 	#反向代理配置，将请求转发到指定服务</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3). 检查配置文件，并重新加载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rnv8hxj213u02dmy1.jpg" alt="image-20210831001021252"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p><strong>4). 访问</strong> </p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a></p>
<h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><h4 id="6-4-1-概念介绍"><a href="#6-4-1-概念介绍" class="headerlink" title="6.4.1 概念介绍"></a>6.4.1 概念介绍</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p>
<p><strong>应用集群：</strong>将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p>
<p><strong>负载均衡器：</strong>将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rogb0lj213u02dmy1.jpg" alt="image-20210831080743617" style="zoom:80%;" />  

<p>此处的负载均衡器，我们将会使用Nginx来实现，而Nginx的负载均衡是基于反向代理的，只不过此时所代理的服务器不是一台，而是多台。</p>
<h4 id="6-4-2-测试"><a href="#6-4-2-测试" class="headerlink" title="6.4.2 测试"></a>6.4.2 测试</h4><p><strong>1). 将资料中提供的两个jar包，上传到 192.168.100.200 服务器上</strong></p>
<table>
<thead>
<tr>
<th>jar</th>
<th>运行端口</th>
<th>请求链接</th>
<th>响应数据</th>
</tr>
</thead>
<tbody><tr>
<td>![image-20220511211247384](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211247384.png)</td>
<td>8080</td>
<td>&#x2F;hello</td>
<td>8080</td>
</tr>
<tr>
<td>![image-20220511211258476](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211258476.png)</td>
<td>8081</td>
<td>&#x2F;hello</td>
<td>8081</td>
</tr>
</tbody></table>
<blockquote>
<p>我们在测试时，并没有那么多服务器，我们可以在一台服务器中启动多个服务，运行在不同的端口号上进行测试。</p>
</blockquote>
<p><strong>2). 运行上传上来的两个jar包，运行端口分别是 8080 ， 8081</strong></p>
<p>由于我们执行 java -jar 指令会占用前台窗口，所以我们可以采用后台模式运行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar helloworld-8080.jar &amp;&gt; helloworld-8080.log &amp;</span><br><span class="line"><span class="built_in">nohup</span> java -jar helloworld-8081.jar &amp;&gt; helloworld-8081.log &amp;</span><br></pre></td></tr></table></figure>





<p><strong>3). 在nginx中配置负载均衡</strong></p>
<p>打开nginx的配置文件nginx.conf并增加如下配置: </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#upstream指令可以定义一组服务器</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">targetserver&#123;	</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.100.200:8080;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.100.200:8081;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://targetserver;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>



<p>具体的配置位置如下: </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rsejyxj20qc08s0tf.jpg" alt="image-20220220182717939"> </p>
<p><strong>4). 重新加载nginx配置文件,访问</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>测试时,我们直接访问nginx(<a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a>), 此时nginx会根据负载均衡策略,将请求转发到后面的两台服务器。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5s04giaj20p403omxc.jpg" alt="image-20220220182548353"> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rrfbfhj20ow03v74g.jpg" alt="image-20220220182613070"> </p>
<p>在上述的测试过程中，我们看到请求均衡的转发到了8080和8081，因为模式的负载均衡策略是&#x3D;&#x3D;轮询&#x3D;&#x3D;。</p>
<p><font color="red" size="5">注意: 上述所有涉及到的端口号，都需要在对应的服务器的防火墙中开放，或者彻底关闭防火墙</font></p>
<h4 id="6-4-3-负载均衡策略"><a href="#6-4-3-负载均衡策略" class="headerlink" title="6.4.3 负载均衡策略"></a>6.4.3 负载均衡策略</h4><p>处理上述默认的轮询策略以外，在Nginx中还提供了其他的负载均衡策略，如下： </p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
<td></td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
<td>根据权重分发请求,权重大的分配到请求的概率大</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
<td>根据客户端请求的IP地址计算hash值， 根据hash值来分发请求, 同一个IP发起的请求, 会发转发到同一个服务器上</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
<td>哪个服务器当前处理的连接少, 请求优先转发到这台服务器</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式</td>
<td>根据客户端请求url的hash值，来分发请求, 同一个url请求, 会发转发到同一个服务器上</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
<td>优先把请求分发给处理请求时间短的服务器</td>
</tr>
</tbody></table>
<p>权重的配置： </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#upstream指令可以定义一组服务器</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">targetserver&#123;	</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.100.200:8080 weight=10;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.100.200:8081 weight=5;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述配置的weight权重是相对的，在上述的配置中，效果就是，在大数据量的请求下，最终8080接收的请求数是8081的两倍。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8CShardingJDBC/">数据库主从复制</a>
            </div>
            <p class="sub">May 11 2022</p>
            <div class="post-content">
                
                    <h2 id="1-MySQL主从复制"><a href="#1-MySQL主从复制" class="headerlink" title="1. MySQL主从复制"></a>1. MySQL主从复制</h2><p>MySQL数据库默认是支持主从复制的，不需要借助于其他的技术，我们只需要在数据库中简单的配置即可。接下来，我们就从以下的几个方面，来介绍一下主从复制：</p>
<h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的 <strong>二进制日志</strong> 功能。就是一台或多台MySQL数据库（slave，即<strong>从库</strong>）从另一台MySQL数据库（master，即<strong>主库</strong>）进行日志的复制，然后再解析日志并应用到自身，最终实现 <strong>从库</strong> 的数据和 <strong>主库</strong> 的数据保持一致。MySQL主从复制是<strong>MySQL数据库自带功能</strong>，无需借助第三方工具。</p>
<blockquote>
<p><strong>二进制日志：</strong> </p>
<p>​    二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句,包括改密码，<strong>但是不包括数据查询语句</strong>。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该<strong>binlog</strong>实现的。<strong>默认MySQL是未开启该日志的。</strong></p>
</blockquote>
<p><strong>MySQL的主从复制原理如下：</strong> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5jw19fkj20fk0amq3k.jpg" alt="image-20220511204640329"></p>
<p><strong>MySQL复制过程分成三步：</strong></p>
<p>1). MySQL master 将数据变更写入二进制日志( binary log)</p>
<p>2). slave将master的binary log拷贝到它的中继日志（relay log）</p>
<p>3). slave重做中继日志中的事件，将数据变更反映它自己的数据</p>
<h3 id="1-2-主库配置"><a href="#1-2-主库配置" class="headerlink" title="1.2 主库配置"></a>1.2 主库配置</h3><p> <strong>1)修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong>**</p>
<p>在[mysqld]下面增加配置: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin   #[必须]启用二进制日志</span><br><span class="line">server-id=100       #[必须]服务器唯一ID(唯一即可)</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k0049hj20jp0a3q4f.jpg" alt="image-20220511205023685"></p>
<p><strong>2)重启Mysql服务</strong></p>
<p>执行指令： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k3zn92j20uo01ujro.jpg" alt="image-20210825115853116"> </p>
<p><strong>3). 创建数据同步的用户并授权</strong></p>
<p>登录mysql，并执行如下指令，创建用户并授权：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;xiaoming&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;注：上面SQL的作用是创建一个用户 xiaoming ，密码为 Root@123456 ，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。&#x3D;&#x3D;</strong></p>
<blockquote>
<p>MySQL密码复杂程度说明: </p>
<p>​    <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k6qbwrj20ei03ejrt.jpg" alt="image-20210825144818269"> </p>
<p>​    目前mysql5.7默认密码校验策略等级为 MEDIUM , 该等级要求密码组成为: 数字、小写字母、大写字母 、特殊字符、长度至少8位</p>
</blockquote>
<p><strong>4). 登录Mysql数据库，查看master同步状态</strong></p>
<p>执行下面SQL，记录下结果中<strong>File</strong>和<strong>Position</strong>的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k927f8j20xe04fab1.jpg" alt="image-20210825120355600"> </p>
<p><strong>&#x3D;&#x3D;注：上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作&#x3D;&#x3D;</strong></p>
<h3 id="1-3从库配置"><a href="#1-3从库配置" class="headerlink" title="1.3从库配置"></a>1.3从库配置</h3><p><strong>1). 修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-id=200 	#[必须]服务器唯一ID</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kbw5z0j207p02ajrc.jpg" alt="image-20220220175414871"> </p>
<p><strong>2). 重启Mysql服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>



<p><strong>3). 登录Mysql数据库，设置主库地址及同步位置</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=<span class="string">&#x27;8.130.21.14&#x27;</span>,master_user=<span class="string">&#x27;xiaoming&#x27;</span>,master_password=<span class="string">&#x27;Root@123456&#x27;</span>,master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos=441;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明： </p>
<p>​    A. master_host : 主库的IP地址</p>
<p>​    B. master_user : 访问主库进行主从复制的用户名(上面在主库创建的)</p>
<p>​    C. master_password : 访问主库进行主从复制的用户名对应的密码</p>
<p>​    D. master_log_file : 从哪个日志文件开始同步(上述查询master状态中展示的有)</p>
<p>​    E. master_log_pos : 从指定日志文件的哪个位置开始同步(上述查询master状态中展示的有)</p>
</blockquote>
<p><strong>4). 查看从数据库的状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure>

<p>然后通过状态信息中的 Slave_IO_running 和 Slave_SQL_running 可以看出主从同步是否就绪，如果这两个参数全为Yes，表示主从同步已经配置完成。</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kjp6sxj210y0ofgrt.jpg" alt="image-20210825142313382"></p>
<blockquote>
<p>MySQL命令行技巧： </p>
<p>​    \G : 在MySQL的sql语句后加上\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行。即将查到的结构旋转90度变成纵向；</p>
</blockquote>
<h2 id="2-读写分离案例"><a href="#2-读写分离案例" class="headerlink" title="2. 读写分离案例"></a>2. 读写分离案例</h2><h3 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h3><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作<strong>，能够有效的避免由数据更新导致的行锁</strong>，使得整个系统的查询性能得到极大的改善。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5klfhcej20tn0b0jsg.jpg" alt="image-20210825145647274"> </p>
<p>通过读写分离,就可以降低单台数据库的访问压力, 提高访问效率，也可以避免单机故障。</p>
<p>主从复制的结构，我们在第一节已经完成了，那么我们在项目中，如何通过java代码来完成读写分离呢，如何在执行select的时候查询从库，而在执行insert、update、delete的时候，操作主库呢？这个时候，我们就需要介绍一个新的技术 ShardingJDBC。</p>
<h3 id="2-2-ShardingJDBC介绍"><a href="#2-2-ShardingJDBC介绍" class="headerlink" title="2.2 ShardingJDBC介绍"></a>2.2 ShardingJDBC介绍</h3><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p>
<p>Sharding-JDBC具有以下几个特点： </p>
<p>1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</p>
<p>2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</p>
<p>3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</p>
<h3 id="2-3-读写分离配置"><a href="#2-3-读写分离配置" class="headerlink" title="2.3 读写分离配置"></a>2.3 读写分离配置</h3><p>1). 在pom.xml中增加shardingJdbc的maven坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2). 在application.yml中增加数据源的配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.100.100:3306/rw?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.100.200:3306/rw?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment">#轮询</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure>



<p>配置解析: </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kqiiudj21e50de44v.jpg" alt="image-20210825162910711"> </p>
<p>3). 在application.yml中增加配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>该配置项的目的,就是如果当前项目中存在同名的bean,后定义的bean会覆盖先定义的。</p>
<p>spring中(spring.main.allow-bean-definition-overriding) 分析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liubenlong007/article/details/87885567">https://blog.csdn.net/liubenlong007/article/details/87885567</a></p>
<p>&#x3D;&#x3D;如果不配置该项，项目启动之后将会报错：&#x3D;&#x3D; </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kncntaj20tn0b0jsg.jpg" alt="image-20210825163737687"> </p>
<p>报错信息表明，在声明 org.apache.shardingsphere.shardingjdbc.spring.boot 包下的SpringBootConfiguration中的dataSource这个bean时出错, 原因是有一个同名的 dataSource 的bean在com.alibaba.druid.spring.boot.autoconfigure包下的DruidDataSourceAutoConfigure类加载时已经声明了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5koge4cj21e706ydim.jpg" alt="image-20210825164147056"> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5krkhptj210y0ofgrt.jpg" alt="image-20210825164227927"> </p>
<p>而我们需要用到的是 shardingjdbc包下的dataSource，所以我们需要配置上述属性，让后加载的覆盖先加载的。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/JVM%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">JVM的学习总结</a>
            </div>
            <p class="sub">May 11 2022</p>
            <div class="post-content">
                
                    <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><ul>
<li>定义</li>
</ul>
<p>​    java 程序运行环境(java二进制字节码的运行环境)</p>
<ul>
<li>好处</li>
</ul>
<p>​    一次编写,到处运行</p>
<p>​    自动内存管理,垃圾回收功能</p>
<p>​    数组下标越界检查</p>
<p>​    多态</p>
<ul>
<li>比较</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5weo104j20mx0dx406.jpg" alt="image-20220511191019291"></p>
<h1 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5whivtvj20qs0e8ta9.jpg" alt="image-20220511192331436"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wj7543j20tl0gqgon.jpg" alt="WechatIMG244"></p>
<h1 id="内存结构之程序计数器-寄存器"><a href="#内存结构之程序计数器-寄存器" class="headerlink" title="内存结构之程序计数器(寄存器)"></a>内存结构之程序计数器(寄存器)</h1><p>作用:</p>
<p>​       记住下一条JVM指令的执行地址</p>
<p>特点:</p>
<p>​      线程私有随着线程创建而创建,随着线程销毁而销毁,每个线程都有自己的程序计数器</p>
<p>​      是一块比较小的内存空间,不会存在内存溢出</p>
<p>实现</p>
<p>​       计数器在物理上是通过寄存器来实现的</p>
<h1 id="内存结构之虚拟机栈"><a href="#内存结构之虚拟机栈" class="headerlink" title="内存结构之虚拟机栈"></a>内存结构之虚拟机栈</h1><p>线程运行时需要的内存空间,称为虚拟机栈</p>
<p>每个栈由多个栈帧(Frame)组成,对应着每次方法调用时所占用的内存</p>
<p>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法,也就是栈的最顶部</p>
<p>栈帧出栈时会释放掉携带的资源</p>
<p>问题辨析:</p>
<p>1.垃圾回收是否涉及栈内存?</p>
<p>​    不需要,因为方法调用产生的栈帧内存会随着方法调用的结束后弹出栈并且自动释放资源,被自动回收</p>
<p>2.栈内存分配越大越好吗?</p>
<p>​    并不是,每个栈内存大小初始值一般都是1024KB,除了windows系统会根据虚拟内存影响内存大小,栈内存越大</p>
<p>线程数越少,线程数少了就会影响执行效率,一般让栈内存扩大只是为了一些方法的递归调用,不容易栈溢出.并不会因为</p>
<p>栈内存越大,执行效率越高,反而会让线程减少,降低执行效率.(一般采用默认大小就可以了)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wmfr7xj20bu0600t2.jpg" alt="image-20220511201653094"></p>
<p>3.方法内的局部变量是否线程安全?</p>
<p>​    首先要看,这个变量是对外共享的,还是对每个线程私有的,比如两个线程同时调用一个方法,方法中的局部变量是static修饰的,那么这个变量是共享的,因为静态变量只加载一次存在于静态区域,线程也就自然不安全,如果这个变量是个普通的局部变量,那么不会有线程安全问题,因为每个线程调用方法时都会生成对应线程的的栈帧.</p>
<p>​      <strong>如果方法内部局部变量没有逃离方法的作用访问,他是线程安全的</strong></p>
<p>​      <strong>如果局部变量引用了对象,并逃离了方法的作用范围,需要考虑线程安全问题</strong></p>
<h1 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h1><p>1.栈帧过多导致栈内存溢出</p>
<p>2.栈帧过大导致栈内存溢出</p>
<h1 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h1><h3 id="案例1-cpu占用过多"><a href="#案例1-cpu占用过多" class="headerlink" title="案例1:cpu占用过多"></a>案例1:cpu占用过多</h3><p>定位</p>
<p>1.用top定位那个进程对cpu的占用过高</p>
<p>2.通过Linux命令查看是哪条线程引起的cup占用过高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查看进程对cup占用情况-------&gt;只能定位进程,不能定位线程</span><br><span class="line">zhangminghao@zhangminghaodeMacBook-Pro ~ % top</span><br><span class="line">PID    COMMAND      %CPU TIME     #TH   #WQ   #PORT MEM    PURG   CMPRS  PGRP</span><br><span class="line">1704   FinalShell            63.3 02:14:05       150      0       1030  1364M       0B     360M   1704</span><br><span class="line">368    WindowServer     35.1 73:51.63        21        5       2665+ 379M-  43M+     57M       368</span><br><span class="line">1687   iTerm2                 30.8 04:04.45 8      5       314     54M    3536K     6608K       1687</span><br><span class="line"></span><br><span class="line">#查看线程对cup的占用情况</span><br><span class="line">#H:进程里的线程数</span><br><span class="line">#eo:需要展示的字段</span><br><span class="line">zhangminghao@zhangminghaodeMacBook-Pro ~ %  ps H -eo pid,tid,%cpu | grep 进程id    </span><br><span class="line"></span><br><span class="line">#利用jdk提供的工具命令,可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</span><br><span class="line">zhangminghao@zhangminghaodeMacBook-Pro ~ % jstack 进程id   </span><br></pre></td></tr></table></figure>

<p><strong>通过进程id的16进制来找出对应的线程,知道了是那个那个程序运行出了问题</strong></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wpm1lsj210b0ipn1g.jpg" alt="image-20220512203716530" style="zoom: 50%;" />

<p><strong>通过信息找到java代码中的行号,检查到cpu占用过高的原因</strong></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wr4cotj20c2076t96.jpg" alt="image-20220512203955346"  />



<h3 id="案例2-运行很长时间没有结果"><a href="#案例2-运行很长时间没有结果" class="headerlink" title="案例2:运行很长时间没有结果"></a>案例2:运行很长时间没有结果</h3><p> 1,通过jstack 进程id命令查看线程执行信息</p>
<p>2.观察最后的输出结果(发现死锁问题)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ws4yldj20t30g9dit.jpg" alt="image-20220512210643175"></p>
<h1 id="本地方法栈Native-Method-Stack"><a href="#本地方法栈Native-Method-Stack" class="headerlink" title="本地方法栈Native Method Stack"></a>本地方法栈Native Method Stack</h1><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>​    本地方法Native Method ,指的是那些不是JAVA代码编写的方法</p>
<h3 id="本地方法的作用"><a href="#本地方法的作用" class="headerlink" title="本地方法的作用"></a>本地方法的作用</h3><p>​    JAVA代码是受限制的,有时候不能直接跟底层操作系统打交道,需要调用一些 用C或者C++编写的本地方法来间接调用执行.</p>
<h1 id="Heap堆"><a href="#Heap堆" class="headerlink" title="Heap堆"></a>Heap堆</h1><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>​    通过new关键字,创建的对象都会使用堆内存,堆内存默认大小是4个G </p>
<h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><p>​    它是线程共享的,堆中对象都需要考虑线程安全问题</p>
<p>​    有垃圾回收机制</p>
<h3 id="堆内存的溢出问题"><a href="#堆内存的溢出问题" class="headerlink" title="堆内存的溢出问题"></a>堆内存的溢出问题</h3><p>​    java.lang.OutofMemoryError:Java heap space</p>
<h1 id="堆内存溢出的原因"><a href="#堆内存溢出的原因" class="headerlink" title="堆内存溢出的原因"></a>堆内存溢出的原因</h1><p>堆内存不是有垃圾回收机制吗,为什么还会有内存溢出的问题呢,原因是,堆内存的垃圾回收机制是在对象应用完毕后,才会自动回收,如果一个对象一直被引用,而且内存越来越大,就会导致堆内存溢出问题发发生,如以下代码:    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();-----------一直在做死循环做添加操作,且是引用中状态,导致堆不能垃圾回收</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;---------</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a+a;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(i);-----------&gt;最终输出<span class="number">26</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#异常信息</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">	at com.itheima.test.Test.main(Test.java:<span class="number">19</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>堆内存默认为4G,通过设置堆内存空间为8m,发现在i值到达17的时候就内存溢出了,所以可以通过这种方式,尽早的暴露出内存溢出的问题:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wvth3wj218o0u0tej.jpg" alt="image-20220513203904487"></p>
<h1 id="堆的内存诊断jmap"><a href="#堆的内存诊断jmap" class="headerlink" title="堆的内存诊断jmap"></a>堆的内存诊断jmap</h1><h3 id="1-jps工具"><a href="#1-jps工具" class="headerlink" title="1.jps工具:"></a>1.jps工具:</h3><p>​    是 java 提供的一个用来显示当前所有 java 进程的 pid 的命令,可以查看当前系统中有那些JAVA进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangminghao<span class="meta">@localhost</span> java-Spring % jps </span><br><span class="line"><span class="number">1488</span> </span><br><span class="line"><span class="number">1956</span> Jps</span><br><span class="line"><span class="number">1684</span> Launcher</span><br></pre></td></tr></table></figure>

<h3 id="2-jmap工具"><a href="#2-jmap工具" class="headerlink" title="2.jmap工具"></a>2.jmap工具</h3><p>​        jmap（Java Virtual Machine Memory Map）是JDK提供的一个可以生成Java虚拟机的堆转储快照dump文件的命令行工具。除此以外，jmap命令还可以查看finalize执行队列、Java堆和方法区的详细信息，比如空间使用率、当前使用的什么垃圾回收器、分代情况等等</p>
<p>​     查看堆内存占用情况heao进程id——&gt;&gt;jmap -heap 进程id</p>
<h3 id="3-jconsole工具"><a href="#3-jconsole工具" class="headerlink" title="3,jconsole工具"></a>3,jconsole工具</h3><p>​     图形界面的,多功能的检测工具,可以连续检测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangminghao<span class="meta">@localhost</span> java-Spring % jconsole</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ww8dmgj20qf0713zs.jpg" alt="image-20220513210926906"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/10/Mysql%E7%B4%A2%E5%BC%95-%E6%A0%B8%E5%BF%83/">Mysql索引(核心)</a>
            </div>
            <p class="sub">May 10 2022</p>
            <div class="post-content">
                
                    <h1 id="索引的概述"><a href="#索引的概述" class="headerlink" title="索引的概述"></a>索引的概述</h1><p>索引是帮助Mysql高效获取数据的一个有序的数据结构</p>
<p>优缺点:</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tqtt6gj20r504ajru.jpg" alt="image-20220510102517966" style="zoom:150%;" />

<h1 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h1><p>Mysql的索引是在存储引擎实层实现的,不同的存储索引有不同的结构,主要包括以下几种</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5trrd5nj20r907gdgr.jpg" alt="image-20220510102752768"></p>
<p>不同存储引擎支持的索引结构</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ts6jk2j20r407j3yx.jpg" alt="image-20220510102843612"></p>
<p><strong>平常所说的索引,如果没有特别指明,都是值B+树结构组织的索引</strong></p>
<h1 id="各个数据结构的优缺点"><a href="#各个数据结构的优缺点" class="headerlink" title="各个数据结构的优缺点"></a>各个数据结构的优缺点</h1><ul>
<li>二叉树和红黑树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tu4tlzj20rz0cg3zr.jpg" alt="image-20220510103435512"></p>
<ul>
<li>B树(多路平衡查找树)</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txaoxkj20tc0cg3zw.jpg" alt="image-20220510103600779"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txsdvfj20ry0c575o.jpg" alt="image-20220510104003733"><strong>B-Tree(B树)总结:①指针比key多一个②当key等于最大度数时(违背x阶时)中间元素向上分类</strong></p>
<ul>
<li>B+树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tz7djwj20ri08ydgp.jpg" alt="image-20220510104651047"></p>
<p><strong>B+Tree数相对于B-Tree区别:</strong></p>
<p><strong>①:所有数据都会出现在叶子节点</strong></p>
<p><strong>②:叶子节点行程一个单项链表的结构</strong></p>
<ul>
<li>Hash</li>
</ul>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u4lqq4j20sc0cedht.jpg" alt="image-20220510105739506"></p>
<p>  索引特点:</p>
<p>  1.Hash索引只能用于对等比较(&#x3D;,in),不支持范围查询(between,&gt;,&lt;,…),因为存储顺序不一致</p>
<p>  2.无法利用索引完成排序操作</p>
<p>  3.查询效率高,通常只需要一次检索就可以了,效率通常要高于B+Tree树(这里的通常指的是,没有哈希碰撞的前提下)</p>
<p>​    存储引擎支持:</p>
<p>​    在Mysql中,支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能,hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的.</p>
<h1 id="Mysql中的B-树索引"><a href="#Mysql中的B-树索引" class="headerlink" title="Mysql中的B+树索引"></a>Mysql中的B+树索引</h1><p>Mysql索引数据结构对经典的B+Tree进行了优化,在原B+Tree的基础上,增加了一个指向相邻叶子节点的链表指针,就形成了带有顺序指针的B+Tree,提高区间访问的性能**(就是叶子节点的单向链表变成了双向链表)**</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u5j8fhj20rj09075i.jpg" alt="image-20220510105526048"></p>
<h1 id="为什么InnoDB存储引擎选择使用B-Tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-Tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+Tree索引结构"></a>为什么InnoDB存储引擎选择使用B+Tree索引结构</h1><p>①相对于二叉树,层级更少,搜索效率更高</p>
<p>②对于B-Tree,无论是叶子节点还是非叶子节点,都会保存数据,这样导致一页(磁盘块,一个节点一个磁盘块,16kb)中存储的键值减少,指针跟着减少,要同样保存大量数据,只能增加树的高度,导致性能降低(B+Tree只有叶子节点才会存储行数据,其他节点只起到了索引的作用,除了叶子节点,其他的页只存放key和索引,因为不存储数据,所以可以存放更多的索引和key,也就可以降低树的高度,层级变小,从而增加查询效率)<strong>而且在mysql中对b+树索引进行了优化,对叶子节点的单项链表变成了双向链表,便于范围搜索和排序</strong></p>
<p>③相对于Hash索引(只能进行等值匹配),B+Tree支持范围匹配及排序操作</p>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u92miej20r3077t9f.jpg" alt="image-20220510113432105"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u9yambj20rd0ac75g.jpg" alt="image-20220510112749285"></p>
<p><strong>就会隐式的定义一个 rowid 作为聚集索引</strong></p>
<h1 id="InnoDB—-gt-回表查询"><a href="#InnoDB—-gt-回表查询" class="headerlink" title="InnoDB—-&gt;回表查询"></a>InnoDB—-&gt;回表查询</h1><p>如果想要执行类似于:selecy*from where name &#x3D; ‘Arm’ 这种sql语句,那么mysql先回根据二级索引找到对应的主键,或者带有唯一约束的值,然后通过主键或者唯一约束的值来通过聚集索引来查询对应row(行数据)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uc5k8yj20xs0h80uo.jpg" alt="image-20220510115518828"></p>
<h1 id="InnoDB主键索引的B-Tree高度为多高呢"><a href="#InnoDB主键索引的B-Tree高度为多高呢" class="headerlink" title="InnoDB主键索引的B+Tree高度为多高呢?"></a>InnoDB主键索引的B+Tree高度为多高呢?</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5udhri1j20jl0hidhd.jpg" alt="image-20220510123359487"></p>
<p><strong>可以得出,用innodb来存储2000多万条数据,树也只有三层,大大的提高了检索效率!</strong></p>
<h1 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h1><ul>
<li><p>创建索引:<strong>构建B+Tree的数据结构,构建一次,一劳永逸,空间换时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* create index idx_user_name on <span class="title function_">tb_user</span><span class="params">(name)</span>;</span><br><span class="line">* create unique index idx_user_phone on <span class="title function_">tb_user</span><span class="params">(phone)</span>;</span><br><span class="line">* create index idx_user_pro_age_sta on <span class="title function_">tb_user</span><span class="params">(profession,age,status)</span>; ---&gt; 创建联合索引</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from tb_user;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_user_phone on tb_user</span><br></pre></td></tr></table></figure>

<p><strong>SQL语句的优化一般优化的是查询语句,在优化查询语句中索引占主导地位</strong></p>
</li>
</ul>
<h1 id="sql优化性能分析"><a href="#sql优化性能分析" class="headerlink" title="sql优化性能分析"></a>sql优化性能分析</h1><ul>
<li><p>SQL的执行频率</p>
<blockquote>
<p>Mysql客户端链接成功后,通过Show[session|global] status 命令可以提供服务器状态信息,通过如下命令,可以查看当前数据库的insert,update,delete,select的访问频次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE <span class="string">&#x27;COM_______&#x27;</span> -----&gt;<span class="number">7</span>个下划线代表<span class="number">7</span>个字符</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uhipaej20e109qmxx.jpg" alt="image-20220510125834554"></p>
</blockquote>
</li>
</ul>
<p><strong>如果我们使用执行频率查看到当前数据库select查询的执行频次占据绝大部分,我们就需要对当前数据库来进行优化</strong></p>
<ul>
<li><p>慢查询日志</p>
</li>
<li><blockquote>
<p>  慢查询日志记录了所有执行时间超过指定参数(long_query_time,单位:妙,默认10妙)的所有sql语句的日志,我们可以通过查询慢查询日志,来定位执行效率比较低的语句,来做对应的优化处理.</p>
<p>  Mysql的慢查询日志默认没有开启,需要在Mysql的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#查询慢查询日志是否开启</span><br><span class="line">mysql&gt; show variables like &#x27;slow_query_log&#x27;;</span><br><span class="line">+----------------+-------+</span><br><span class="line">| Variable_name  | Value |</span><br><span class="line">+----------------+-------+</span><br><span class="line">| slow_query_log | OFF   |  -------&gt;可以看到默认开关是关闭的</span><br><span class="line">+----------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">#可以在/etc/my.cnf中配置一下信息</span><br><span class="line">#开启Mysql慢查询日志开关</span><br><span class="line">slow_query_log=1</span><br><span class="line">#设置慢查询日志的时间为2妙,sql语执行时间超过2秒,就会视为慢查询,记录慢查询日志</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完毕后,可以通过一下命令重启Mysql服务器进行测试,查询慢日志文件中记录的信息&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-show.log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">  systemctl restart mysqld;</span><br><span class="line"> #进入mysql继续用命令查看当前慢日志开关</span><br><span class="line">mysql&gt; show variables like &#x27;slow_query_log&#x27;;</span><br><span class="line">+----------------+-------+</span><br><span class="line">| Variable_name  | Value |</span><br><span class="line">+----------------+-------+</span><br><span class="line">| slow_query_log | ON    | -------&gt;可以看到开关从OFF变成了ON,表示已经开启慢查询日志</span><br><span class="line">+----------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>当慢查询日志开启后,慢查询日志的位置在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;的目录下,文件名教localhost-slow.log</strong></p>
<p><strong>注意:但是只用慢查询日志的话,只能锁定一些自己定义的慢查询时间(设定的预设时间),来查到查询慢的sql语句,比较笼统,如果有的sql语句在1.98s或者1.99s其实也是属于慢查询,但是因为配置的原因并不会记录到慢查询日志中去,所以这个时候就要用到profiling工具来辅助sql调优</strong></p>
</blockquote>
</li>
<li><p>Profile详情</p>
<blockquote>
<p>show profiles 能够在做SQL优化的时候帮助我们了解时间都耗费到哪里去了.通过have_profiling参数,能够看到Mysql是否支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#profile操作</span><br><span class="line">mysql&gt; SELECT @@have_profiling;</span><br><span class="line">+------------------+</span><br><span class="line">| @@have_profiling |</span><br><span class="line">+------------------+</span><br><span class="line">| YES              |    ---------&gt;可以看到当前数据库支持profile</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>支持是支持,但是还要检查一下profiling是否是开启状态,<strong>默认是关闭的</strong>,可以通过session&#x2F;global级别开启profiling:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#查看是否开启了profiling开关</span><br><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+-------------+</span><br><span class="line">| @@profiling |</span><br><span class="line">+-------------+</span><br><span class="line">|           0 |     ------&gt;可以看到默认是关闭的</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">#设置profiling的开关</span><br><span class="line">mysql&gt; set profiling = 1;   ---------&gt;设置开关为1,就是打开</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+-------------+</span><br><span class="line">| @@profiling |</span><br><span class="line">+-------------+</span><br><span class="line">|           1 |     ---------------&gt;再次查看发现,profiling开关已经被开启了</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p> 这个时候就可以通过一下语句来查询,每个查询的sql语句的详细执行情况了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条sql的耗时的基本情况</span><br><span class="line">mysql&gt; show profiles;   </span><br><span class="line">+----------+------------+--------------------+</span><br><span class="line">| Query_ID | Duration   | Query              |</span><br><span class="line">+----------+------------+--------------------+</span><br><span class="line">|        1 | 0.00013000 | select @@profiling |</span><br><span class="line">|        2 | 0.00011800 | SELECT DATABASE()  |</span><br><span class="line">|        3 | 0.00166125 | show databases     |</span><br><span class="line">|        4 | 0.00015150 | show tables        |</span><br><span class="line">|        5 | 0.00024825 | show tables        |</span><br><span class="line">|        6 | 0.00024200 | select * from user |</span><br><span class="line">|        7 | 0.00013325 | select * from DISH |</span><br><span class="line">|        8 | 0.00027600 | select * from dish |</span><br><span class="line">+----------+------------+--------------------+</span><br><span class="line">8 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">#查看指定的query_id的SQL语句各个阶段的耗时情况</span><br><span class="line"> mysql&gt; show profile for query 3;   -------&gt;根据从show profiles中查询的基本情况的query_id来查看该语句各个阶段的耗时详情</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000031 |</span><br><span class="line">| checking permissions | 0.000010 |</span><br><span class="line">| Opening tables       | 0.000028 |</span><br><span class="line">| init                 | 0.000006 |</span><br><span class="line">| System lock          | 0.000004 |</span><br><span class="line">| optimizing           | 0.000003 |</span><br><span class="line">| statistics           | 0.000009 |</span><br><span class="line">| preparing            | 0.000007 |</span><br><span class="line">| executing            | 0.001503 |    ----------&gt;可以发现在执行的时候耗时最长</span><br><span class="line">| Sending data         | 0.000019 |</span><br><span class="line">| end                  | 0.000003 |</span><br><span class="line">| query end            | 0.000004 |</span><br><span class="line">| closing tables       | 0.000003 |</span><br><span class="line">| removing tmp table   | 0.000005 |</span><br><span class="line">| closing tables       | 0.000003 |</span><br><span class="line">| freeing items        | 0.000013 |</span><br><span class="line">| cleaning up          | 0.000012 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">17 rows in set, 1 warning (0.00 sec)</span><br><span class="line">#还可以在show profile for query语句中的profile后面加上cup关键字 ,就可以查询到cup的耗时情况</span><br><span class="line">mysql&gt; show profile cpu  for query 3;</span><br><span class="line">+----------------------+----------+----------+------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system |   ---------&gt;可以看到比上面的结果多了一个CPU_user的的字段信息</span><br><span class="line">+----------------------+----------+----------+------------+</span><br><span class="line">| starting             | 0.000031 | 0.000013 |   0.000015 |</span><br><span class="line">| checking permissions | 0.000010 | 0.000005 |   0.000005 |</span><br><span class="line">| Opening tables       | 0.000028 | 0.000013 |   0.000015 |</span><br><span class="line">| init                 | 0.000006 | 0.000002 |   0.000003 |</span><br><span class="line">| System lock          | 0.000004 | 0.000002 |   0.000002 |</span><br><span class="line">| optimizing           | 0.000003 | 0.000001 |   0.000002 |</span><br><span class="line">| statistics           | 0.000009 | 0.000005 |   0.000005 |</span><br><span class="line">| preparing            | 0.000007 | 0.000003 |   0.000003 |</span><br><span class="line">| executing            | 0.001503 | 0.000000 |   0.000286 |</span><br><span class="line">| Sending data         | 0.000019 | 0.000000 |   0.000015 |</span><br><span class="line">| end                  | 0.000003 | 0.000000 |   0.000003 |</span><br><span class="line">| query end            | 0.000004 | 0.000000 |   0.000004 |</span><br><span class="line">| closing tables       | 0.000003 | 0.000000 |   0.000003 |</span><br><span class="line">| removing tmp table   | 0.000005 | 0.000000 |   0.000005 |</span><br><span class="line">| closing tables       | 0.000003 | 0.000000 |   0.000003 |</span><br><span class="line">| freeing items        | 0.000013 | 0.000000 |   0.000012 |</span><br><span class="line">| cleaning up          | 0.000012 | 0.000000 |   0.000012 |</span><br><span class="line">+----------------------+----------+----------+------------+</span><br><span class="line">17 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>explain执行计划:</p>
<p>可以模拟 优化器 执行SQL查询语句，并不会去真正的执行这条SQL，从而知道 MySQL 是如何处理你的SQL语句的。可用来分析你的查询语句或是表结构的性能瓶颈。<strong>从而评判sql语句的执行性能</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用explain模拟优化器</span><br><span class="line">mysql&gt; explain select * from dish; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | dish  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   26 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>expalin执行计划各个字段的含义:</p>
<p><strong>id:</strong></p>
<p>select查询的序列号,表示查询中执行select子句或者是操作表的顺序(id相同,执行顺序从上到下:id不同,值越大,越先执行)</p>
<p><strong>select_type:</strong></p>
<p>表示SELECT的类型,常见的取值有SIMPLE(简单表,即不实用表连接或者子查询),PRIMARY(主查询),PRIMARY(主查询,即外层的查询),UNION(UNION中搞得第二个或者后面的查询语句),SUBQUERY(SELECT&#x2F;WHERE之后包含了子查询)等</p>
<p><strong>type:</strong></p>
<p>表示连接类型,性能由好到差的连接类型为NULL,system,const,eq_ref,ref,range,index,all.</p>
<p><strong>possible_key:</strong></p>
<p>显示可能应用在这张表上的索引,一个或者多个</p>
<p><strong>key</strong></p>
<p>实际使用的索引,如果为null,则没有使用索引.</p>
<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数,该值为索引字段最大可能长度,并非实际使用长度,在不损失精确性的前提下,长度越长越好.</p>
<p><strong>rows</strong></p>
<p>MYSQL认为必须要执行查询的行数,在Innodb引擎的表中,是一个估计值,可能并不总是准确的.</p>
<p><strong>filtered</strong></p>
<p>表示返回结果的行数占需读取行数的百分比,filtered的值越大越好</p>
<p><strong>Extra</strong></p>
<p>该语句没有查询出来的字段,会在额外字段中展示</p>
<p>using index condition  回表查询</p>
<p>using index 索引覆盖</p>
<p>using where 全表扫描</p>
<p>需重点关注以下字段信息:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uo0um1j20uv046t9s.jpg" alt="image-20220510144105150"></p>
</blockquote>
</li>
</ul>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ul>
<li><p>验证索引效率</p>
<p>在不用默认主键的聚合索引通过普通字段查询数据时,1000万条数据需要耗时20多s</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uq1th2j21420a6ad4.jpg" alt="image-20220510145621792"></p>
</li>
</ul>
<p>​    这个时候我们针对刚刚的字段来创建对应的索引,构造该字段的B+Tree索引数据结构(为1000万条的数据构造数据结构是非常耗时的经过1min11s的时间终于构建成功)</p>
<p>​        <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uqwe9ej20b201ut8q.jpg" alt="image-20220510145924020"></p>
<p>此时查询一下当前表的索引,发现刚刚创建的索引已经构建成功<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ut08o0j212p088abo.jpg" alt="image-20220510150140764"></p>
<p>这个时候我们再次查询一下刚刚的sql语句</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uvpvx4j20er0bgq41.jpg" alt="image-20220510150423765"></p>
<p><strong>可以看到再次执行时,只用了0.01s的时间,这就是索引对于查询效率的提升</strong></p>
<h1 id="无效索引"><a href="#无效索引" class="headerlink" title="无效索引"></a>无效索引</h1><ul>
<li>没有遵守最左前缀法则</li>
</ul>
<p>如果索引了多列(联合索引),要遵守最左前缀法则.最左前缀法则指的是查询从索引的最左列开始,并且不跳过索引中的列,如果跳跃某一列,索引将部分失效(后面的字段索引失效) —-&gt;必须包含最左边的列,不然会失效,导致全表扫描</p>
<ul>
<li>范围查询</li>
</ul>
<p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引会失效(<strong>但是&lt;&#x3D;,&gt;&#x3D;索引会生效</strong>)</p>
<ul>
<li>索引列运算</li>
</ul>
<p>不要在索引列上进行运算操作,索引将失效</p>
<ul>
<li>字符串不加引号</li>
</ul>
<p>字符串类型字段使用时,不加引号,会发生隐式转换,索引将失效</p>
<ul>
<li>模糊查询</li>
</ul>
<p>如果仅仅是尾部模糊匹配,索引不会失效.如果是头部模糊匹配,索引失效.(例如: ‘xx%’可以  ‘%xx’不可以)</p>
<ul>
<li>or连接条件</li>
</ul>
<p>用or分割开的条件,如果or前的条件中的列有索引,而后面的列没有索引,那么涉及的索引都不会被用到,索引失效(只有两侧都有索引的时候,索引才会剩生效)—–&gt;解决方法,只需要在没有索引的一方建立索引即可 </p>
<h1 id="select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题"><a href="#select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题" class="headerlink" title="select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?"></a>select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?</h1><p><strong>有个问题,select * 的时候用 or 且满足左右两边都是索引的情况下按道理来说可以用到索引但是如果是联合索引,则不会走索引查询,而是全表扫描,如果是两边都是单个索引就会合并索引走二级索引+回表查询,如果所有字段都有索引,那么就会索引覆盖,直接走二级索引,符合索引覆盖</strong></p>
<ul>
<li><strong>数据分布影响</strong> —–重点</li>
</ul>
<p>如果MYSQL评估使用索引比全表更慢,则不使用索引.(比如查询一个比最小数据大的所有数据,因此本来就是要走全表扫描的,索引还不如直接走全表扫描来的快,也就不会走索引)</p>
<ul>
<li><strong>关于字段是否有null</strong> —重点</li>
</ul>
<p><strong>在where后面进行null值判断,导致索引失效的原因并不是null本身,而是mysql根据数据分布来自动判断是否用索引,比如一个字段里绝大多数都是null,这个时候你查询字段里为null的值,mysql会认为全表扫描比索引来的更快,所以不会使用索引,如果一个字段里的null是极少数的,那么当你查询字段里为null的值的数据的时候,mysql会判断全表扫描的性能要低于索引查询,这个时候就会使用索引!</strong></p>
<p>因为在判断时候,联合索引必须要有最左前缀,如果用or,就不能保证有最左前缀,所以直接全表扫描!</p>
<h1 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h1><p>SQL提示,是优化数据库的一个重要手段,简单来说,就是在SQL语句中加入一些认为的提示来达到优化操作的目的.</p>
<p>当单列索引存在与联合索引中的时候,Mysql会自动选择一个效率高的索引,如果想要使用其他索引的话,那就需要在sql语句中指定要用的索引,sql语句如下:</p>
<p><strong>use index(索引名)—–&gt;建议(MySQL不一定执行,会自动判断)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#默认情况下</span><br><span class="line">mysql&gt; explain select * from dish where name = &#x27;梅菜扣肉&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys                          | key           | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name,idx_dish_name_price_code | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">#给mysql建议使用索引情况下----&gt;mysql会自动判断,如果建议的索引效率低,则不会执行建议的索引</span><br><span class="line">mysql&gt; explain select * from dish use   index(idx_dish_name_price_code) where name = &#x27;梅菜扣肉&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>ignore index(索引名)——&gt;表示忽略某个索引,也就是不用的索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#忽略联合索引索引,会执行另外的索引</span><br><span class="line">mysql&gt; explain select * from dish ignore  index(idx_dish_name_price_code) where name = &#x27;梅菜扣肉&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key           | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>force index(索引名)——&gt;强制Mysql执行某个索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#强制使用联合索引</span><br><span class="line">mysql&gt; explain select * from dish force  index(idx_dish_name_price_code) where name = &#x27;梅菜扣肉&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>尽量使用覆盖索引(查询使用了索引,并且需要返回的列,在索引中已经全部能够找到),减少select * .</p>
<p>覆盖索引的白话:就是要查询的字段都是设置了索引,建议直接覆盖所索引,就不需要回表查询了!</p>
<p>如果要查询的字段中包含没有索引的字段,那么会在二级索引找到有索引字段的值后拿到挂在叶子节点底下的主键值获取者约束唯一字段的值去聚集函数中进行回表查询,如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v1fz2cj20wx0f60vb.jpg" alt="image-20220510171143926"></p>
<p>解决方案:就是将没有加入索引的字段也加上索引,实现索引覆盖效果,效率提高,尽量不用select * 不然大概率都会进行回表查询,性能就会下降</p>
<h1 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h1><p>当字段类型为字符串(varcahr,text等)时,有时候需要索引很长的字符串,这会让索引变得很大,查询时,浪费大量的磁盘IO,影响查询效率.此时可以只将字符串的一部分前缀,建立索引,这样可以大大节约索引空间,从而提高索引效率</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建前缀索引</span><br><span class="line">create index idx_xxxx on table_name(colum(n));</span><br></pre></td></tr></table></figure>

<p>前缀长度:<br>可以根据索引的有选择性来决定,而选择性是指不重复的索引值(基数)和数据表的记录总数的比值,索引选择性越高则查询效率越高,唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询email中不为空的数据</span><br><span class="line">select count( email)/count(*) from tb_user;</span><br><span class="line">#查询email中不重复的数据</span><br><span class="line">select count(distinct email) from tb_user;</span><br><span class="line">#查询emai中不重复数据的选择性 /不重复数据/总条目数</span><br><span class="line">select count(distinct email)/count(*) from tb_user;</span><br><span class="line">#查询emai中不重复数据的选择性 /不重复数据/总条目数的前5个字符(降低索引的体积)</span><br><span class="line">select count(distinct substring(email,1,5))/count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v3t7zuj20xu0fjwh6.jpg" alt="image-20220510212318350"></p>
<h1 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v95x4hj20wb0e4dij.jpg" alt="image-20220510220527020"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v9t2zpj20xb0f2q50.jpg" alt="image-20220510220551724"></p>
<h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>1.针对数据量大,且查询比较频繁的表建立索引</p>
<p>2.针对常作为查询条件(where),排序(order by),分组(group by)操作的字段建立索引</p>
<p>3.尽量选择区分度高的列作为索引,尽量建立唯一索引,区分度越高,使用的效率就越高.</p>
<p>4.如果是字符串类型的字段,字段的长度较长,可以针对于字段的特点,建立前缀索引</p>
<p>5.尽量使用联合索引,减少单例索引,查询时,联合索引很多时候可以覆盖索引,节省存储空间,避免回表,提高查询效率.</p>
<p>6.要控制索引的数量,索引并不是多多益善,索引越多,维护索引结构的代价就越大,会影响增删改的效率</p>
<p>7.如果索引列不能存储NULL值,请再创建表使用NOT NULL约束它.当优化器知道每列是否包含NULL值时,可以更好的确定那个索引最有效的用于查询.</p>
<h1 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h1><p>1.索引概述</p>
<blockquote>
<p>索引是高效获取数据的数据结构,它是有序的</p>
</blockquote>
<p>2.索引结构</p>
<blockquote>
<p>B+Tree:所有的数据都会出现在叶子节点,而且叶子节点形成了一个双向链表</p>
<p>Hash:检索性能高,直接算出哈希值定位到检索数据,如果存在哈希碰撞,则会形成链表,在寻着链表找对应的值,检索性能比较高,但是缺点就是只能进行等值(精确)匹配,不支持范围查询,和索引的排序—-&gt;(memory引擎使用)</p>
</blockquote>
<p>3.索引分类</p>
<blockquote>
<p>主键索引,唯一索引,常规索引,全文索引</p>
<p>在innodb引擎中,根据索引的存储结构分为两类:聚集索引,二级索引</p>
<p>聚集索引:必须存在,且只能有一个,最大特点就是这个B+Tree叶子节点的数据是这一行的数据,默认主键索引就是聚集索引,没有主键会选择第一个唯一索引作为聚集索引</p>
<p>二级索引:B+Tree叶子节点的底下挂的是主键</p>
</blockquote>
<p>4.索引语法</p>
<blockquote>
<p>create [unique] index xxx on xxx(xxx);</p>
<p>Show index from xxxx;</p>
<p>Drop index xxx on xxx;</p>
</blockquote>
<p>5.SQL性能分析</p>
<blockquote>
<p>执行频次,慢查询日志,profile,explain</p>
</blockquote>
<p>6.索引使用</p>
<blockquote>
<p> 联合索引:必须严格遵守最左前缀法则</p>
<p>索引失效</p>
<p>SQL提示</p>
<p>覆盖索引</p>
<p>前缀索引</p>
<p>单例&#x2F;联合索引</p>
</blockquote>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/10/Mysql%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/">Mysql存储索引</a>
            </div>
            <p class="sub">May 10 2022</p>
            <div class="post-content">
                
                    <h1 id="MYSQL体系结构-连接层"><a href="#MYSQL体系结构-连接层" class="headerlink" title="MYSQL体系结构:连接层"></a>MYSQL体系结构:连接层</h1><p>最上层是一些客户端的链接服务,主要完成一些类似于链接处理,授权认证,及相关的安全方案.服务器也会安全接入的每个客户端验证它所具有的操作权限</p>
<h1 id="MYSQL体系结构-服务层"><a href="#MYSQL体系结构-服务层" class="headerlink" title="MYSQL体系结构:服务层"></a>MYSQL体系结构:服务层</h1><p>第二层架构主要完成大多数的核心服务功能,如SQL接口,并完成缓存查询,Sql的分析和优化,部分内置函数的执行.所有跨存储引擎的功能也是在这一层实现的,如过程,函数等</p>
<h1 id="MYSQL体系结构-引擎层"><a href="#MYSQL体系结构-引擎层" class="headerlink" title="MYSQL体系结构:引擎层"></a>MYSQL体系结构:引擎层</h1><p>存储引擎真正的负责了Mysql中数据的存储和提取,服务器通过API和存储引擎进行通信.不同的存储引擎距有不同的功能,这样我们可以根据自己的需要,来选取核实的存储引擎.存储引擎是可插拔式的</p>
<h1 id="MYSQL体系结构-存储层"><a href="#MYSQL体系结构-存储层" class="headerlink" title="MYSQL体系结构:存储层"></a>MYSQL体系结构:存储层</h1><p>主要是将数据存储在文件系统上,并且完成与存储引擎的交互</p>
<h1 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h1><p>存储引擎就是存储数据,建立索引,更新&#x2F;查询数据等技术的实现方式.</p>
<p>指定存储引擎的语句:ENGINE&#x3D;INNODB &lt;—-可替换</p>
<p>查看当前数据库支持的存储引擎:SHOW ENGINES</p>
<p>没有指定存储引擎时,默认为InnoDB</p>
<p><strong>存储引擎是基于表的么人不是基于库的,所以存储引擎也被称为表类型</strong></p>
<h1 id="InnoDB存储引擎的特点"><a href="#InnoDB存储引擎的特点" class="headerlink" title="InnoDB存储引擎的特点"></a>InnoDB存储引擎的特点</h1><p>InnoDB介绍:</p>
<p>InnoDB是一种兼顾高可靠性的高性能的通用存储引擎,在Mysql5.5之后,InnoDB是默认的MYSQL存储引擎</p>
<p>InnoDB特点:</p>
<p>DML(增删改操作)操作遵循ACID模型,支持事务</p>
<p>行级锁,提高并发访问性能</p>
<p>支持外检Foreign key约束,保证数据的完整性和正确性</p>
<p>InnoDB文件:</p>
<p>xxx.ibd:xxx代表的是表名,innoDB引擎的每张表都会对应这样的一个表空间文件,存储该表的表结构(frm 8.0前  ,sdi 8.0后),数据和索引. 参数:innodb_flie_per_table如果打开,代表 每一张表都代表一个表空间</p>
<h1 id="查看ibd文件"><a href="#查看ibd文件" class="headerlink" title="查看ibd文件"></a>查看ibd文件</h1><p>idb文件是不能直接打开的,里面记录的都是二进制数据,如果非要打开看可以使用cmd输入—–&gt;   ibd2sdi xxx.idb</p>
<h1 id="ibd文件存储结构"><a href="#ibd文件存储结构" class="headerlink" title="ibd文件存储结构"></a>ibd文件存储结构</h1><p>![image-20220510095308222](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220510095308222.png)</p>
<h1 id="MyISAM存储引擎的特点"><a href="#MyISAM存储引擎的特点" class="headerlink" title="MyISAM存储引擎的特点"></a>MyISAM存储引擎的特点</h1><p>介绍:</p>
<p>MyISAM是MySQL早期默认的存储引擎</p>
<p>特点:</p>
<p>不支持事务,不支持外键</p>
<p>支持表锁,不支持行锁</p>
<p>访问速度快 </p>
<p>文件:</p>
<p>xxx.sdi:存储表结构信息(存储的json格式数据)</p>
<p>xxx.MYD:存储数据</p>
<p>xxx.MYI:存储索引</p>
<h1 id="Memory存储引擎的特点"><a href="#Memory存储引擎的特点" class="headerlink" title="Memory存储引擎的特点"></a>Memory存储引擎的特点</h1><p>![ ](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220510100043131.png)</p>
<h1 id="三个存储引擎的区别"><a href="#三个存储引擎的区别" class="headerlink" title="三个存储引擎的区别"></a>三个存储引擎的区别</h1><p>![image-20220510100124777](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220510100124777.png)</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">HashMap源码解析</a>
            </div>
            <p class="sub">May 08 2022</p>
            <div class="post-content">
                
                    <h1 id="TreeifyBin"><a href="#TreeifyBin" class="headerlink" title="TreeifyBin"></a>TreeifyBin</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">//n 数组的长度，index 数组位置</span></span><br><span class="line">        <span class="type">int</span> n, index;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//如果当前数组为空，或者当前数组容量小于最小树化容量</span></span><br><span class="line">            <span class="comment">//直接扩容不进行树化</span></span><br><span class="line">            resize();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当当前找的节点e不为空</span></span><br><span class="line">            <span class="comment">//hd红黑树链表头，红黑树链表尾（红黑树中不仅有维护其所有节点的红黑树结构，还有所有节点的链表结构）</span></span><br><span class="line">            <span class="comment">//所以先将目前节点按链表排列好，在进行红黑树化</span></span><br><span class="line">            TreeNode&lt;K, V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//遍历列表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//将当前e节点装化为TreeNode</span></span><br><span class="line">                TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//如果tl不存在</span></span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//则p为hd</span></span><br><span class="line">                    hd = p;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若存在则p的前节点指向tl</span></span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    <span class="comment">//tl的后节点指向p</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后将tl指向p</span></span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将hd放在数组上，且hd存在，将链表进行红黑树化</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Treeify"><a href="#Treeify" class="headerlink" title="Treeify"></a>Treeify</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K, V&gt;[] tab)</span> &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K, V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">                <span class="comment">//根据链表进行遍历</span></span><br><span class="line">                next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">                x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果根节点还没设置则当前节点设置为根节点root</span></span><br><span class="line">                    x.parent = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//根节点一定是黑色的</span></span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//获取当前循环节点的key和哈希值</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//每次都从根节点开始循环</span></span><br><span class="line">                    TreeNode&lt;K, V&gt; p = root;</span><br><span class="line">                    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                        <span class="comment">//遍历当前红黑树</span></span><br><span class="line">                        <span class="type">int</span> dir;</span><br><span class="line">                        <span class="comment">//获得p的hash值和key</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                        <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                        <span class="comment">//比较hash值，然后根据比较值dir决定插入左边还是右边</span></span><br><span class="line">                        <span class="keyword">if</span> (ph &gt; h) &#123;</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//k不是不是课比较类或者比较结果为0，使用tieBreakOrder方法比较</span></span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line">                        &#125;</span><br><span class="line">                        TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                        p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right;</span><br><span class="line">                        <span class="comment">//仅当当前要插入的位置上没有节点时才进行插入，否则继续向下遍历</span></span><br><span class="line">                        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//设置父节点</span></span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="comment">//根据dir值设置为父节点的左右子节点</span></span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//插入成功后平衡红黑树</span></span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="comment">//跳出当前循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确保当前的root是直接落在table数组上的</span></span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


                
            </div>
        </article>
    
</div>
<div class="side-bar">


    <div class="avator" id="avator">
    <div class="title">
        <a href="#" class="text-underline">这是爷</a>
    </div>
        <img src="WechatIMG68.jpeg" class="ava-img">
        <h3 class="author">张鸣昊</h3>
        <div class="icon-list">
        <a href="yourweibo"><i class="iconfont icon-weibo icon-item"></i></a>
        <a href="mailto:youremail"><i class="iconfont icon-email icon-item"></i></a>
        <a href="yourgithub"><i class="iconfont icon-github icon-item"></i></a>
        <a href="yourlinkedin"><i class="iconfont icon-linkedin icon-item"></i></a>
        </div>
    <div class="tags">
    <h3 class="tags-title">Tags</h3>
    
</div>
    </div>
</div>


</section>

    <nav class="page-nav">
    
    
        <a class="next" href="/page/2/">
            <span class="next-text">Next</span>
            <i class="iconfont icon-right"></i>
        </a>
    
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Zmhaoo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
