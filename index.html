<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>Zmhaoo&#39;s Blog</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 6.1.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">Zmhaoo&#39;s Blog</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">主页</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">归档</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">关于</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
    <div class="posts-wrapper">
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/23/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/">Nacos注册中心的使用</a>
            </div>
            <p class="sub">5月 23 2022</p>
            <div class="post-content">
                
                    <h1 id="1-Nacos注册中心"><a href="#1-Nacos注册中心" class="headerlink" title="1.Nacos注册中心"></a>1.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p>
<h2 id="15-1-认识和安装Nacos"><a href="#15-1-认识和安装Nacos" class="headerlink" title="15.1.认识和安装Nacos"></a>15.1.认识和安装Nacos</h2><p><a target="_blank" rel="noopener" href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzmnfpej20th0bxwfp.jpg" alt="image-20210713230444308"></p>
<p>安装方式可以参考课前资料《Nacos安装指南.md》</p>
<h2 id="1-2-服务注册到nacos"><a href="#1-2-服务注册到nacos" class="headerlink" title="1.2.服务注册到nacos"></a>1.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p>
<p>主要差异在于：</p>
<ul>
<li>依赖不同</li>
<li>服务地址不同</li>
</ul>
<h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>&#x3D;&#x3D;<strong>注意</strong>：不要忘了注释掉eureka的依赖。&#x3D;&#x3D;</p>
<h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p><strong>注意</strong>：不要忘了注释掉eureka的地址</p>
</blockquote>
<h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzoja9bj20ng08274z.jpg" alt="image-20210713231439607"></p>
<h2 id="1-3-服务分级存储模型"><a href="#1-3-服务分级存储模型" class="headerlink" title="1.3.服务分级存储模型"></a>1.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzktxvlj21760le76o.jpg" alt="image-20210713232522531"></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzkal82j210k0ci3zn.jpg" alt="image-20210713232658928"></p>
<p>杭州机房内的order-service应该优先访问同机房的user-service。</p>
<h3 id="1-3-1-给user-service配置集群"><a href="#1-3-1-给user-service配置集群" class="headerlink" title="1.3.1.给user-service配置集群"></a>1.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment"># 集群名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzib2inj20sz0743z0.jpg" alt="image-20210713232916215"></p>
<p>我们再次复制一个user-service启动配置，添加属性：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>配置如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzpxfmxj20tn0odgoq.jpg" alt="image-20210713233528982"></p>
<p>启动UserApplication3后再次查看nacos控制台：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzqv68aj20z00k676x.jpg" alt="image-20210713233727923"></p>
<h3 id="1-3-2-同集群优先的负载均衡"><a href="#1-3-2-同集群优先的负载均衡" class="headerlink" title="1.3.2.同集群优先的负载均衡"></a>1.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>
<p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>
<p>1）给order-service配置集群信息</p>
<p>修改order-service的application.yml文件，添加集群配置：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ # 集群名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>2）修改负载均衡规则</p>
<p>修改order-service的application.yml文件，修改负载均衡规则：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="1-4-权重配置"><a href="#1-4-权重配置" class="headerlink" title="1.4.权重配置"></a>1.4.权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>
<p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p>
<p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzm71elj20y509xwfq.jpg" alt="image-20210713235133225"></p>
<p>在弹出的编辑窗口，修改权重：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzrbtl7j20kt0hr0td.jpg" alt="image-20210713235235219"></p>
<blockquote>
<p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p>
</blockquote>
<h2 id="1-5-环境隔离"><a href="#1-5-环境隔离" class="headerlink" title="1.5.环境隔离"></a>1.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzp0fiaj20tn0i2dh7.jpg" alt="image-20210714000101516"></p>
<h3 id="1-5-1-创建namespace"><a href="#1-5-1-创建namespace" class="headerlink" title="1.5.1.创建namespace"></a>1.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inznua1kj20fg0c5q3d.jpg" alt="image-20210714000414781"></p>
<p>我们可以点击页面新增按钮，添加一个namespace：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzjdaqej20k40c7t9e.jpg" alt="image-20210714000440143"></p>
<p>然后，填写表单：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzrspxsj20k30c1t9h.jpg" alt="image-20210714000505928"></p>
<p>就能在页面看到一个新的namespace：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzn4nqkj20nk0813z5.jpg" alt="image-20210714000522913"></p>
<h3 id="1-5-2-给微服务配置namespace"><a href="#1-5-2-给微服务配置namespace" class="headerlink" title="1.5.2.给微服务配置namespace"></a>1.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p>
<p>例如，修改order-service的application.yml文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ
        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment"># 命名空间，填ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>重启order-service后，访问控制台，可以看到下面的结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inziwhggj20fw05z0sv.jpg" alt="image-20210714000830703"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzqd7qvj20ep05ywen.jpg" alt="image-20210714000837140"></p>
<p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzpgu1xj20rn045q4e.jpg" alt="image-20210714000941256"></p>
<h2 id="1-6-Nacos与Eureka的区别"><a href="#1-6-Nacos与Eureka的区别" class="headerlink" title="1.6.Nacos与Eureka的区别"></a>1.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p>
<ul>
<li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p>
</li>
<li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p>
</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置为非临时实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzlprprj212b0jugnb.jpg" alt="image-20210714001728017"></p>
<ul>
<li><p>Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li><p>Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/23/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/">Eureka注册中心的使用</a>
            </div>
            <p class="sub">5月 23 2022</p>
            <div class="post-content">
                
                    <h1 id="1-Eureka注册中心"><a href="#1-Eureka注册中心" class="headerlink" title="1.Eureka注册中心"></a>1.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwnehkbj20xp0i03zh.jpg" alt="image-20210713214925388"></p>
<p>大家思考几个问题：</p>
<ul>
<li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li>
<li>有多个user-service实例地址，order-service调用时该如何选择？</li>
<li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li>
</ul>
<h2 id="1-1-Eureka的结构和作用"><a href="#1-1-Eureka的结构和作用" class="headerlink" title="1.1.Eureka的结构和作用"></a>1.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwt2e5yj214e0nagoy.jpg" alt="image-20210713220104956"></p>
<p>回答之前的各个问题。</p>
<p>问题1：order-service如何得知user-service实例地址？</p>
<p>获取地址信息的流程如下：</p>
<ul>
<li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li>
<li>eureka-server保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li>
</ul>
<p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p>
<ul>
<li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
<p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p>
<ul>
<li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li>
<li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service拉取服务时，就能将故障实例排除了</li>
</ul>
<blockquote>
<p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p>
</blockquote>
<p>因此，接下来我们动手实践的步骤包括：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwqp9c0j20ws0eamz5.jpg" alt="image-20210713220509769"></p>
<h2 id="1-2-搭建eureka-server"><a href="#1-2-搭建eureka-server" class="headerlink" title="1.2.搭建eureka-server"></a>1.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p>
<h3 id="1-2-1-创建eureka-server服务"><a href="#1-2-1-创建eureka-server服务" class="headerlink" title="1.2.1.创建eureka-server服务"></a>1.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwwrbqwj20sz06amyf.jpg" alt="image-20210713220605881"></p>
<p>填写模块信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwvw3qaj20qi0sd7aq.jpg" alt="image-20210713220857396"></p>
<p>然后填写服务信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwljx82j20qi0sdgmw.jpg" alt="image-20210713221339022"></p>
<h3 id="1-2-2-引入eureka依赖"><a href="#1-2-2-引入eureka依赖" class="headerlink" title="1.2.2.引入eureka依赖"></a>1.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-2-3-编写启动类"><a href="#1-2-3-编写启动类" class="headerlink" title="1.2.3.编写启动类"></a>1.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>eureka</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span></span><span class="token class-name">EnableEurekaServer</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableEurekaServer</span><span class="token comment">//表示Eureka服务端</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-2-4-编写配置文件"><a href="#1-2-4-编写配置文件" class="headerlink" title="1.2.4.编写配置文件"></a>1.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span> 
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-2-5-启动服务"><a href="#1-2-5-启动服务" class="headerlink" title="1.2.5.启动服务"></a>1.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a target="_blank" rel="noopener" href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p>
<p>看到下面结果应该是成功了：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwod4uej212a0ljdid.jpg" alt="image-20210713222157190"></p>
<h2 id="1-3-服务注册"><a href="#1-3-服务注册" class="headerlink" title="1.3.服务注册"></a>1.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p>
<h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p>
<p>首先，复制原来的user-service启动配置：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwotkijj20dn07fwf9.jpg" alt="image-20210713222656562"></p>
<p>然后，在弹出的窗口中，填写信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwwbm79j20tn0odwid.jpg" alt="image-20210713222757702"></p>
<p>现在，SpringBoot窗口会出现两个user-service启动配置：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwrnen3j20cu061jrw.jpg" alt="image-20210713222841951"></p>
<p>不过，第一个是8081端口，第二个是8082端口。</p>
<p>启动两个user-service实例：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwk7k49j20c804mjrp.jpg" alt="image-20210713223041491"></p>
<p>查看eureka-server管理页面：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwjqbf2j213c05y0u2.jpg" alt="image-20210713223150650"></p>
<h2 id="1-4-服务发现"><a href="#1-4-服务发现" class="headerlink" title="1.4.服务发现"></a>1.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p>
<h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p>
<p>在order-service的pom文件中，引入下面的eureka-client依赖：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p>
<p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p>
<p>不过这些动作不用我们去做，只需要添加一些注解即可。</p>
<p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwm0jjpj20l20bsgmz.jpg" alt="image-20210713224049419"></p>
<p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwtk769j20t20i3ju5.jpg" alt="image-20210713224245731"></p>
<p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p>
<h1 id="2-Ribbon负载均衡"><a href="#2-Ribbon负载均衡" class="headerlink" title="2.Ribbon负载均衡"></a>2.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p>
<h2 id="2-1-负载均衡原理"><a href="#2-1-负载均衡原理" class="headerlink" title="2.1.负载均衡原理"></a>2.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwr5k93j215k0epgmy.jpg" alt="image-20210713224517686"></p>
<p>那么我们发出的请求明明是<a target="_blank" rel="noopener" href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p>
<h2 id="2-2-源码跟踪"><a href="#2-2-源码跟踪" class="headerlink" title="2.2.源码跟踪"></a>2.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p>
<p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>
<p>我们进行源码跟踪：</p>
<h3 id="1）LoadBalancerInterceptor"><a href="#1）LoadBalancerInterceptor" class="headerlink" title="1）LoadBalancerInterceptor"></a>1）LoadBalancerInterceptor</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwnvllaj20o00c3jue.jpg" alt="1525620483637"></p>
<p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，本例中就是 <a target="_blank" rel="noopener" href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li>
</ul>
<p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p>
<h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwmiavcj20q107eq4t.jpg" alt="1525620787090"></p>
<p>代码是这样的：</p>
<ul>
<li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li>
<li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li>
</ul>
<p>放行后，再次访问并跟踪，发现获取的是8081：</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwtze46j20k4041754.jpg" alt="1525620835911"></p>
<p>果然实现了负载均衡。</p>
<h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p>
<p> <img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day01-SpringCloud01/%E8%AE%B2%E4%B9%89/md/assets/1525620835911.png" alt="1525620835911"></p>
<p>我们继续跟入：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwug2v2j20pr06cabg.jpg" alt="1544361421671"></p>
<p>继续跟踪源码chooseServer方法，发现这么一段代码：</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwmyyflj20go0bct9w.jpg" alt="1525622652849"></p>
<p>我们看看这个rule是谁：</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwuxabxj20k407iabi.jpg" alt="1525622699666"></p>
<p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwsmr1zj20jl04wdga.jpg" alt="1525622754316"></p>
<p>这不就是轮询的意思嘛。</p>
<p>到这里，整个负载均衡的流程我们就清楚了。</p>
<h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwpbbxwj218h0k2jtx.jpg" alt="image-20210713224724673"></p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<h2 id="2-3-负载均衡策略"><a href="#2-3-负载均衡策略" class="headerlink" title="2.3.负载均衡策略"></a>2.3.负载均衡策略</h2><h3 id="2-3-1-负载均衡策略"><a href="#2-3-1-负载均衡策略" class="headerlink" title="2.3.1.负载均衡策略"></a>2.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwvdjuuj212i0e8ac4.jpg" alt="image-20210713225653000"></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p>
<h3 id="2-3-2-自定义负载均衡策略"><a href="#2-3-2-自定义负载均衡策略" class="headerlink" title="2.3.2.自定义负载均衡策略"></a>2.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<ol start="2">
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li>
</ol>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p>
</blockquote>
<h2 id="2-4-饥饿加载"><a href="#2-4-饥饿加载" class="headerlink" title="2.4.饥饿加载"></a>2.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试，默认采用懒加载的时候，访问<a target="_blank" rel="noopener" href="http://localhost:8080/order/103%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E6%98%AF%E5%B7%AE%E4%B8%8D%E5%A4%9A1s">http://localhost:8080/order/103的第一次访问时间是差不多1s</a>,</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwq8ndkj21gn05yaaw.jpg" alt="1652356722332"></p>
<p>使用了饥饿加载之后，第一次访问的时间差不多是650ms左右</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwl5n8nj21fw05c3zd.jpg" alt="1652356816332"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/19/Spring%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">Spring底层原理学习</a>
            </div>
            <p class="sub">5月 19 2022</p>
            <div class="post-content">
                
                    <h1 id="Spring中的单例bean"><a href="#Spring中的单例bean" class="headerlink" title="Spring中的单例bean"></a>Spring中的单例bean</h1><p>spring中的单例bean根所谓的单例模式并不一样,Spring的单例bean的实现是基于单例池</p>
<p>单例池其实就是一个Map集合,key存储的是单例对象的名字,value存储的是名字对应的对象,也就是类型</p>
<p>所以使用@autowire注解来进行依赖注入的时候,是先通过类型来找,如果有多个,在通过名字来找,先bytype在byname</p>
<p>单例bean其实指的是,一个名字对应一个对象,当我们通过getbean来获取spring容器中的bean的时候,通过名字来获取的默认都是单例的,singleton模式,如果设置了多例模式,那么创建的bean不会存储在单例池,每次get直接获取新的对象</p>
<h1 id="Spring创建bean使用的什么构造方法"><a href="#Spring创建bean使用的什么构造方法" class="headerlink" title="Spring创建bean使用的什么构造方法"></a>Spring创建bean使用的什么构造方法</h1><p>Spring创建Bean的时候,默认使用无参构造创建bean**(默认)**</p>
<p>如果没有无参构造,只有一个有参构造,则会通过有参构造中参数的类型去spring容器找对象进行注入,然后再通过有参构造进行实例化bean对象,此时还没有对构造属性赋值**(推断构造方法)**</p>
<p>如果在没有无参构造方法的情况下,有多个有参构造而且没有指定使用哪一个构造方法,则会报错**(推断构造方法)**</p>
<h1 id="Aop代理对象"><a href="#Aop代理对象" class="headerlink" title="Aop代理对象"></a>Aop代理对象</h1><p>Spring中Bean 的生命周期在初始化后,会去判断有没有进行aop切面的操作,如果有,则对这个对象创建一个代理对象,如果这个对象有实现接口,则默认使用jdk代理对象,如果没有则创建这个对象的子类,实现CGlib动态代理</p>
<p>代理对象有个target属性,这个属性就是被代理对象的实例化对象,直接在代理对象中通过target对象来调用方法,实现aop的效果</p>
<h1 id="Autowire依赖注入ByType的详细流程"><a href="#Autowire依赖注入ByType的详细流程" class="headerlink" title="@Autowire依赖注入ByType的详细流程"></a>@Autowire依赖注入ByType的详细流程</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dlr91pgsj20ne0y3k0k.jpg" alt="image-20220519123007306"></p>
<h1 id="Resource依赖注入ByName的详细流程"><a href="#Resource依赖注入ByName的详细流程" class="headerlink" title="@Resource依赖注入ByName的详细流程"></a>@Resource依赖注入ByName的详细流程</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dp747b0fj20i40m9dhz.jpg" alt="image-20220519142911972"></p>
<p>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<p>　　@Resource装配顺序</p>
<p>  　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br>    　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br>      　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br>        　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配</p>
<h1 id="Spring启动流程详细图解"><a href="#Spring启动流程详细图解" class="headerlink" title="Spring启动流程详细图解"></a>Spring启动流程详细图解</h1><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dpcbv448j20w90u0gpl.jpg" alt="Spring启动流程详解" style="zoom:150%;" />

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/16/Mysql%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Mysql锁的学习总结</a>
            </div>
            <p class="sub">5月 16 2022</p>
            <div class="post-content">
                
                    <h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL中的锁,按照锁的粒度分,分为以下三类:</p>
<p>1.全局锁:锁定数据库中所有表</p>
<p>2.表级锁:每次操作锁住整张表</p>
<p>3.行级锁:每次操作锁住对应的行数据</p>
<h1 id="全局锁-备份"><a href="#全局锁-备份" class="headerlink" title="全局锁(备份)"></a>全局锁(备份)</h1><p>全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态,后续的DML的写语句,DDL语句,已经更新操作的事务提交语句都将被阻塞</p>
<p>**其典型的使用场景是做全库的逻辑备份,**对所有的表进行锁定,从而获取一致性视图,保证数据的完整性</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a9nwsbtoj20sb0c4q3z.jpg" alt="image-20220516151501523"></p>
<p>加了全局锁后,在备份过程中,用户只能进行DQL查询操作,不能写入</p>
<h3 id="第一种备份操作-加全局锁"><a href="#第一种备份操作-加全局锁" class="headerlink" title="第一种备份操作,加全局锁"></a>第一种备份操作,加全局锁</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#第一步:进入mysql输入打开全局锁命令
mysql&gt; flush tables with read lock;
Query OK, 0 rows affected (0.00 sec)


#第二步:打开第二个cmd窗口,此时不能关闭mysql窗口,不然全局锁失效
#在第二个窗口执行备份语句 (在终端执行,不是mysql内部命令)
zhangminghao@localhost blog % mysqldump -uroot -proot reggie &gt; &#x2F;Users&#x2F;zhangminghao&#x2F;Desktop&#x2F;SQL&#x2F;emp.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.\


#第三步:备份成功后返回第一个mysql窗口执行释放锁命令
mysql&gt; unlock tables;
Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>特点</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aackyaj6j20qu03jaah.jpg" alt="image-20220516153844161"></p>
<h3 id="第二种备份操作-不加全局锁"><a href="#第二种备份操作-不加全局锁" class="headerlink" title="第二种备份操作,不加全局锁"></a>第二种备份操作,不加全局锁</h3><p>在InnoDB引擎中,我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">zhangminghao@localhost blog %   mysqldump --single-transaction -uroot -proot reggie &gt; &#x2F;Users&#x2F;zhangminghao&#x2F;Desktop&#x2F;SQL&#x2F;reggie.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>表级锁,每次操作锁住整张表.锁定粒度大,发生锁冲突的概率最高,并发度最低</p>
<p>应用在MyISAM,InnoDB,BDB等存储引擎中</p>
<h3 id="1-1表锁"><a href="#1-1表锁" class="headerlink" title="1.1表锁"></a>1.1表锁</h3><h4 id="1-2对于表锁-分为两类"><a href="#1-2对于表锁-分为两类" class="headerlink" title="1.2对于表锁,分为两类"></a>1.2对于表锁,分为两类</h4><p>​    ①.表共享<strong>读锁</strong>(read lock):读锁不会阻塞开启读锁的客户端的写操作,但是会阻塞其他客户端的写操作,释放锁后才解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aau0dv7ij20kw04t0td.jpg" alt="image-20220516155528866"></p>
<p>   ②.表独占锁<strong>写锁</strong>(write lock):写锁不会阻塞上锁的客户端的读和写,但是会阻塞其他客户端的读和写,阻塞到客户端A释放锁,才能解除阻塞状态.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ab18a527j20kd04tq3i.jpg" alt="image-20220516160224869"></p>
<h4 id="1-3语法"><a href="#1-3语法" class="headerlink" title="1.3语法"></a>1.3语法</h4><p>​    1.加锁:lock tables 表名… read&#x2F;write</p>
<pre><code> 2.释放锁:unlock tables/客户端断开连接.
</code></pre>
<h3 id="2-1元数据锁"><a href="#2-1元数据锁" class="headerlink" title="2.1元数据锁"></a>2.1元数据锁</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acmvdflbj20wp08rq4r.jpg" alt="image-20220516165749161"></p>
<p>在MySQL 5.7中，针对MDL，引入了一张新表performance_schema.metadata_locks，该表可对外展示MDL的相关信息，包括其作用对象，类型及持有等待情况。</p>
<h4 id="2-2开启MDL的instrument"><a href="#2-2开启MDL的instrument" class="headerlink" title="2.2开启MDL的instrument"></a>2.2<strong>开启MDL的instrument</strong></h4><p>但是相关instrument并没有开启（MySQL 8.0是默认开启的），其可通过如下两种方式开启，</p>
<p><strong>临时生效</strong></p>
<p>修改<code>performance_schema.setup_instrume nts表</code>，但实例重启后，又会恢复为默认值。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE  performance_schema.setup_instruments SET ENABLED &#x3D; &#39;YES&#39;, TIMED &#x3D; &#39;YES&#39; WHERE NAME &#x3D; &#39;wait&#x2F;lock&#x2F;metadata&#x2F;sql&#x2F;mdl&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>永久生效</strong></p>
<h4 id="2-3在配置文件中设置"><a href="#2-3在配置文件中设置" class="headerlink" title="2.3在配置文件中设置"></a>2.3在配置文件中设置</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[mysqld]
performance- schema -instrument&#x3D; &#39;wait&#x2F;lock&#x2F;metadata&#x2F;sql&#x2F;mdl&#x3D;ON&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="2-4元数据锁的执行流程"><a href="#2-4元数据锁的执行流程" class="headerlink" title="2.4元数据锁的执行流程"></a>2.4元数据锁的执行流程</h4><p>第一步:通过performance_schema.metadata_locks查看元数据锁状态</p>
<pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#查看元数据锁状态
mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
+-------------+--------------------+----------------+-------------+---------------+
| object_type | object_schema      | object_name    | lock_type   | lock_duration |
+-------------+--------------------+----------------+-------------+---------------+
| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |
+-------------+--------------------+----------------+-------------+---------------+
1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第二步:<strong>开启事务</strong>后,写一条<strong>查询语句</strong>,元数据锁表中会增加一条共享读锁</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
+-------------+--------------------+----------------+-------------+---------------+
| object_type | object_schema      | object_name    | lock_type   | lock_duration |
+-------------+--------------------+----------------+-------------+---------------+
| TABLE       | reggie             | employee       | SHARED_READ | TRANSACTION   |   --------------&gt;共享读锁
| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |
+-------------+--------------------+----------------+-------------+---------------+
2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果commit提交了事务,那么元数据中的共享读锁会消失</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abyhhqodj21430a6n0x.jpg" alt="image-20220516163422539"></p>
<p>第三步:如果在没有提交事务之前,在另一个客户端对该表进行修改,会增加排他锁,但是排他锁跟其他所都是互斥的,所以会造成阻塞.    </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aceptxmoj213c0dq0vz.jpg" alt="image-20220516164958973"></p>
<p>此时在左边客户端再次查询元数据</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acjams3nj217r0gw0wy.jpg" alt="image-20220516165423051"></p>
<p>提交事务后</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acl0vhj6j213j0f5dk5.jpg" alt="image-20220516165602410"></p>
<h3 id="3-1意向锁"><a href="#3-1意向锁" class="headerlink" title="3.1意向锁"></a>3.1意向锁</h3><h4 id="3-2为什么要加意向锁"><a href="#3-2为什么要加意向锁" class="headerlink" title="3.2为什么要加意向锁?"></a>3.2为什么要加意向锁?</h4><p>先看一下现象:</p>
<p>加入客户端A在修改表中数据时,开启事务后通过id来修改数据,因为id是主键,所以会自动上行锁</p>
<p>这个时候客户端B想对该表上表锁的时候,必须判断该表是否有表锁,就必须从第一条开始遍历检查,以及行锁的类型</p>
<p>来判断能不能加表锁,此时数据量大的时候,性能极底 ,如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ad1ve4xmj20w40a3gn7.jpg" alt="image-20220516171213695"></p>
<p><strong>所以为了避免DML执行时,加的行锁与表锁冲突,在InnoDB中引如了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表的检查.</strong></p>
<p>可以通过以下sql,查看意向锁及行锁的加锁情况:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="3-3意向共享锁-IS"><a href="#3-3意向共享锁-IS" class="headerlink" title="3.3意向共享锁(IS)"></a>3.3意向共享锁(IS)</h4><p>与表锁共享锁(read)兼容,与表锁排他锁(write)互斥.</p>
<h4 id="3-4意向排他锁-IX"><a href="#3-4意向排他锁-IX" class="headerlink" title="3.4意向排他锁(IX)"></a>3.4意向排他锁(IX)</h4><p>与表锁共享锁(read)及排他锁(write)都互斥,意向锁之间不会互斥.</p>
<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>行级锁,每次操作锁住对应的行数据.锁定粒度最小,发生锁冲突的概率底,并发度最高.</p>
<p>应用在InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的**,行锁是通过对索引上的索引项来实现的**,而不是对记录加的锁.</p>
<p><strong>如果条件的字段没有索引那么行锁会升级为表锁🔒</strong></p>
<p>对于行级锁主要分为以下三类:</p>
<h3 id="1-行锁的分类"><a href="#1-行锁的分类" class="headerlink" title="1)行锁的分类"></a>1)行锁的分类</h3><h4 id="1-1行锁-Record-Lock"><a href="#1-1行锁-Record-Lock" class="headerlink" title="1.1行锁(Record Lock)"></a>1.1行锁(Record Lock)</h4><p>锁定单个行记录的锁,防止其他事务对此进行update和delete.在RC.RR隔离级别下都支持.</p>
<blockquote>
<p><strong>自己的理解:</strong></p>
<p><strong>行锁就是锁住聚集索引索引对应的行数据如果是从二级索引开始上锁</strong></p>
<p><strong>那么要通过索引对应的主键回表查询到聚集索引对应的行数据</strong></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afb9euuzj20mr03rmxt.jpg" alt="image-20220516183027448"></p>
<h4 id="1-2间隙锁-Gap-Lock"><a href="#1-2间隙锁-Gap-Lock" class="headerlink" title="1.2间隙锁(Gap Lock)"></a>1.2间隙锁(Gap Lock)</h4><p>锁定索引记录间隙(不含该记录),确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读.</p>
<p>在RR隔离级别下都支持</p>
<p>​       <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afehj6x7j20qo03kgmb.jpg" alt="image-20220516183333703"></p>
<h4 id="1-3临键锁-Next-Key-Lock"><a href="#1-3临键锁-Next-Key-Lock" class="headerlink" title="1.3临键锁(Next-Key Lock)"></a>1.3临键锁(Next-Key Lock)</h4><p>行锁和间隙锁组合,同时锁住数据,并锁住数据前面的间隙Gap.在RR隔离级别下支持**(行锁和间隙锁的组合)**</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2affu842oj20qo03qgmb.jpg" alt="image-20220516183451619"></p>
<h3 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2)行锁"></a>2)行锁</h3><p>InnoDB实现了一下两种类型的行锁:</p>
<h4 id="2-1共享锁-S"><a href="#2-1共享锁-S" class="headerlink" title="2.1共享锁(S)"></a>2.1共享锁(S)</h4><p>允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.</p>
<p>简单理解就是,共享锁之间是兼容的,共享锁和排他锁是互斥的</p>
<h4 id="2-2排他锁-X"><a href="#2-2排他锁-X" class="headerlink" title="2.2排他锁(X)"></a>2.2排他锁(X)</h4><p>允许获取排他锁的事务更新数据,组织其他事务获得相同的数据集的共享锁和排他锁. </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afl6o5dnj20nc055jrl.jpg" alt="image-20220516183959691"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afpo7dhqj20wg065mxu.jpg" alt="image-20220516184418623"></p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afysg3ltj20vs03k3z6.jpg" alt="image-20220516185304652"></p>
<hr>
<h4 id="3-间隙锁-x2F-临键锁-演示"><a href="#3-间隙锁-x2F-临键锁-演示" class="headerlink" title="3)间隙锁&#x2F;临键锁-演示"></a>3)间隙锁&#x2F;临键锁-演示</h4><hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag1wtzlvj20q303j3yx.jpg" alt="image-20220516185604366"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag21w7q8j20x8011t91.jpg" alt="image-20220516185612478"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2agddsvkuj20ji0exmyw.jpg" alt="image-20220516190705735"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/13/Mysql%E7%9A%84Sql%E4%BC%98%E5%8C%96/">Mysql的Sql优化</a>
            </div>
            <p class="sub">5月 13 2022</p>
            <div class="post-content">
                
                    <h1 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h1><ul>
<li><p>insert优化</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5gdckvkj20ep0bzq3q.jpg" alt="image-20220513213453462"></p>
</li>
</ul>
<p>经量减少网络之间的I&#x2F;O传输,可以提高性能</p>
<ul>
<li>大批量插入数据</li>
</ul>
<p>如果需要一次性大批量插入数据,使用insert语句插入性能较低,此时可以使用MYSQL数据库提供的load指令进行插入.操作如下;</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g91h2dj20vn06ftar.jpg" alt="image-20220513213651727"></p>
<pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#客户端连接服务器时,加上参数 --local-infile
mysql --local-infile -u root -p
#设置全局参数local_infile为1.开启从本地加载文件导入数据的开关(默认关闭的)
set global local_infile &#x3D; 1;

mysql&gt; select @@local_infile
    -&gt; ;
+----------------+
| @@local_infile |
+----------------+
|              1 |     -------------&gt;设置为1
+----------------+
1 row in set (0.00 sec)
#执行load指令将准备好的数据,加载到表就诶够中
load data local infeil &#39;&#x2F;root&#x2F;sql.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;
					       #文件位置                     到那张表           字段用什么分隔              每一行用什么分隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>主键顺序插入性能高于乱序插入</strong></p>
<h1 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h1><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>​    在InnoDB存储引擎中,表数据都是根据主键顺序存放的,这种存储方式的表称为<strong>索引组织表</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g5lvquj20tg0ca75y.jpg" alt="image-20220516093022006"></p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,可以填充一半,也可以填充100%.每个页包含了2-N行数据(如果一行数据过多,会行溢出),根据主键排列</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fy2n63j20wj0580tf.jpg" alt="image-20220516093248234"></p>
<p>如果主键不是顺序插入,那么新插入过来的数据,会找出比自己小一级的那个页,截取50%的内容</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fva5qcj20uj0af0tf.jpg" alt="image-20220516093713899"></p>
<p>并开辟一个新的页空间,然后和截取的那一部分一同存入新的页空间中,最后被截取的那部分页再重新指向那段新的页空间.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fstyg2j20w808v757.jpg" alt="image-20220516093818505"></p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>当删除一行记录时,实际上记录并没有被屋里删除,只是记录被标记为删除,并且它的空间变得允许其他记录声明使用.</p>
<p>当页中删除的记录达到了MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找靠近的页(前或后)看看是否可以合并,以优化空间使用.</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fo5ng1j20w10333z9.jpg" alt="image-20220516094302614"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fmeqh8j20ww058dgi.jpg" alt="image-20220516094319791"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fhtxesj20xs09gmyn.jpg" alt="image-20220516094410407"></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#添加索引的时候设置(默认百分之50)
create index ix_person_birthday on tempdb.person(birthday) comment &#39;MERGE_THRESHOLD&#x3D;48&#39;

#可以从information_schema中查询索引页的合并阀值
select * from INNODB_INDEXES where name in (&#39;ix_person_name&#39;,&#39;ix_person_birthday&#39;) ;
+----------+--------------------+----------+------+----------+---------+-------+-----------------+
| INDEX_ID | NAME               | TABLE_ID | TYPE | N_FIELDS | PAGE_NO | SPACE | MERGE_THRESHOLD |
+----------+--------------------+----------+------+----------+---------+-------+-----------------+
|      147 | ix_person_name     |     1059 |    0 |        2 |       5 |     2 |              45 |
|      148 | ix_person_birthday |     1059 |    0 |        2 |       6 |     2 |              48 |
+----------+--------------------+----------+------+----------+---------+-------+-----------------+
2 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="主键的设计原则"><a href="#主键的设计原则" class="headerlink" title="主键的设计原则"></a>主键的设计原则</h1><p>1.满足业务需求的情况下,尽量降低主键的长度,主键长度过长,当二级索引较多时,会占用大量的磁盘空间,而且在搜索的时候会耗费大量的磁盘IO,所以要尽量降低主键的长度</p>
<p>2.插入数据时,尽量选择顺序插入,选择使用AUTO_INCREMENT自增主键,如果不是顺序插入,可能会出现页分裂现象</p>
<p>3.尽量不要用UUID做主键或者其他自然主键,如身份证号,因为这些数据都是无序的,就会导致页分裂,数据过长,检索时间增加,也会增加磁盘IO</p>
<p>4.在业务操作时,避免对主键的修改,应为修改主键也会改变对应的索引结构,代价很大</p>
<h1 id="mysql8-0新特性——-gt-order-by优化"><a href="#mysql8-0新特性——-gt-order-by优化" class="headerlink" title="mysql8.0新特性——-&gt;order by优化"></a>mysql8.0新特性——-&gt;order by优化</h1><p>1.Using filesort:通过表的索引或全表扫描,读取满足条件的数据行,然后再排序缓冲区sort buffer中完成排序操作,所有不是通过索引直接返回结果的排序都叫FileSort排序</p>
<p>2,Using index:通过有序索引顺序扫描直接返回的有序数据,这种情况下即为Using index,不需要额外排序,操作小效率高</p>
<h3 id="新特性一-Backward-index-scan关键字"><a href="#新特性一-Backward-index-scan关键字" class="headerlink" title="新特性一:Backward  index scan关键字"></a>新特性一:Backward  <em>index</em> <em>scan</em>关键字</h3><p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong>Using index</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong><em>Backward</em> <em>index</em> <em>scan</em>,Using index</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Backward index scan,Using index |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在8.0中,对于反向扫描,有一个专门的词进行描述“<em><strong>Backward* <em>index</em> *scan</strong></em>“反向索引扫描,5.7版本没有</p>
<h3 id="新特性二-支持反向索引"><a href="#新特性二-支持反向索引" class="headerlink" title="新特性二:支持反向索引"></a>新特性二:支持反向索引</h3><p>当我们向通过一个字段升序ASC,一个字段降序DESC,或者反之,需要通过创建索引的时候指定,不然会出现全表扫描Using filesort关键字</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc  ,id_number desc;
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

#按照上面需求创建降序联合索引
create index  idx_phone_id_numbe on employee(phone asc,id_number desc); #-------&gt; 指定那个字段降序 
#再次查询索引信息发现Collation字段A代表ASC,D代表DESC 
mysql&gt; show index from employee;
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| employee |          0 | PRIMARY              |                   1 | id         		 | A         |          15 |     NULL | NULL   |      | BTREE      |         |               |
| employee |          1 | idx_phone_id_number  |            1 | phone      		 | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |
| employee |          1 | idx_phone_id_number  |            2 | id_number       | D        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<strong>Mysql5.7</strong>中支持此语法,但是设置降序索引时,还是创建的升序,并没有改变</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index  idx_phone_id_numbe on employee(phone asc,id_number desc)
mysql&gt; show index from employee;
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| employee |          0 | PRIMARY              |                   1 | id         		 | A         |          15 |     NULL | NULL   |      | BTREE      |         |               |
| employee |          1 | idx_phone_id_number  |            1 | phone      		 | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |
| employee |          1 | idx_phone_id_number  |            2 | id_number       | A        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |
+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>图解:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5f3m94kj20wv074gms.jpg" alt="image-20220516105542348"></p>
<h3 id="ORDER-BY注意事项"><a href="#ORDER-BY注意事项" class="headerlink" title="ORDER BY注意事项"></a>ORDER BY注意事项</h3><p><strong>事项一</strong>:根据排序字段建立合适的索引,多字段排序时,<strong>应当遵循最左前缀法则</strong>,不然虽然会走索引但是会出现<strong>Using filesort</strong></p>
<p>降低了查询效率.<strong>(前提是索引覆盖)</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by id_number,phone ;
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |
+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>事项二</strong>:如果没有遵循最左前缀也没有达到索引覆盖条件,则会全表扫描,<strong>索引尽量要索引覆盖</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select * from employee order by id_number,phone ;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using filesort |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>事项三</strong>:多字段排序时,一个升序一个降序,此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)</p>
<p><strong>事项四</strong>:如果不可避免的出现filesort,大数据量排序时,<strong>可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</strong>,如果在排序时,占满了256k的排序缓冲区,则会涉及到磁盘文件当中进行排序,会降低性能,可以适量增大</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#默认排序缓冲区大小sort_buffer_size为256k
mysql&gt; show variables like &#39;sort_buffer_size&#39;;
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| sort_buffer_size | 262144 |
+------------------+--------+
1 row in set (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h1><p>1,在分组时,也可以通过索引来提高效率,如果没有索引则会出现 <strong>Using temporary</strong>临时表关键字,效率低下</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select name,count(*) from employee group by name;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using temporary; Using filesort |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.分组操作时,索引的使用也是满足最左前缀法则的</p>
<p>情况一:索引没有满足最左前缀,但满足索引覆盖(Using index; Using temporary; Using filesort)</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; mysql&gt; explain select  id_number,count(*) from employee group by id_number;
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+
| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                                        |
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+
|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using temporary; Using filesort |
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>情况二:索引满足最左前缀,也满足索引覆盖(Using index )</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select  phone,count(*) from employee group by phone;
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h1><p>一个常见有非常头疼的问题就是limit 200000,10 ,此时mysql排序前200000,10 记录,仅仅返回200000,200010的记录,其他记录丢弃,查询排序的代价非常大</p>
<p>优化思路:一般分页查询时,通过创建覆盖所以,能够比较好的提高性能,可以通过覆盖索引加子查询形式优化.</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from tb_sku t,(select id from tb_sku order by id limit 200000,10)  a  where t.id &#x3D; a.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>mysql官方给出的优化方案</p>
<h1 id="Count优化"><a href="#Count优化" class="headerlink" title="Count优化"></a>Count优化</h1><h3 id="COUNT的几种用法"><a href="#COUNT的几种用法" class="headerlink" title="COUNT的几种用法"></a>COUNT的几种用法</h3><p>![image-20220516113046371](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220516113046371.png)</p>
<h1 id="update优化-InnoDB中索引-行锁-表锁的关系"><a href="#update优化-InnoDB中索引-行锁-表锁的关系" class="headerlink" title="update优化(InnoDB中索引-行锁-表锁的关系)"></a>update优化(InnoDB中索引-行锁-表锁的关系)</h1><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p>Mysql中的InnoDB引擎<strong>默认是行级锁</strong>,当一个客户端通过主键id修改一个条数据时,这条数据会被锁上,另一个客户端通过<strong>同一个ID修改</strong>这个被锁住的数据时,就会堵塞**(如果是不同id则不会阻塞)**</p>
<p>客户端A:条件相同</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ewvch5j20jj078q43.jpg" alt="image-20220516114611297"></p>
<p>客户端B:条件相同</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ei8t8gj20l108j40e.jpg" alt="image-20220516114824459"></p>
<p>等待一段时间后会抛出:ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction(等待超时)</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>当一个客户端通过名字name修改一个条数据时,这条数据会被锁上,另一个客户端修改<strong>另一条数据</strong>通过<strong>另一个名字name修改,发现也会阻塞</strong>,这是为什么呢????</p>
<blockquote>
<p>因为InnoDB的行锁针对索引加锁,不是针对记录加的锁,并且改索引不能失效,否则会从行锁升级为表说</p>
<p>也就是只要你的条件不是索引字段,那么这一次操作则会锁住整张表</p>
</blockquote>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/12/Redis%E4%BD%BF%E7%94%A8/">Redis使用</a>
            </div>
            <p class="sub">5月 12 2022</p>
            <div class="post-content">
                
                    <h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul>
<li>Redis入门</li>
<li>Redis数据类型</li>
<li>Redis常用命令</li>
<li>在Java中操作Redis</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis"></a>1.1 什么是Redis</h3><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件，它是「<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice」的首字母缩写，也就是「远程字典服务」。</p>
<ul>
<li><input disabled="" type="checkbox"> 基于内存存储，读写性能高</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sbs9ygj20b106v74l.jpg" alt="image-20210927090555559"></p>
<ul>
<li><input disabled="" type="checkbox"> 适合存储热点数据（热点商品、资讯、新闻）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5scrk8rj20bk07o0tn.jpg" alt="image-20210927090604994"></p>
<ul>
<li><input disabled="" type="checkbox"> 企业应用广泛</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sdng30j20c007o74l.jpg" alt="image-20210927090612540"></p>
<h3 id="1-2-使用Redis能做什么"><a href="#1-2-使用Redis能做什么" class="headerlink" title="1.2 使用Redis能做什么"></a>1.2 使用Redis能做什么</h3><ul>
<li>数据缓存</li>
<li>消息队列</li>
<li>注册中心</li>
<li>发布订阅</li>
</ul>
<h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-Redis简介"><a href="#2-1-Redis简介" class="headerlink" title="2.1 Redis简介"></a>2.1 Redis简介</h3><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. 翻译为：Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io</a></p>
<p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p>
<p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p>
<p>关系型数据库(RDBMS)：</p>
<ul>
<li>Mysql</li>
<li>Oracle</li>
<li>DB2</li>
<li>SQLServer</li>
</ul>
<p>非关系型数据库(NoSql)：</p>
<ul>
<li>Redis</li>
<li>Mongo db</li>
<li>MemCached</li>
</ul>
<h3 id="2-2-Redis下载与安装"><a href="#2-2-Redis下载与安装" class="headerlink" title="2.2 Redis下载与安装"></a>2.2 Redis下载与安装</h3><h4 id="2-2-1-Redis下载"><a href="#2-2-1-Redis下载" class="headerlink" title="2.2.1 Redis下载"></a>2.2.1 Redis下载</h4><p>Redis安装包分为windows版和Linux版：</p>
<ul>
<li>Windows版下载地址：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li>
<li>Linux版下载地址： <a target="_blank" rel="noopener" href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li>
</ul>
<p>下载后得到下面安装包：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sj9t3rj20ug02jq34.jpg" alt="image-20210927092053283"></p>
<h4 id="2-2-2-Redis安装"><a href="#2-2-2-Redis安装" class="headerlink" title="2.2.2 Redis安装"></a>2.2.2 Redis安装</h4><p><strong>1）在Linux中安装Redis</strong></p>
<p>在Linux系统安装Redis步骤：</p>
<ol>
<li>将Redis安装包上传到Linux</li>
<li>解压安装包，命令：&#x3D;&#x3D;tar -zxvf redis-4.0.0.tar.gz -C &#x2F;usr&#x2F;local&#x3D;&#x3D;</li>
<li>安装Redis的依赖环境gcc，命令：&#x3D;&#x3D;yum install -y gcc-c++&#x3D;&#x3D;</li>
<li>进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0，进行编译，命令：&#x3D;&#x3D;make&#x3D;&#x3D;</li>
<li>进入redis的src目录进行安装，命令：&#x3D;&#x3D;make install&#x3D;&#x3D;</li>
</ol>
<p>安装后重点文件说明：</p>
<blockquote>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-server：Redis服务启动脚本</p>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-cli：Redis客户端脚本</p>
<p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;redis.conf：Redis配置文件</p>
</blockquote>
<p><strong>2）在Windows中安装Redis</strong></p>
<p>Redis的Windows版属于绿色软件，直接解压即可使用，解压后目录结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sl2swwj20sp0bqq48.jpg" alt="image-20210927093112281"></p>
<h3 id="2-3-Redis服务启动与停止"><a href="#2-3-Redis服务启动与停止" class="headerlink" title="2.3 Redis服务启动与停止"></a>2.3 Redis服务启动与停止</h3><p><strong>1）Linux系统中启动和停止Redis</strong></p>
<p>执行Redis服务启动脚本文件&#x3D;&#x3D;redis-server&#x3D;&#x3D;：</p>
<p><code>路径：</code></p>
<p><code>/usr/local/redis-4.0.0/src/redis-server</code></p>
<p><code>/usr/local/redis-4.0.0/src/redis-cli</code></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5spmhpoj216c0k4jxz.jpg" alt="image-20210927094452556"></p>
<p>通过启动日志可以看到，Redis默认端口号为&#x3D;&#x3D;6379&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p>
<p>通过&#x3D;&#x3D;redis-cli&#x3D;&#x3D;可以连接到本地的Redis服务，默认情况下不需要认证即可连接成功。</p>
<p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p>
<p><strong>2）Windows系统中启动和停止Redis</strong></p>
<p>Windows系统中启动Redis，直接双击redis-server.exe即可启动Redis服务，redis服务默认端口号为6379</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqhzd8j20xz0hrdix.jpg" alt="image-20210927100421213"></p>
<p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p>
<p>双击&#x3D;&#x3D;redis-cli.exe&#x3D;&#x3D;即可启动Redis客户端，默认连接的是本地的Redis服务，而且不需要认证即可连接成功。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqsuvzj20xz0hr0t8.jpg" alt="image-20210927100319016"></p>
<p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p>
<h3 id="2-4-Redis配置文件"><a href="#2-4-Redis配置文件" class="headerlink" title="2.4 Redis配置文件"></a>2.4 Redis配置文件</h3><p>前面我们已经启动了Redis服务，默认情况下Redis启动后是在前台运行，而且客户端不需要密码就可以连接到Redis服务。如果我们希望Redis服务启动后是在后台运行，同时希望客户端认证通过后才能连接到Redis服务，应该如果做呢？</p>
<p>此时就需要修改Redis的配置文件：</p>
<ul>
<li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li>
<li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li>
</ul>
<p><strong>通过修改Redis配置文件可以进行如下配置：</strong></p>
<p><strong>1）</strong>设置Redis服务后台运行</p>
<p>​    将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p>
<p>​    注意：Windows版的Redis不支持后台运行。</p>
<p><strong>2）</strong>设置Redis服务密码</p>
<p>​    将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p>
<p><strong>3）</strong>设置允许客户端远程连接Redis服务</p>
<p>​    Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p>
<p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p>
<p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p>
<p>requirepass：设置Redis的连接密码</p>
<p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p>
</blockquote>
<p><strong>注意</strong>：修改配置文件后需要重启Redis服务配置才能生效，&#x3D;&#x3D;并且&#x3D;&#x3D;启动Redis服务时需要显示的指定配置文件：</p>
<p>1）Linux中启动Redis服务</p>
<pre class="line-numbers language-none"><code class="language-none"># 进入Redis安装目录
cd &#x2F;usr&#x2F;local&#x2F;redis-4.0.0
# 启动Redis服务，指定使用的配置文件
.&#x2F;src&#x2F;redis-server .&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>2）Windows中启动Redis服务</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ssqiloj20xz0e4dit.jpg" alt="image-20210927104929169"></p>
<p>由于Redis配置文件中开启了认证校验，即客户端连接时需要提供密码，此时客户端连接方式变为：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sti807j20ny09uq3j.jpg" alt="image-20210927105909600"></p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>-h：指定连接的Redis服务的ip地址</p>
<p>-p：指定连接的Redis服务的端口号</p>
<p>-a：指定连接的Redis服务的密码</p>
</blockquote>
<h2 id="3-Redis数据类型"><a href="#3-Redis数据类型" class="headerlink" title="3. Redis数据类型"></a>3. Redis数据类型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p>
<ul>
<li>字符串 string</li>
<li>哈希 hash</li>
<li>列表 list</li>
<li>集合 set</li>
<li>有序集合 sorted set &#x2F; zset</li>
</ul>
<h3 id="3-2-Redis-5种常用数据类型"><a href="#3-2-Redis-5种常用数据类型" class="headerlink" title="3.2 Redis 5种常用数据类型"></a>3.2 Redis 5种常用数据类型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5svuyd2j20od0e50tf.jpg" alt="image-20210927111819871"></p>
<p><strong>解释说明：</strong></p>
<blockquote>
<p>字符串(string)：普通字符串，常用</p>
<p>哈希(hash)：适合存储对象</p>
<p>列表(list)：按照插入顺序排序，可以有重复元素</p>
<p>集合(set)：无序集合，没有重复元素</p>
<p>有序集合(sorted set &#x2F; zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</p>
</blockquote>
<h2 id="4-Redis常用命令"><a href="#4-Redis常用命令" class="headerlink" title="4. Redis常用命令"></a>4. Redis常用命令</h2><h3 id="4-1-字符串string操作命令"><a href="#4-1-字符串string操作命令" class="headerlink" title="4.1 字符串string操作命令"></a>4.1 字符串string操作命令</h3><p>Redis 中字符串类型常用命令：</p>
<ul>
<li><strong>SET</strong> key value                              设置指定key的值</li>
<li><strong>GET</strong> key                                        获取指定key的值</li>
<li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li>
<li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li>
</ul>
<p>更多命令可以参考Redis中文网：<a target="_blank" rel="noopener" href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p>
<h3 id="4-2-哈希hash操作命令"><a href="#4-2-哈希hash操作命令" class="headerlink" title="4.2 哈希hash操作命令"></a>4.2 哈希hash操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p>
<ul>
<li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li>
<li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li>
<li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li>
<li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li>
<li><strong>HVALS</strong> key                              获取哈希表中所有值</li>
<li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t21hlmj20m503jmx3.jpg" alt="image-20210927113014567"></p>
<h3 id="4-3-列表list操作命令"><a href="#4-3-列表list操作命令" class="headerlink" title="4.3 列表list操作命令"></a>4.3 列表list操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p>
<ul>
<li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li>
<li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li>
<li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li>
<li><strong>LLEN</strong> key                                        获取列表长度</li>
<li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t3ub6oj20nh042t8n.jpg" alt="image-20210927113312384"></p>
<p>list特点：双端阻塞队列</p>
<p>操作技巧：FIFO，先进先出。</p>
<h3 id="4-4-集合set操作命令"><a href="#4-4-集合set操作命令" class="headerlink" title="4.4 集合set操作命令"></a>4.4 集合set操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p>
<ul>
<li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li>
<li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li>
<li><strong>SCARD</strong> key                                                  获取集合的成员数</li>
<li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li>
<li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li>
<li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li>
<li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t66f4mj20ma03xgli.jpg" alt="image-20210927113632472"></p>
<h3 id="4-5-有序集合sorted-set操作命令"><a href="#4-5-有序集合sorted-set操作命令" class="headerlink" title="4.5 有序集合sorted set操作命令"></a>4.5 有序集合sorted set操作命令</h3><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p>
<p>常用命令：</p>
<ul>
<li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li>
<li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li>
<li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li>
<li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t72qyej20ng04pt8n.jpg" alt="image-20210927114003383"></p>
<h3 id="4-6-通用命令"><a href="#4-6-通用命令" class="headerlink" title="4.6 通用命令"></a>4.6 通用命令</h3><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p>
<ul>
<li><p><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </p>
</li>
<li><p><strong>EXISTS</strong> key  检查给定 key 是否存在</p>
</li>
<li><p><strong>TYPE</strong> key  返回 key 所储存的值的类型</p>
</li>
<li><p><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</p>
</li>
<li><p><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</p>
<p><code>keys * 引发的宕机事故：</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014756578/article/details/91951793">https://blog.csdn.net/u014756578/article/details/91951793</a></p>
</li>
</ul>
<h2 id="5-在Java中操作Redis"><a href="#5-在Java中操作Redis" class="headerlink" title="5. 在Java中操作Redis"></a>5. 在Java中操作Redis</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p>
<p>Redis 的 Java 客户端很多，官方推荐的有三种：</p>
<ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p>
<h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p>
<p>maven坐标：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 Jedis 操作 Redis 的步骤：</p>
<ol>
<li>获取连接</li>
<li>执行操作</li>
<li>关闭连接</li>
</ol>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 使用Jedis操作Redis
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisTest</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">//1 获取连接</span>
        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//2 执行具体的操作</span>
        jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span> value <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//jedis.del("username");</span>

        jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"myhash"</span><span class="token punctuation">,</span><span class="token string">"addr"</span><span class="token punctuation">,</span><span class="token string">"bj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> hValue <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hget</span><span class="token punctuation">(</span><span class="token string">"myhash"</span><span class="token punctuation">,</span> <span class="token string">"addr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">//3 关闭连接</span>
        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-Spring-Data-Redis"><a href="#5-3-Spring-Data-Redis" class="headerlink" title="5.3 Spring Data Redis"></a>5.3 Spring Data Redis</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p>
<p>网址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tadff7j21810r67b7.jpg" alt="image-20210927143741458"></p>
<p>maven坐标：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.data<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Spring Boot提供了对应的Starter，maven坐标：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p>
<ul>
<li>ValueOperations：简单K-V操作</li>
<li>SetOperations：set类型数据操作</li>
<li>ZSetOperations：zset类型数据操作</li>
<li>HashOperations：针对hash类型的数据操作</li>
<li>ListOperations：针对list类型的数据操作</li>
</ul>
<h4 id="5-3-2-使用方式"><a href="#5-3-2-使用方式" class="headerlink" title="5.3.2 使用方式"></a>5.3.2 使用方式</h4><h5 id="5-3-2-1-环境搭建"><a href="#5-3-2-1-环境搭建" class="headerlink" title="5.3.2.1 环境搭建"></a>5.3.2.1 环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>
         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.itheima<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springdataredis_demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>
    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第二步：编写启动类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">App</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第三步：配置application.yml</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> springdataredis_demo
  <span class="token comment">#Redis相关配置</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
    <span class="token comment">#password: 123456</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token comment">#操作的是0号数据库</span>
    <span class="token key atrule">jedis</span><span class="token punctuation">:</span>
      <span class="token comment">#Redis连接池配置</span>
      <span class="token key atrule">pool</span><span class="token punctuation">:</span>
        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span> <span class="token comment">#最大连接数</span>
        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> 1ms <span class="token comment">#连接池最大阻塞等待时间</span>
        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#连接池中的最大空闲连接</span>
        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token comment">#连接池中的最小空闲连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解释说明：</p>
<blockquote>
<p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p>
<p>可以通过修改Redis配置文件来指定数据库的数量。</p>
</blockquote>
<p>第四步：提供配置类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">CachingConfigurerSupport</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span></span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token class-name">StringRedisSerializer</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Redis配置类
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> redisTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        redisTemplate<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解释说明：</p>
<blockquote>
<p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p>
</blockquote>
<p>第五步：提供测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootTest</span>
<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringDataRedisTest</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="5-3-2-2-操作字符串类型数据"><a href="#5-3-2-2-操作字符串类型数据" class="headerlink" title="5.3.2.2 操作字符串类型数据"></a>5.3.2.2 操作字符串类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 操作String类型数据
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//存值</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"city123"</span><span class="token punctuation">,</span><span class="token string">"beijing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"city123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值，同时设置过期时间</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span><span class="token string">"value1"</span><span class="token punctuation">,</span><span class="token number">10l</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值，如果存在则不执行任何操作</span>
    <span class="token class-name">Boolean</span> aBoolean <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"city1234"</span><span class="token punctuation">,</span> <span class="token string">"nanjing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aBoolean<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="5-3-2-3-操作哈希类型数据"><a href="#5-3-2-3-操作哈希类型数据" class="headerlink" title="5.3.2.3 操作哈希类型数据"></a>5.3.2.3 操作哈希类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 操作Hash类型数据
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">HashOperations</span> hashOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值</span>
    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token punctuation">,</span><span class="token string">"bj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    <span class="token class-name">String</span> age <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> hashOperations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//获得hash结构中的所有字段</span>
    <span class="token class-name">Set</span> keys <span class="token operator">=</span> hashOperations<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//获得hash结构中的所有值</span>
    <span class="token class-name">List</span> values <span class="token operator">=</span> hashOperations<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="5-3-2-4-操作列表类型数据"><a href="#5-3-2-4-操作列表类型数据" class="headerlink" title="5.3.2.4 操作列表类型数据"></a>5.3.2.4 操作列表类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 操作List类型的数据
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">ListOperations</span> listOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值</span>
    listOperations<span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    listOperations<span class="token punctuation">.</span><span class="token function">leftPushAll</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> mylist <span class="token operator">=</span> listOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//获得列表长度 llen</span>
    <span class="token class-name">Long</span> size <span class="token operator">=</span> listOperations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lSize <span class="token operator">=</span> size<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//出队列</span>
        <span class="token class-name">String</span> element <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> listOperations<span class="token punctuation">.</span><span class="token function">rightPop</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="5-3-2-5-操作集合类型数据"><a href="#5-3-2-5-操作集合类型数据" class="headerlink" title="5.3.2.5 操作集合类型数据"></a>5.3.2.5 操作集合类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 操作Set类型的数据
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">SetOperations</span> setOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值</span>
    setOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myset <span class="token operator">=</span> setOperations<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> o <span class="token operator">:</span> myset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//删除成员</span>
    setOperations<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    myset <span class="token operator">=</span> setOperations<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> o <span class="token operator">:</span> myset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="5-3-2-6-操作有序集合类型数据"><a href="#5-3-2-6-操作有序集合类型数据" class="headerlink" title="5.3.2.6 操作有序集合类型数据"></a>5.3.2.6 操作有序集合类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 操作ZSet类型的数据
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testZset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">ZSetOperations</span> zSetOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForZSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//存值</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">11.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">13.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//修改分数</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">incrementScore</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//删除成员</span>
    zSetOperations<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//取值</span>
    myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="5-3-2-7-通用操作"><a href="#5-3-2-7-通用操作" class="headerlink" title="5.3.2.7 通用操作"></a>5.3.2.7 通用操作</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 通用操作，针对不同的数据类型都可以操作
*/</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//获取Redis中所有的key</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//判断某个key是否存在</span>
    <span class="token class-name">Boolean</span> itcast <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>itcast<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//删除指定key</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//获取指定key对应的value的数据类型</span>
    <span class="token class-name">DataType</span> dataType <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dataType<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/12/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux的常用命令</a>
            </div>
            <p class="sub">5月 12 2022</p>
            <div class="post-content">
                
                    <h4 id="停止防火墙"><a href="#停止防火墙" class="headerlink" title="#停止防火墙"></a>#停止防火墙</h4><p>systemctl stop firewalld</p>
<h4 id="禁用防火墙开机启动"><a href="#禁用防火墙开机启动" class="headerlink" title="#禁用防火墙开机启动"></a>#禁用防火墙开机启动</h4><p>systemctl disable firewalld</p>
<h4 id="停止网络管理器"><a href="#停止网络管理器" class="headerlink" title="#停止网络管理器"></a>#停止网络管理器</h4><p>systemctl stop NetworkManager</p>
<h4 id="禁止开机自启"><a href="#禁止开机自启" class="headerlink" title="#禁止开机自启"></a>#禁止开机自启</h4><p>systemctl disable NetworkManager</p>
<h4 id="加压jdk"><a href="#加压jdk" class="headerlink" title="#加压jdk"></a>#加压jdk</h4><p>tar -zxvf jdk-8u171-linux-x64.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="配置jdk的环境变量"><a href="#配置jdk的环境变量" class="headerlink" title="#配置jdk的环境变量"></a>#配置jdk的环境变量</h4><p>echo ‘JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p>
<h4 id="重新加载文件"><a href="#重新加载文件" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p>
<h4 id="查看jdk版本"><a href="#查看jdk版本" class="headerlink" title="#查看jdk版本"></a>#查看jdk版本</h4><p>java -version</p>
<h4 id="解压tomcat"><a href="#解压tomcat" class="headerlink" title="#解压tomcat"></a>#解压tomcat</h4><p>tar -zxvf apache-tomcat-7.0.57.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="卸载mariadb数据库"><a href="#卸载mariadb数据库" class="headerlink" title="#卸载mariadb数据库"></a>#卸载mariadb数据库</h4><p>rpm -e –nodeps  <code>rpm -qa | grep mariadb</code></p>
<h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="#创建文件夹"></a>#创建文件夹</h4><p>mkdir &#x2F;usr&#x2F;local&#x2F;mysql</p>
<h4 id="解压mysql"><a href="#解压mysql" class="headerlink" title="#解压mysql"></a>#解压mysql</h4><p>tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C &#x2F;usr&#x2F;local&#x2F;mysql</p>
<h4 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="#安装依赖环境"></a>#安装依赖环境</h4><p>yum install -y net-tools perl libaio openssl gcc pcre-devel zlib-devel openssl vim openssl-devel</p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="#安装mysql"></a>#安装mysql</h4><p>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-common-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-devel-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-client-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-server-5.7.25-1.el7.x86_64.rpm</p>
<h4 id="开启mysql服务"><a href="#开启mysql服务" class="headerlink" title="#开启mysql服务"></a>#开启mysql服务</h4><p>systemctl start mysqld</p>
<h4 id="查看临时密码"><a href="#查看临时密码" class="headerlink" title="#查看临时密码"></a>#查看临时密码</h4><p>cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</p>
<h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="#登录数据库"></a>#登录数据库</h4><p>mysql -uroot -p</p>
<pre><code>set global validate_password_length=4;
set global validate_password_policy=LOW;
set password = password(&#39;root&#39;);
grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;
flush privileges;
</code></pre>
<h4 id="修改MySQL编码"><a href="#修改MySQL编码" class="headerlink" title="#修改MySQL编码"></a>#修改MySQL编码</h4><p>vim &#x2F;etc&#x2F;my.cnf</p>
<pre><code>[client]
default_character_set=utf8

[mysql]
default_character_set=utf8

[mysqld]
character_set_server=utf8
</code></pre>
<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="#重启服务"></a>#重启服务</h4><p>systemctl restart mysqld</p>
<h4 id="查看数据库编码"><a href="#查看数据库编码" class="headerlink" title="#查看数据库编码"></a>#查看数据库编码</h4><p>mysql -uroot -proot -e “show variables like ‘%char%’;”</p>
<h4 id="安装git"><a href="#安装git" class="headerlink" title="#安装git"></a>#安装git</h4><p>yum install -y git</p>
<h4 id="解压maven"><a href="#解压maven" class="headerlink" title="#解压maven"></a>#解压maven</h4><p>tar -zxvf apache-maven-3.5.4-bin.tar.gz -C &#x2F;usr&#x2F;local</p>
<h4 id="配置maven环境变量"><a href="#配置maven环境变量" class="headerlink" title="#配置maven环境变量"></a>#配置maven环境变量</h4><p>echo ‘MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p>
<h4 id="重新加载文件-1"><a href="#重新加载文件-1" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p>
<h4 id="查看maven版本"><a href="#查看maven版本" class="headerlink" title="#查看maven版本"></a>#查看maven版本</h4><p>mvn -v</p>
<h4 id="删除settings文件"><a href="#删除settings文件" class="headerlink" title="#删除settings文件"></a>#删除settings文件</h4><p>rm -rf &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p>
<h4 id="拷贝settings文件"><a href="#拷贝settings文件" class="headerlink" title="#拷贝settings文件"></a>#拷贝settings文件</h4><p>cp &#x2F;root&#x2F;settings.xml  &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p>
<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="#本地仓库"></a>#本地仓库</h4><p>mv &#x2F;root&#x2F;repo &#x2F;usr&#x2F;local</p>
<h4 id="修改静态IP"><a href="#修改静态IP" class="headerlink" title="#修改静态IP"></a>#修改静态IP</h4><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32</p>
<p> BOOTPROTO&#x3D;static<br> IPADDR&#x3D;192.168.100.100<br> GATEWAY&#x3D;192.168.100.2<br> NETMASK&#x3D;255.255.255.0<br> DNS1&#x3D;8.8.8.8</p>
<h4 id="重启网卡"><a href="#重启网卡" class="headerlink" title="#重启网卡"></a>#重启网卡</h4><p>systemctl restart network</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/NGINX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">NEGINX学习总结</a>
            </div>
            <p class="sub">5月 11 2022</p>
            <div class="post-content">
                
                    <h2 id="Nginx-概述"><a href="#Nginx-概述" class="headerlink" title="Nginx-概述"></a>Nginx-概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q6nrd7j206t01pgli.jpg" alt="image-20210829234142590"> </p>
<p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>Nginx是由<strong>伊戈尔·赛索耶夫</strong>为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://nginx.org/">https://nginx.org/</a></p>
<h3 id="4-2-下载和安装"><a href="#4-2-下载和安装" class="headerlink" title="4.2 下载和安装"></a>4.2 下载和安装</h3><h4 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h4><p>在Nginx的官网的下载页面中(<a target="_blank" rel="noopener" href="http://nginx.org/en/download.html)%EF%BC%8C%E5%B0%B1%E5%B1%95%E7%A4%BA%E4%BA%86%E5%BD%93%E5%89%8DNginx%E7%89%88%E6%9C%AC%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82">http://nginx.org/en/download.html)，就展示了当前Nginx版本，并提供了下载的连接。</a> 如下： </p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q8htihj217c0inwk1.jpg" alt="image-20210829234623737" style="zoom:80%;" /> 

<p>在本项目中，我们所学习的Nginx选择的是稳定版本的1.16这个版本，我们可以直接从官网下载</p>
<h4 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2 安装"></a>4.2.2 安装</h4><p><strong>1). 安装依赖包</strong></p>
<p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p>
<pre class="line-numbers language-none"><code class="language-none">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>2). 下载Nginx安装包</strong></p>
<pre class="line-numbers language-none"><code class="language-none">yum install wget
wget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>wget : </p>
<p>​    wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。</p>
</blockquote>
<p>执行完wget指令后，就会在当前所在目录看到下载下来的文件。</p>
<p><strong>3). 解压nginx压缩包</strong></p>
<pre class="line-numbers language-none"><code class="language-none">tar -zxvf nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>4). 配置Nginx编译环境</strong></p>
<pre class="line-numbers language-none"><code class="language-none">cd nginx-1.16.1
.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>说明: </p>
<p>​    –prefix 指定的目录，就是我们安装Nginx的目录。</p>
<p><strong>5). 编译&amp;安装</strong></p>
<pre class="line-numbers language-none"><code class="language-none">make &amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="4-3-目录结构"><a href="#4-3-目录结构" class="headerlink" title="4.3 目录结构"></a>4.3 目录结构</h3><p>安装完Nginx后，我们可以切换到Nginx的安装目录(&#x2F;usr&#x2F;local&#x2F;nginx)，先来熟悉一下Nginx的目录结构，如下图：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qd1z0zj21310jl78b.jpg" alt="image-20210830000933352" style="zoom:90%;" /> 

<blockquote>
<p>备注： </p>
<p>​    上述我们用到的一个指令 tree，该指令可以将我们指定的目录以树状结构展示出来。如果没有这个指令，可以通过以下指令进行安装。</p>
<p>​    yum install tree</p>
</blockquote>
<p>重点目录和文件如下: </p>
<table>
<thead>
<tr>
<th>目录&#x2F;文件</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>配置文件的存放目录</td>
<td></td>
</tr>
<tr>
<td>conf&#x2F;nginx.conf</td>
<td>Nginx的核心配置文件</td>
<td>conf下有很多nginx的配置文件，我们主要操作这个核心配置文件</td>
</tr>
<tr>
<td>html</td>
<td>存放静态资源(html, css, )</td>
<td>部署到Nginx的静态资源都可以放在html目录中</td>
</tr>
<tr>
<td>logs</td>
<td>存放nginx日志(访问日志、错误日志等)</td>
<td></td>
</tr>
<tr>
<td>sbin&#x2F;nginx</td>
<td>二进制文件，用于启动、停止Nginx服务</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-Nginx-命令"><a href="#5-Nginx-命令" class="headerlink" title="5. Nginx-命令"></a>5. Nginx-命令</h2><h3 id="5-1-常用命令"><a href="#5-1-常用命令" class="headerlink" title="5.1 常用命令"></a>5.1 常用命令</h3><p>Nginx中，我们的二进制可执行文件(nginx)存放在sbin目录下，虽然只有一个可执行文件，但是我们可以通过该指令配合不同的参数达到更加强大的功能。接下来，我们就演示一下Nginx常见指令, 在执行下面的指令时,都需要在&#x3D;&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;&#x3D;&#x3D;目录下执行。</p>
<p><strong>1). 查看版本</strong></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qdraafj213002d0t9.jpg" alt="image-20210830223435585"> </p>
<p><strong>2). 检查配置文件</strong></p>
<p>修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf&#x2F;nginx.conf文件配置的是否有错误，命令如下：</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qfj1shj211z03u75q.jpg" alt="image-20210830223511878"> </p>
<p><strong>3). 启动</strong></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qglixpj2139036t9x.jpg" alt="image-20210830224019661"> </p>
<p>注意： nginx服务启动后，默认就会有两个进程。</p>
<p>启动之后，我们可以直接访问Nginx的80端口， <a target="_blank" rel="noopener" href="http://192.168.200.200/">http://192.168.200.200</a></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qiatq9j20wg07e0u8.jpg" alt="image-20210830224605952" style="zoom:80%;" /> 



<blockquote>
<p>注意：</p>
<p>​    要想正常访问Nginx，需要关闭防火墙或开放指定端口号，执行的指令如下： </p>
<p>​    A. 关闭防火墙</p>
<p>​        systemctl stop firewalld</p>
<p>​    B. 开放80端口</p>
<p>​        firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p>
<p>​        firewall-cmd –reload</p>
</blockquote>
<p><strong>4). 停止</strong></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -s stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>停止之后，我们可以查看nginx的进程： </p>
<pre class="line-numbers language-none"><code class="language-none">ps -ef|grep nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qkle8hj21550330tk.jpg" alt="image-20210830224121489"> </p>
<p><strong>5). 重新加载</strong></p>
<p>当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>在上述我们在使用nginx命令在进行服务的启动、停止、重新加载时，都需要用到一个指令nginx，而这个指令是在nginx&#x2F;sbin目录下的，我们每一次使用这个指令都需要切换到sbin目录才可以，使用相对繁琐。那么我们能不能在任意目录下都可以执行该指令来操作nginx呢？答案是可以的，配置nginx的环境变量即可。</p>
<p>通过vim编辑器，打开&#x2F;etc&#x2F;profile文件, 在PATH环境变量中增加nginx的sbin目录，如下： </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qmhcirj20v302wt9b.jpg" alt="image-20210830225544343"> </p>
<p>修改完配置文件之后，需要执行 source &#x2F;etc&#x2F;profile 使文件生效。 接下来，我们就可以在任意目录下执行nginx的指令了，如： </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qoam9sj2127043t9y.jpg" alt="image-20210830225702899"> </p>
<h2 id="6-Nginx-应用"><a href="#6-Nginx-应用" class="headerlink" title="6. Nginx-应用"></a>6. Nginx-应用</h2><p>介绍了并安装了Nginx之后，本章节将要讲解的是Nginx的使用，我们主要从以下四个方面进行讲解。</p>
<h3 id="6-1-配置文件结构"><a href="#6-1-配置文件结构" class="headerlink" title="6.1 配置文件结构"></a>6.1 配置文件结构</h3><p>nginx的配置文件(conf&#x2F;nginx.conf)整体上分为三部分: 全局块、events块、http块。这三块的分别配置什么样的信息呢，看下表： </p>
<table>
<thead>
<tr>
<th>区域</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>全局块</td>
<td>配置和nginx运行相关的全局配置</td>
</tr>
<tr>
<td>events块</td>
<td>配置和网络连接相关的配置</td>
</tr>
<tr>
<td>http块</td>
<td>配置代理、缓存、日志记录、虚拟主机等配置</td>
</tr>
</tbody></table>
<p>具体结构图如下: </p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qun39kj20rf0k7dj8.jpg" alt="image-20210830230827686" style="zoom:80%;" /> 

<blockquote>
<p>在全局块、events块以及http块中，我们经常配置的是http块。</p>
<p>在http块中可以包含多个server块,每个server块可以配置多个location块。</p>
</blockquote>
<h3 id="6-2-部署静态资源"><a href="#6-2-部署静态资源" class="headerlink" title="6.2 部署静态资源"></a>6.2 部署静态资源</h3><h4 id="6-2-1-介绍"><a href="#6-2-1-介绍" class="headerlink" title="6.2.1 介绍"></a>6.2.1 介绍</h4><p><strong>Nginx可以作为静态web服务器来部署静态资源</strong>。这里所说的静态资源是指在服务端真实存在，并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p>
<p><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</strong></p>
<p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">80;				#监听端口	</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;	#服务器名称</span>
<span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;			#匹配客户端请求url</span>
<span class="token attr-name">        root</span> <span class="token attr-value">html;			#指定静态资源根目录</span>
<span class="token attr-name">        index</span> <span class="token attr-value">index.html;	#指定默认首页</span>
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-2-测试"><a href="#6-2-2-测试" class="headerlink" title="6.2.2 测试"></a>6.2.2 测试</h4><p>在资料中，我们提供了一个静态的html文件，我们需要将这个文件部署到nginx中，然后通过nginx访问html静态资源。</p>
<p><strong>1). 将静态资源上传到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html 目录</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r16sh0j213v04qmyi.jpg" alt="image-20210830232238402"> </p>
<p><strong>2). 启动nginx</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r27gfuj214609dadc.jpg" alt="image-20210830232419462"> </p>
<p><strong>3). 访问</strong></p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/hello.html">http://192.168.100.100/hello.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r4itx5j20g605daa9.jpg" alt="image-20220220180550093"> </p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a> ， 访问该地址，访问的是nginx的默认首页</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r6eu4aj20lv0a8ta8.jpg" alt="image-20220220180207165"></p>
<p><strong>4). 配置首页</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r5ooaij20lv0a8ta8.jpg" alt="image-20210830232720821"> </p>
<p>如果我们需要将hello.html作为nginx的首页，可以修改location的index指令，配置为hello.html，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r9td6ij214609dadc.jpg" alt="image-20210830233019489"> </p>
<p>配置完毕后，我们可以通过指令，来检查配置文件是否配置正确： nginx -t</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r82i9mj214609dadc.jpg" alt="image-20210830233122708"> </p>
<p>配置文件修改了，我们需要重新加载一下，才可以生效： </p>
<pre class="line-numbers language-none"><code class="language-none">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>5). 访问</strong></p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5radelvj20h4054weq.jpg" alt="image-20220220180805583"> </p>
<h3 id="6-3-反向代理"><a href="#6-3-反向代理" class="headerlink" title="6.3 反向代理"></a>6.3 反向代理</h3><h4 id="6-3-1-概念介绍"><a href="#6-3-1-概念介绍" class="headerlink" title="6.3.1 概念介绍"></a>6.3.1 概念介绍</h4><p>1). 正向代理</p>
<p>正向代理服务器是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p><strong>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径</strong>。</p>
<p>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rdb0ajj20h507imxi.jpg" alt="image-20210830233450415"> </p>
<p>2). 反向代理</p>
<p>反向代理服务器位于用户与目标服务器之间，<strong>但是对于用户而言，反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。<strong>用户不需要知道目标服务器的地址，也无须在用户端作任何设定，对于用户来说，访问反向代理服务器是完全无感知的。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rewzahj20of09o754.jpg" alt="image-20210830233634695"> </p>
<p>那么在本小节，我们就是要使用nginx来作为反向代理服务器使用。 在nginx中，我们可以在nginx.conf中配置反向代理: </p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">80;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;</span>
<span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span>
<span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://192.168.100.200:8080; 	#反向代理配置，将请求转发到指定服务</span>
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述配置的含义为: 当我们访问nginx的80端口时，</p>
<p>根据反向代理配置，会将请求转发到 <a target="_blank" rel="noopener" href="http://192.168.100.200:8080/">http://192.168.100.200:8080</a> 对应的服务上。</p>
<h4 id="6-3-2-测试"><a href="#6-3-2-测试" class="headerlink" title="6.3.2 测试"></a>6.3.2 测试</h4><p>需求: 在192.168.100.200这台服务器中部署了java应用，运行端口为8080，并提供了一个可访问的链接 &#x2F;hello。现在我们需要在访问nginx时，通过nginx将请求转发到192.168.100.200:8080的服务。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rgs9s9j20rc06vq3j.jpg" alt="image-20210830235803013" style="zoom:67%;" /> 



<p><strong>1). 在192.168.100.200 部署服务并启动</strong></p>
<p>将资料中提供的 helloworld-8080.jar 上传到服务器端，并通过指令 java -jar helloworld-8080.jar 运行服务。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rmlqi8j21g40hu48d.jpg" alt="image-20210831000152199"> </p>
<p><strong>2). 在192.168.100.100中的nginx.conf中配置反向代理</strong></p>
<p>进入nginx的安装目录，并编辑配置文件nginx.conf:</p>
<pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;
vim nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">80;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;</span>
<span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span>
<span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://192.168.100.200:8080; 	#反向代理配置，将请求转发到指定服务</span>
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>3). 检查配置文件，并重新加载</strong></p>
<pre class="line-numbers language-none"><code class="language-none">nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rnv8hxj213u02dmy1.jpg" alt="image-20210831001021252"> </p>
<pre class="line-numbers language-none"><code class="language-none">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>4). 访问</strong> </p>
<p><a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a></p>
<h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><h4 id="6-4-1-概念介绍"><a href="#6-4-1-概念介绍" class="headerlink" title="6.4.1 概念介绍"></a>6.4.1 概念介绍</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p>
<p><strong>应用集群：</strong>将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p>
<p><strong>负载均衡器：</strong>将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rogb0lj213u02dmy1.jpg" alt="image-20210831080743617" style="zoom:80%;" />  

<p>此处的负载均衡器，我们将会使用Nginx来实现，而Nginx的负载均衡是基于反向代理的，只不过此时所代理的服务器不是一台，而是多台。</p>
<h4 id="6-4-2-测试"><a href="#6-4-2-测试" class="headerlink" title="6.4.2 测试"></a>6.4.2 测试</h4><p><strong>1). 将资料中提供的两个jar包，上传到 192.168.100.200 服务器上</strong></p>
<table>
<thead>
<tr>
<th>jar</th>
<th>运行端口</th>
<th>请求链接</th>
<th>响应数据</th>
</tr>
</thead>
<tbody><tr>
<td>![image-20220511211247384](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211247384.png)</td>
<td>8080</td>
<td>&#x2F;hello</td>
<td>8080</td>
</tr>
<tr>
<td>![image-20220511211258476](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211258476.png)</td>
<td>8081</td>
<td>&#x2F;hello</td>
<td>8081</td>
</tr>
</tbody></table>
<blockquote>
<p>我们在测试时，并没有那么多服务器，我们可以在一台服务器中启动多个服务，运行在不同的端口号上进行测试。</p>
</blockquote>
<p><strong>2). 运行上传上来的两个jar包，运行端口分别是 8080 ， 8081</strong></p>
<p>由于我们执行 java -jar 指令会占用前台窗口，所以我们可以采用后台模式运行。</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nohup java -jar helloworld-8080.jar &amp;&gt; helloworld-8080.log &amp;
nohup java -jar helloworld-8081.jar &amp;&gt; helloworld-8081.log &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>





<p><strong>3). 在nginx中配置负载均衡</strong></p>
<p>打开nginx的配置文件nginx.conf并增加如下配置: </p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#upstream指令可以定义一组服务器</span>
<span class="token attr-name">upstream</span> <span class="token attr-value">targetserver&#123;	</span>
<span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8080;</span>
<span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8081;</span>
&#125;

<span class="token attr-name">server</span> <span class="token attr-value">&#123;</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">      80;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value"> localhost;</span>
<span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span>
<span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://targetserver;</span>
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>具体的配置位置如下: </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rsejyxj20qc08s0tf.jpg" alt="image-20220220182717939"> </p>
<p><strong>4). 重新加载nginx配置文件,访问</strong></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>测试时,我们直接访问nginx(<a target="_blank" rel="noopener" href="http://192.168.100.100/">http://192.168.100.100</a>), 此时nginx会根据负载均衡策略,将请求转发到后面的两台服务器。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5s04giaj20p403omxc.jpg" alt="image-20220220182548353"> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rrfbfhj20ow03v74g.jpg" alt="image-20220220182613070"> </p>
<p>在上述的测试过程中，我们看到请求均衡的转发到了8080和8081，因为模式的负载均衡策略是&#x3D;&#x3D;轮询&#x3D;&#x3D;。</p>
<p><font color="red" size="5">注意: 上述所有涉及到的端口号，都需要在对应的服务器的防火墙中开放，或者彻底关闭防火墙</font></p>
<h4 id="6-4-3-负载均衡策略"><a href="#6-4-3-负载均衡策略" class="headerlink" title="6.4.3 负载均衡策略"></a>6.4.3 负载均衡策略</h4><p>处理上述默认的轮询策略以外，在Nginx中还提供了其他的负载均衡策略，如下： </p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
<td></td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
<td>根据权重分发请求,权重大的分配到请求的概率大</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
<td>根据客户端请求的IP地址计算hash值， 根据hash值来分发请求, 同一个IP发起的请求, 会发转发到同一个服务器上</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
<td>哪个服务器当前处理的连接少, 请求优先转发到这台服务器</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式</td>
<td>根据客户端请求url的hash值，来分发请求, 同一个url请求, 会发转发到同一个服务器上</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
<td>优先把请求分发给处理请求时间短的服务器</td>
</tr>
</tbody></table>
<p>权重的配置： </p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#upstream指令可以定义一组服务器</span>
<span class="token attr-name">upstream</span> <span class="token attr-value">targetserver&#123;	</span>
<span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8080 weight=10;</span>
<span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8081 weight=5;</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述配置的weight权重是相对的，在上述的配置中，效果就是，在大数据量的请求下，最终8080接收的请求数是8081的两倍。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8CShardingJDBC/">数据库主从复制</a>
            </div>
            <p class="sub">5月 11 2022</p>
            <div class="post-content">
                
                    <h2 id="1-MySQL主从复制"><a href="#1-MySQL主从复制" class="headerlink" title="1. MySQL主从复制"></a>1. MySQL主从复制</h2><p>MySQL数据库默认是支持主从复制的，不需要借助于其他的技术，我们只需要在数据库中简单的配置即可。接下来，我们就从以下的几个方面，来介绍一下主从复制：</p>
<h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的 <strong>二进制日志</strong> 功能。就是一台或多台MySQL数据库（slave，即<strong>从库</strong>）从另一台MySQL数据库（master，即<strong>主库</strong>）进行日志的复制，然后再解析日志并应用到自身，最终实现 <strong>从库</strong> 的数据和 <strong>主库</strong> 的数据保持一致。MySQL主从复制是<strong>MySQL数据库自带功能</strong>，无需借助第三方工具。</p>
<blockquote>
<p><strong>二进制日志：</strong> </p>
<p>​    二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句,包括改密码，<strong>但是不包括数据查询语句</strong>。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该<strong>binlog</strong>实现的。<strong>默认MySQL是未开启该日志的。</strong></p>
</blockquote>
<p><strong>MySQL的主从复制原理如下：</strong> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5jw19fkj20fk0amq3k.jpg" alt="image-20220511204640329"></p>
<p><strong>MySQL复制过程分成三步：</strong></p>
<p>1). MySQL master 将数据变更写入二进制日志( binary log)</p>
<p>2). slave将master的binary log拷贝到它的中继日志（relay log）</p>
<p>3). slave重做中继日志中的事件，将数据变更反映它自己的数据</p>
<h3 id="1-2-主库配置"><a href="#1-2-主库配置" class="headerlink" title="1.2 主库配置"></a>1.2 主库配置</h3><p> <strong>1)修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong>**</p>
<p>在[mysqld]下面增加配置: </p>
<pre class="line-numbers language-none"><code class="language-none">log-bin&#x3D;mysql-bin   #[必须]启用二进制日志
server-id&#x3D;100       #[必须]服务器唯一ID(唯一即可)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k0049hj20jp0a3q4f.jpg" alt="image-20220511205023685"></p>
<p><strong>2)重启Mysql服务</strong></p>
<p>执行指令： </p>
<pre class="line-numbers language-none"><code class="language-none">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k3zn92j20uo01ujro.jpg" alt="image-20210825115853116"> </p>
<p><strong>3). 创建数据同步的用户并授权</strong></p>
<p>登录mysql，并执行如下指令，创建用户并授权：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">'xiaoming'</span><span class="token variable">@'%'</span> identified <span class="token keyword">by</span> <span class="token string">'Root@123456'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>&#x3D;&#x3D;注：上面SQL的作用是创建一个用户 xiaoming ，密码为 Root@123456 ，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。&#x3D;&#x3D;</strong></p>
<blockquote>
<p>MySQL密码复杂程度说明: </p>
<p>​    <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k6qbwrj20ei03ejrt.jpg" alt="image-20210825144818269"> </p>
<p>​    目前mysql5.7默认密码校验策略等级为 MEDIUM , 该等级要求密码组成为: 数字、小写字母、大写字母 、特殊字符、长度至少8位</p>
</blockquote>
<p><strong>4). 登录Mysql数据库，查看master同步状态</strong></p>
<p>执行下面SQL，记录下结果中<strong>File</strong>和<strong>Position</strong>的值</p>
<pre class="line-numbers language-none"><code class="language-none">show master status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k927f8j20xe04fab1.jpg" alt="image-20210825120355600"> </p>
<p><strong>&#x3D;&#x3D;注：上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作&#x3D;&#x3D;</strong></p>
<h3 id="1-3从库配置"><a href="#1-3从库配置" class="headerlink" title="1.3从库配置"></a>1.3从库配置</h3><p><strong>1). 修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong></p>
<pre class="line-numbers language-none"><code class="language-none">server-id&#x3D;200 	#[必须]服务器唯一ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kbw5z0j207p02ajrc.jpg" alt="image-20220220175414871"> </p>
<p><strong>2). 重启Mysql服务</strong></p>
<pre class="line-numbers language-none"><code class="language-none">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>3). 登录Mysql数据库，设置主库地址及同步位置</strong></p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">change master to master_host&#x3D;&#39;8.130.21.14&#39;,master_user&#x3D;&#39;xiaoming&#39;,master_password&#x3D;&#39;Root@123456&#39;,master_log_file&#x3D;&#39;mysql-bin.000001&#39;,master_log_pos&#x3D;441;

start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>参数说明： </p>
<p>​    A. master_host : 主库的IP地址</p>
<p>​    B. master_user : 访问主库进行主从复制的用户名(上面在主库创建的)</p>
<p>​    C. master_password : 访问主库进行主从复制的用户名对应的密码</p>
<p>​    D. master_log_file : 从哪个日志文件开始同步(上述查询master状态中展示的有)</p>
<p>​    E. master_log_pos : 从指定日志文件的哪个位置开始同步(上述查询master状态中展示的有)</p>
</blockquote>
<p><strong>4). 查看从数据库的状态</strong></p>
<pre class="line-numbers language-none"><code class="language-none">show slave status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后通过状态信息中的 Slave_IO_running 和 Slave_SQL_running 可以看出主从同步是否就绪，如果这两个参数全为Yes，表示主从同步已经配置完成。</p>
<p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kjp6sxj210y0ofgrt.jpg" alt="image-20210825142313382"></p>
<blockquote>
<p>MySQL命令行技巧： </p>
<p>​    \G : 在MySQL的sql语句后加上\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行。即将查到的结构旋转90度变成纵向；</p>
</blockquote>
<h2 id="2-读写分离案例"><a href="#2-读写分离案例" class="headerlink" title="2. 读写分离案例"></a>2. 读写分离案例</h2><h3 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h3><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作<strong>，能够有效的避免由数据更新导致的行锁</strong>，使得整个系统的查询性能得到极大的改善。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5klfhcej20tn0b0jsg.jpg" alt="image-20210825145647274"> </p>
<p>通过读写分离,就可以降低单台数据库的访问压力, 提高访问效率，也可以避免单机故障。</p>
<p>主从复制的结构，我们在第一节已经完成了，那么我们在项目中，如何通过java代码来完成读写分离呢，如何在执行select的时候查询从库，而在执行insert、update、delete的时候，操作主库呢？这个时候，我们就需要介绍一个新的技术 ShardingJDBC。</p>
<h3 id="2-2-ShardingJDBC介绍"><a href="#2-2-ShardingJDBC介绍" class="headerlink" title="2.2 ShardingJDBC介绍"></a>2.2 ShardingJDBC介绍</h3><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p>
<p>Sharding-JDBC具有以下几个特点： </p>
<p>1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</p>
<p>2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</p>
<p>3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</p>
<h3 id="2-3-读写分离配置"><a href="#2-3-读写分离配置" class="headerlink" title="2.3 读写分离配置"></a>2.3 读写分离配置</h3><p>1). 在pom.xml中增加shardingJdbc的maven坐标</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.shardingsphere<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>sharding-jdbc-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.0-RC1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2). 在application.yml中增加数据源的配置</p>
<pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">shardingsphere</span><span class="token punctuation">:</span>
    <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
      <span class="token key atrule">names</span><span class="token punctuation">:</span>
        master<span class="token punctuation">,</span>slave
      <span class="token comment"># 主数据源</span>
      <span class="token key atrule">master</span><span class="token punctuation">:</span>
        <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource
        <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
        <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.100.100<span class="token punctuation">:</span>3306/rw<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>
        <span class="token key atrule">username</span><span class="token punctuation">:</span> root
        <span class="token key atrule">password</span><span class="token punctuation">:</span> root
      <span class="token comment"># 从数据源</span>
      <span class="token key atrule">slave</span><span class="token punctuation">:</span>
        <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource
        <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
        <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.100.200<span class="token punctuation">:</span>3306/rw<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>
        <span class="token key atrule">username</span><span class="token punctuation">:</span> root
        <span class="token key atrule">password</span><span class="token punctuation">:</span> root
    <span class="token key atrule">masterslave</span><span class="token punctuation">:</span>
      <span class="token comment"># 读写分离配置</span>
      <span class="token key atrule">load-balance-algorithm-type</span><span class="token punctuation">:</span> round_robin <span class="token comment">#轮询</span>
      <span class="token comment"># 最终的数据源名称</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> dataSource
      <span class="token comment"># 主库数据源名称</span>
      <span class="token key atrule">master-data-source-name</span><span class="token punctuation">:</span> master
      <span class="token comment"># 从库数据源名称列表，多个逗号分隔</span>
      <span class="token key atrule">slave-data-source-names</span><span class="token punctuation">:</span> slave
    <span class="token key atrule">props</span><span class="token punctuation">:</span>
      <span class="token key atrule">sql</span><span class="token punctuation">:</span>
        <span class="token key atrule">show</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#开启SQL显示，默认false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>配置解析: </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kqiiudj21e50de44v.jpg" alt="image-20210825162910711"> </p>
<p>3). 在application.yml中增加配置</p>
<pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  
  <span class="token key atrule">main</span><span class="token punctuation">:</span>
    <span class="token key atrule">allow-bean-definition-overriding</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>该配置项的目的,就是如果当前项目中存在同名的bean,后定义的bean会覆盖先定义的。</p>
<p>spring中(spring.main.allow-bean-definition-overriding) 分析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liubenlong007/article/details/87885567">https://blog.csdn.net/liubenlong007/article/details/87885567</a></p>
<p>&#x3D;&#x3D;如果不配置该项，项目启动之后将会报错：&#x3D;&#x3D; </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kncntaj20tn0b0jsg.jpg" alt="image-20210825163737687"> </p>
<p>报错信息表明，在声明 org.apache.shardingsphere.shardingjdbc.spring.boot 包下的SpringBootConfiguration中的dataSource这个bean时出错, 原因是有一个同名的 dataSource 的bean在com.alibaba.druid.spring.boot.autoconfigure包下的DruidDataSourceAutoConfigure类加载时已经声明了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5koge4cj21e706ydim.jpg" alt="image-20210825164147056"> </p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5krkhptj210y0ofgrt.jpg" alt="image-20210825164227927"> </p>
<p>而我们需要用到的是 shardingjdbc包下的dataSource，所以我们需要配置上述属性，让后加载的覆盖先加载的。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/11/JVM%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">JVM的学习总结</a>
            </div>
            <p class="sub">5月 11 2022</p>
            <div class="post-content">
                
                    <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><ul>
<li>定义</li>
</ul>
<p>​    java 程序运行环境(java二进制字节码的运行环境)</p>
<ul>
<li>好处</li>
</ul>
<p>​    一次编写,到处运行</p>
<p>​    自动内存管理,垃圾回收功能</p>
<p>​    数组下标越界检查</p>
<p>​    多态</p>
<ul>
<li>比较</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5weo104j20mx0dx406.jpg" alt="image-20220511191019291"></p>
<h1 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5whivtvj20qs0e8ta9.jpg" alt="image-20220511192331436"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wj7543j20tl0gqgon.jpg" alt="WechatIMG244"></p>
<h1 id="内存结构之程序计数器-寄存器"><a href="#内存结构之程序计数器-寄存器" class="headerlink" title="内存结构之程序计数器(寄存器)"></a>内存结构之程序计数器(寄存器)</h1><p>作用:</p>
<p>​       记住下一条JVM指令的执行地址</p>
<p>特点:</p>
<p>​      线程私有随着线程创建而创建,随着线程销毁而销毁,每个线程都有自己的程序计数器</p>
<p>​      是一块比较小的内存空间,不会存在内存溢出</p>
<p>实现</p>
<p>​       计数器在物理上是通过寄存器来实现的</p>
<h1 id="内存结构之虚拟机栈"><a href="#内存结构之虚拟机栈" class="headerlink" title="内存结构之虚拟机栈"></a>内存结构之虚拟机栈</h1><p>线程运行时需要的内存空间,称为虚拟机栈</p>
<p>每个栈由多个栈帧(Frame)组成,对应着每次方法调用时所占用的内存</p>
<p>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法,也就是栈的最顶部</p>
<p>栈帧出栈时会释放掉携带的资源</p>
<p>问题辨析:</p>
<p>1.垃圾回收是否涉及栈内存?</p>
<p>​    不需要,因为方法调用产生的栈帧内存会随着方法调用的结束后弹出栈并且自动释放资源,被自动回收</p>
<p>2.栈内存分配越大越好吗?</p>
<p>​    并不是,每个栈内存大小初始值一般都是1024KB,除了windows系统会根据虚拟内存影响内存大小,栈内存越大</p>
<p>线程数越少,线程数少了就会影响执行效率,一般让栈内存扩大只是为了一些方法的递归调用,不容易栈溢出.并不会因为</p>
<p>栈内存越大,执行效率越高,反而会让线程减少,降低执行效率.(一般采用默认大小就可以了)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wmfr7xj20bu0600t2.jpg" alt="image-20220511201653094"></p>
<p>3.方法内的局部变量是否线程安全?</p>
<p>​    首先要看,这个变量是对外共享的,还是对每个线程私有的,比如两个线程同时调用一个方法,方法中的局部变量是static修饰的,那么这个变量是共享的,因为静态变量只加载一次存在于静态区域,线程也就自然不安全,如果这个变量是个普通的局部变量,那么不会有线程安全问题,因为每个线程调用方法时都会生成对应线程的的栈帧.</p>
<p>​      <strong>如果方法内部局部变量没有逃离方法的作用访问,他是线程安全的</strong></p>
<p>​      <strong>如果局部变量引用了对象,并逃离了方法的作用范围,需要考虑线程安全问题</strong></p>
<h1 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h1><p>1.栈帧过多导致栈内存溢出</p>
<p>2.栈帧过大导致栈内存溢出</p>
<h1 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h1><h3 id="案例1-cpu占用过多"><a href="#案例1-cpu占用过多" class="headerlink" title="案例1:cpu占用过多"></a>案例1:cpu占用过多</h3><p>定位</p>
<p>1.用top定位那个进程对cpu的占用过高</p>
<p>2.通过Linux命令查看是哪条线程引起的cup占用过高</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看进程对cup占用情况-------&gt;只能定位进程,不能定位线程
zhangminghao@zhangminghaodeMacBook-Pro ~ % top
PID    COMMAND      %CPU TIME     #TH   #WQ   #PORT MEM    PURG   CMPRS  PGRP
1704   FinalShell            63.3 02:14:05       150      0       1030  1364M       0B     360M   1704
368    WindowServer     35.1 73:51.63        21        5       2665+ 379M-  43M+     57M       368
1687   iTerm2                 30.8 04:04.45 8      5       314     54M    3536K     6608K       1687

#查看线程对cup的占用情况
#H:进程里的线程数
#eo:需要展示的字段
zhangminghao@zhangminghaodeMacBook-Pro ~ %  ps H -eo pid,tid,%cpu | grep 进程id    

#利用jdk提供的工具命令,可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号
zhangminghao@zhangminghaodeMacBook-Pro ~ % jstack 进程id   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>通过进程id的16进制来找出对应的线程,知道了是那个那个程序运行出了问题</strong></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wpm1lsj210b0ipn1g.jpg" alt="image-20220512203716530" style="zoom: 50%;" />

<p><strong>通过信息找到java代码中的行号,检查到cpu占用过高的原因</strong></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wr4cotj20c2076t96.jpg" alt="image-20220512203955346"  />



<h3 id="案例2-运行很长时间没有结果"><a href="#案例2-运行很长时间没有结果" class="headerlink" title="案例2:运行很长时间没有结果"></a>案例2:运行很长时间没有结果</h3><p> 1,通过jstack 进程id命令查看线程执行信息</p>
<p>2.观察最后的输出结果(发现死锁问题)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ws4yldj20t30g9dit.jpg" alt="image-20220512210643175"></p>
<h1 id="本地方法栈Native-Method-Stack"><a href="#本地方法栈Native-Method-Stack" class="headerlink" title="本地方法栈Native Method Stack"></a>本地方法栈Native Method Stack</h1><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>​    本地方法Native Method ,指的是那些不是JAVA代码编写的方法</p>
<h3 id="本地方法的作用"><a href="#本地方法的作用" class="headerlink" title="本地方法的作用"></a>本地方法的作用</h3><p>​    JAVA代码是受限制的,有时候不能直接跟底层操作系统打交道,需要调用一些 用C或者C++编写的本地方法来间接调用执行.</p>
<h1 id="Heap堆"><a href="#Heap堆" class="headerlink" title="Heap堆"></a>Heap堆</h1><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>​    通过new关键字,创建的对象都会使用堆内存,堆内存默认大小是4个G </p>
<h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><p>​    它是线程共享的,堆中对象都需要考虑线程安全问题</p>
<p>​    有垃圾回收机制</p>
<h3 id="堆内存的溢出问题"><a href="#堆内存的溢出问题" class="headerlink" title="堆内存的溢出问题"></a>堆内存的溢出问题</h3><p>​    java.lang.OutofMemoryError:Java heap space</p>
<h1 id="堆内存溢出的原因"><a href="#堆内存溢出的原因" class="headerlink" title="堆内存溢出的原因"></a>堆内存溢出的原因</h1><p>堆内存不是有垃圾回收机制吗,为什么还会有内存溢出的问题呢,原因是,堆内存的垃圾回收机制是在对象应用完毕后,才会自动回收,如果一个对象一直被引用,而且内存越来越大,就会导致堆内存溢出问题发发生,如以下代码:    </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>一直在做死循环做添加操作<span class="token punctuation">,</span>且是引用中状态<span class="token punctuation">,</span>导致堆不能垃圾回收
            <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                a <span class="token operator">=</span> a<span class="token operator">+</span>a<span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span>最终输出<span class="token number">26</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
#异常信息
<span class="token class-name">Exception</span> in thread <span class="token string">"main"</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> heap space
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">3332</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>AbstractStringBuilder</span><span class="token punctuation">.</span><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token class-name">AbstractStringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">124</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>AbstractStringBuilder</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">AbstractStringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">448</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>StringBuilder</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">136</span><span class="token punctuation">)</span>
	at <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span>Test</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>堆内存默认为4G,通过设置堆内存空间为8m,发现在i值到达17的时候就内存溢出了,所以可以通过这种方式,尽早的暴露出内存溢出的问题:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wvth3wj218o0u0tej.jpg" alt="image-20220513203904487"></p>
<h1 id="堆的内存诊断jmap"><a href="#堆的内存诊断jmap" class="headerlink" title="堆的内存诊断jmap"></a>堆的内存诊断jmap</h1><h3 id="1-jps工具"><a href="#1-jps工具" class="headerlink" title="1.jps工具:"></a>1.jps工具:</h3><p>​    是 java 提供的一个用来显示当前所有 java 进程的 pid 的命令,可以查看当前系统中有那些JAVA进程</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">zhangminghao<span class="token annotation punctuation">@localhost</span> java<span class="token operator">-</span><span class="token class-name">Spring</span> <span class="token operator">%</span> jps 
<span class="token number">1488</span> 
<span class="token number">1956</span> <span class="token class-name">Jps</span>
<span class="token number">1684</span> <span class="token class-name">Launcher</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-jmap工具"><a href="#2-jmap工具" class="headerlink" title="2.jmap工具"></a>2.jmap工具</h3><p>​        jmap（Java Virtual Machine Memory Map）是JDK提供的一个可以生成Java虚拟机的堆转储快照dump文件的命令行工具。除此以外，jmap命令还可以查看finalize执行队列、Java堆和方法区的详细信息，比如空间使用率、当前使用的什么垃圾回收器、分代情况等等</p>
<p>​     查看堆内存占用情况heao进程id——&gt;&gt;jmap -heap 进程id</p>
<h3 id="3-jconsole工具"><a href="#3-jconsole工具" class="headerlink" title="3,jconsole工具"></a>3,jconsole工具</h3><p>​     图形界面的,多功能的检测工具,可以连续检测</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">zhangminghao<span class="token annotation punctuation">@localhost</span> java<span class="token operator">-</span><span class="token class-name">Spring</span> <span class="token operator">%</span> jconsole<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ww8dmgj20qf0713zs.jpg" alt="image-20220513210926906"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/10/Mysql%E7%B4%A2%E5%BC%95-%E6%A0%B8%E5%BF%83/">Mysql索引(核心)</a>
            </div>
            <p class="sub">5月 10 2022</p>
            <div class="post-content">
                
                    <h1 id="索引的概述"><a href="#索引的概述" class="headerlink" title="索引的概述"></a>索引的概述</h1><p>索引是帮助Mysql高效获取数据的一个有序的数据结构</p>
<p>优缺点</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tqtt6gj20r504ajru.jpg" alt="image-20220510102517966" style="zoom:150%;" />

<h1 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h1><p>Mysql的索引是在存储引擎实层实现的,不同的存储索引有不同的结构,主要包括以下几种</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5trrd5nj20r907gdgr.jpg" alt="image-20220510102752768"></p>
<p>不同存储引擎支持的索引结构</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ts6jk2j20r407j3yx.jpg" alt="image-20220510102843612"></p>
<p><strong>平常所说的索引,如果没有特别指明,都是值B+树结构组织的索引</strong></p>
<h1 id="各个数据结构的优缺点"><a href="#各个数据结构的优缺点" class="headerlink" title="各个数据结构的优缺点"></a>各个数据结构的优缺点</h1><ul>
<li>二叉树和红黑树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tu4tlzj20rz0cg3zr.jpg" alt="image-20220510103435512"></p>
<ul>
<li>B树(多路平衡查找树)</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txaoxkj20tc0cg3zw.jpg" alt="image-20220510103600779"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txsdvfj20ry0c575o.jpg" alt="image-20220510104003733"><strong>B-Tree(B树)总结:①指针比key多一个②当key等于最大度数时(违背x阶时)中间元素向上分类</strong></p>
<ul>
<li>B+树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tz7djwj20ri08ydgp.jpg" alt="image-20220510104651047"></p>
<p><strong>B+Tree数相对于B-Tree区别:</strong></p>
<p><strong>①:所有数据都会出现在叶子节点</strong></p>
<p><strong>②:叶子节点行程一个单项链表的结构</strong></p>
<ul>
<li>Hash</li>
</ul>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u4lqq4j20sc0cedht.jpg" alt="image-20220510105739506"></p>
<p>  索引特点:</p>
<p>  1.Hash索引只能用于对等比较(&#x3D;,in),不支持范围查询(between,&gt;,&lt;,…),因为存储顺序不一致</p>
<p>  2.无法利用索引完成排序操作</p>
<p>  3.查询效率高,通常只需要一次检索就可以了,效率通常要高于B+Tree树(这里的通常指的是,没有哈希碰撞的前提下)</p>
<p>​    存储引擎支持:</p>
<p>​    在Mysql中,支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能,hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的.</p>
<h1 id="Mysql中的B-树索引"><a href="#Mysql中的B-树索引" class="headerlink" title="Mysql中的B+树索引"></a>Mysql中的B+树索引</h1><p>Mysql索引数据结构对经典的B+Tree进行了优化,在原B+Tree的基础上,增加了一个指向相邻叶子节点的链表指针,就形成了带有顺序指针的B+Tree,提高区间访问的性能**(就是叶子节点的单向链表变成了双向链表)**</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u5j8fhj20rj09075i.jpg" alt="image-20220510105526048"></p>
<h1 id="为什么InnoDB存储引擎选择使用B-Tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-Tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+Tree索引结构"></a>为什么InnoDB存储引擎选择使用B+Tree索引结构</h1><p>①相对于二叉树,层级更少,搜索效率更高</p>
<p>②对于B-Tree,无论是叶子节点还是非叶子节点,都会保存数据,这样导致一页(磁盘块,一个节点一个磁盘块,16kb)中存储的键值减少,指针跟着减少,要同样保存大量数据,只能增加树的高度,导致性能降低(B+Tree只有叶子节点才会存储行数据,其他节点只起到了索引的作用,除了叶子节点,其他的页只存放key和索引,因为不存储数据,所以可以存放更多的索引和key,也就可以降低树的高度,层级变小,从而增加查询效率)<strong>而且在mysql中对b+树索引进行了优化,对叶子节点的单项链表变成了双向链表,便于范围搜索和排序</strong></p>
<p>③相对于Hash索引(只能进行等值匹配),B+Tree支持范围匹配及排序操作</p>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u92miej20r3077t9f.jpg" alt="image-20220510113432105"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u9yambj20rd0ac75g.jpg" alt="image-20220510112749285"></p>
<p><strong>就会隐式的定义一个 rowid 作为聚集索引</strong></p>
<h1 id="InnoDB—-gt-回表查询"><a href="#InnoDB—-gt-回表查询" class="headerlink" title="InnoDB—-&gt;回表查询"></a>InnoDB—-&gt;回表查询</h1><p>如果想要执行类似于:selecy*from where name &#x3D; ‘Arm’ 这种sql语句,那么mysql先回根据二级索引找到对应的主键,或者带有唯一约束的值,然后通过主键或者唯一约束的值来通过聚集索引来查询对应row(行数据)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uc5k8yj20xs0h80uo.jpg" alt="image-20220510115518828"></p>
<h1 id="InnoDB主键索引的B-Tree高度为多高呢"><a href="#InnoDB主键索引的B-Tree高度为多高呢" class="headerlink" title="InnoDB主键索引的B+Tree高度为多高呢?"></a>InnoDB主键索引的B+Tree高度为多高呢?</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5udhri1j20jl0hidhd.jpg" alt="image-20220510123359487"></p>
<p><strong>可以得出,用innodb来存储2000多万条数据,树也只有三层,大大的提高了检索效率!</strong></p>
<h1 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h1><ul>
<li><p>创建索引:<strong>构建B+Tree的数据结构,构建一次,一劳永逸,空间换时间</strong></p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">* create index idx_user_name on tb_user(name);
* create unique index idx_user_phone on tb_user(phone);
* create index idx_user_pro_age_sta on tb_user(profession,age,status); ---&gt; 创建联合索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查看索引:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">show index from tb_user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>删除索引:</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">drop index idx_user_phone on tb_user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>SQL语句的优化一般优化的是查询语句,在优化查询语句中索引占主导地位</strong></p>
</li>
</ul>
<h1 id="sql优化性能分析"><a href="#sql优化性能分析" class="headerlink" title="sql优化性能分析"></a>sql优化性能分析</h1><ul>
<li><p>SQL的执行频率</p>
<blockquote>
<p>Mysql客户端链接成功后,通过Show[session|global] status 命令可以提供服务器状态信息,通过如下命令,可以查看当前数据库的insert,update,delete,select的访问频次</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">SHOW GLOBAL STATUS LIKE 'COM_______' <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span><span class="token number">7</span>个下划线代表<span class="token number">7</span>个字符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uhipaej20e109qmxx.jpg" alt="image-20220510125834554"></p>
</blockquote>
</li>
</ul>
<p><strong>如果我们使用执行频率查看到当前数据库select查询的执行频次占据绝大部分,我们就需要对当前数据库来进行优化</strong></p>
<ul>
<li><p>慢查询日志</p>
</li>
<li><blockquote>
<p>  慢查询日志记录了所有执行时间超过指定参数(long_query_time,单位:妙,默认10妙)的所有sql语句的日志,我们可以通过查询慢查询日志,来定位执行效率比较低的语句,来做对应的优化处理.</p>
<p>  Mysql的慢查询日志默认没有开启,需要在Mysql的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询慢查询日志是否开启
mysql&gt; show variables like &#39;slow_query_log&#39;;
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |  -------&gt;可以看到默认开关是关闭的
+----------------+-------+
1 row in set (0.01 sec)

#可以在&#x2F;etc&#x2F;my.cnf中配置一下信息
#开启Mysql慢查询日志开关
slow_query_log&#x3D;1
#设置慢查询日志的时间为2妙,sql语执行时间超过2秒,就会视为慢查询,记录慢查询日志
long_query_time&#x3D;2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>配置完毕后,可以通过一下命令重启Mysql服务器进行测试,查询慢日志文件中记录的信息&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-show.log</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#重启mysql服务
  systemctl restart mysqld;
 #进入mysql继续用命令查看当前慢日志开关
mysql&gt; show variables like &#39;slow_query_log&#39;;
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | ON    | -------&gt;可以看到开关从OFF变成了ON,表示已经开启慢查询日志
+----------------+-------+
1 row in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>当慢查询日志开启后,慢查询日志的位置在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;的目录下,文件名教localhost-slow.log</strong></p>
<p><strong>注意:但是只用慢查询日志的话,只能锁定一些自己定义的慢查询时间(设定的预设时间),来查到查询慢的sql语句,比较笼统,如果有的sql语句在1.98s或者1.99s其实也是属于慢查询,但是因为配置的原因并不会记录到慢查询日志中去,所以这个时候就要用到profiling工具来辅助sql调优</strong></p>
</blockquote>
</li>
<li><p>Profile详情</p>
<blockquote>
<p>show profiles 能够在做SQL优化的时候帮助我们了解时间都耗费到哪里去了.通过have_profiling参数,能够看到Mysql是否支持</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#profile操作
mysql&gt; SELECT @@have_profiling;
+------------------+
| @@have_profiling |
+------------------+
| YES              |    ---------&gt;可以看到当前数据库支持profile
+------------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>支持是支持,但是还要检查一下profiling是否是开启状态,<strong>默认是关闭的</strong>,可以通过session&#x2F;global级别开启profiling:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看是否开启了profiling开关
mysql&gt; select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |     ------&gt;可以看到默认是关闭的
+-------------+
1 row in set, 1 warning (0.00 sec)

#设置profiling的开关
mysql&gt; set profiling &#x3D; 1;   ---------&gt;设置开关为1,就是打开
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           1 |     ---------------&gt;再次查看发现,profiling开关已经被开启了
+-------------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 这个时候就可以通过一下语句来查询,每个查询的sql语句的详细执行情况了</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看每一条sql的耗时的基本情况
mysql&gt; show profiles;   
+----------+------------+--------------------+
| Query_ID | Duration   | Query              |
+----------+------------+--------------------+
|        1 | 0.00013000 | select @@profiling |
|        2 | 0.00011800 | SELECT DATABASE()  |
|        3 | 0.00166125 | show databases     |
|        4 | 0.00015150 | show tables        |
|        5 | 0.00024825 | show tables        |
|        6 | 0.00024200 | select * from user |
|        7 | 0.00013325 | select * from DISH |
|        8 | 0.00027600 | select * from dish |
+----------+------------+--------------------+
8 rows in set, 1 warning (0.00 sec)

#查看指定的query_id的SQL语句各个阶段的耗时情况
 mysql&gt; show profile for query 3;   -------&gt;根据从show profiles中查询的基本情况的query_id来查看该语句各个阶段的耗时详情
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000031 |
| checking permissions | 0.000010 |
| Opening tables       | 0.000028 |
| init                 | 0.000006 |
| System lock          | 0.000004 |
| optimizing           | 0.000003 |
| statistics           | 0.000009 |
| preparing            | 0.000007 |
| executing            | 0.001503 |    ----------&gt;可以发现在执行的时候耗时最长
| Sending data         | 0.000019 |
| end                  | 0.000003 |
| query end            | 0.000004 |
| closing tables       | 0.000003 |
| removing tmp table   | 0.000005 |
| closing tables       | 0.000003 |
| freeing items        | 0.000013 |
| cleaning up          | 0.000012 |
+----------------------+----------+
17 rows in set, 1 warning (0.00 sec)
#还可以在show profile for query语句中的profile后面加上cup关键字 ,就可以查询到cup的耗时情况
mysql&gt; show profile cpu  for query 3;
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |   ---------&gt;可以看到比上面的结果多了一个CPU_user的的字段信息
+----------------------+----------+----------+------------+
| starting             | 0.000031 | 0.000013 |   0.000015 |
| checking permissions | 0.000010 | 0.000005 |   0.000005 |
| Opening tables       | 0.000028 | 0.000013 |   0.000015 |
| init                 | 0.000006 | 0.000002 |   0.000003 |
| System lock          | 0.000004 | 0.000002 |   0.000002 |
| optimizing           | 0.000003 | 0.000001 |   0.000002 |
| statistics           | 0.000009 | 0.000005 |   0.000005 |
| preparing            | 0.000007 | 0.000003 |   0.000003 |
| executing            | 0.001503 | 0.000000 |   0.000286 |
| Sending data         | 0.000019 | 0.000000 |   0.000015 |
| end                  | 0.000003 | 0.000000 |   0.000003 |
| query end            | 0.000004 | 0.000000 |   0.000004 |
| closing tables       | 0.000003 | 0.000000 |   0.000003 |
| removing tmp table   | 0.000005 | 0.000000 |   0.000005 |
| closing tables       | 0.000003 | 0.000000 |   0.000003 |
| freeing items        | 0.000013 | 0.000000 |   0.000012 |
| cleaning up          | 0.000012 | 0.000000 |   0.000012 |
+----------------------+----------+----------+------------+
17 rows in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
</li>
<li><p>explain执行计划:</p>
<p>可以模拟 优化器 执行SQL查询语句，并不会去真正的执行这条SQL，从而知道 MySQL 是如何处理你的SQL语句的。可用来分析你的查询语句或是表结构的性能瓶颈。<strong>从而评判sql语句的执行性能</strong></p>
<blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#使用explain模拟优化器
mysql&gt; explain select * from dish; 
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | dish  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   26 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>expalin执行计划各个字段的含义:</p>
<p><strong>id:</strong></p>
<p>select查询的序列号,表示查询中执行select子句或者是操作表的顺序(id相同,执行顺序从上到下:id不同,值越大,越先执行)</p>
<p><strong>select_type:</strong></p>
<p>表示SELECT的类型,常见的取值有SIMPLE(简单表,即不实用表连接或者子查询),PRIMARY(主查询),PRIMARY(主查询,即外层的查询),UNION(UNION中搞得第二个或者后面的查询语句),SUBQUERY(SELECT&#x2F;WHERE之后包含了子查询)等</p>
<p><strong>type:</strong></p>
<p>表示连接类型,性能由好到差的连接类型为NULL,system,const,eq_ref,ref,range,index,all.</p>
<p><strong>possible_key:</strong></p>
<p>显示可能应用在这张表上的索引,一个或者多个</p>
<p><strong>key</strong></p>
<p>实际使用的索引,如果为null,则没有使用索引.</p>
<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数,该值为索引字段最大可能长度,并非实际使用长度,在不损失精确性的前提下,长度越长越好.</p>
<p><strong>rows</strong></p>
<p>MYSQL认为必须要执行查询的行数,在Innodb引擎的表中,是一个估计值,可能并不总是准确的.</p>
<p><strong>filtered</strong></p>
<p>表示返回结果的行数占需读取行数的百分比,filtered的值越大越好</p>
<p><strong>Extra</strong></p>
<p>该语句没有查询出来的字段,会在额外字段中展示</p>
<p>using index condition  回表查询</p>
<p>using index 索引覆盖</p>
<p>using where 全表扫描</p>
<p>需重点关注以下字段信息:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uo0um1j20uv046t9s.jpg" alt="image-20220510144105150"></p>
</blockquote>
</li>
</ul>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ul>
<li><p>验证索引效率</p>
<p>在不用默认主键的聚合索引通过普通字段查询数据时,1000万条数据需要耗时20多s</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uq1th2j21420a6ad4.jpg" alt="image-20220510145621792"></p>
</li>
</ul>
<p>​    这个时候我们针对刚刚的字段来创建对应的索引,构造该字段的B+Tree索引数据结构(为1000万条的数据构造数据结构是非常耗时的经过1min11s的时间终于构建成功)</p>
<p>​        <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uqwe9ej20b201ut8q.jpg" alt="image-20220510145924020"></p>
<p>此时查询一下当前表的索引,发现刚刚创建的索引已经构建成功<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ut08o0j212p088abo.jpg" alt="image-20220510150140764"></p>
<p>这个时候我们再次查询一下刚刚的sql语句</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uvpvx4j20er0bgq41.jpg" alt="image-20220510150423765"></p>
<p><strong>可以看到再次执行时,只用了0.01s的时间,这就是索引对于查询效率的提升</strong></p>
<h1 id="无效索引"><a href="#无效索引" class="headerlink" title="无效索引"></a>无效索引</h1><ul>
<li>没有遵守最左前缀法则</li>
</ul>
<p>如果索引了多列(联合索引),要遵守最左前缀法则.最左前缀法则指的是查询从索引的最左列开始,并且不跳过索引中的列,如果跳跃某一列,索引将部分失效(后面的字段索引失效) —-&gt;必须包含最左边的列,不然会失效,导致全表扫描</p>
<ul>
<li>范围查询</li>
</ul>
<p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引会失效(<strong>但是&lt;&#x3D;,&gt;&#x3D;索引会生效</strong>)</p>
<ul>
<li>索引列运算</li>
</ul>
<p>不要在索引列上进行运算操作,索引将失效</p>
<ul>
<li>字符串不加引号</li>
</ul>
<p>字符串类型字段使用时,不加引号,会发生隐式转换,索引将失效</p>
<ul>
<li>模糊查询</li>
</ul>
<p>如果仅仅是尾部模糊匹配,索引不会失效.如果是头部模糊匹配,索引失效.(例如: ‘xx%’可以  ‘%xx’不可以)</p>
<ul>
<li>or连接条件</li>
</ul>
<p>用or分割开的条件,如果or前的条件中的列有索引,而后面的列没有索引,那么涉及的索引都不会被用到,索引失效(只有两侧都有索引的时候,索引才会剩生效)—–&gt;解决方法,只需要在没有索引的一方建立索引即可 </p>
<h1 id="select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题"><a href="#select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题" class="headerlink" title="select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?"></a>select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?</h1><p><strong>有个问题,select * 的时候用 or 且满足左右两边都是索引的情况下按道理来说可以用到索引但是如果是联合索引,则不会走索引查询,而是全表扫描,如果是两边都是单个索引就会合并索引走二级索引+回表查询,如果所有字段都有索引,那么就会索引覆盖,直接走二级索引,符合索引覆盖</strong></p>
<ul>
<li><strong>数据分布影响</strong> —–重点</li>
</ul>
<p>如果MYSQL评估使用索引比全表更慢,则不使用索引.(比如查询一个比最小数据大的所有数据,因此本来就是要走全表扫描的,索引还不如直接走全表扫描来的快,也就不会走索引)</p>
<ul>
<li><strong>关于字段是否有null</strong> —重点</li>
</ul>
<p><strong>在where后面进行null值判断,导致索引失效的原因并不是null本身,而是mysql根据数据分布来自动判断是否用索引,比如一个字段里绝大多数都是null,这个时候你查询字段里为null的值,mysql会认为全表扫描比索引来的更快,所以不会使用索引,如果一个字段里的null是极少数的,那么当你查询字段里为null的值的数据的时候,mysql会判断全表扫描的性能要低于索引查询,这个时候就会使用索引!</strong></p>
<p>因为在判断时候,联合索引必须要有最左前缀,如果用or,就不能保证有最左前缀,所以直接全表扫描!</p>
<h1 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h1><p>SQL提示,是优化数据库的一个重要手段,简单来说,就是在SQL语句中加入一些认为的提示来达到优化操作的目的.</p>
<p>当单列索引存在与联合索引中的时候,Mysql会自动选择一个效率高的索引,如果想要使用其他索引的话,那就需要在sql语句中指定要用的索引,sql语句如下:</p>
<p><strong>use index(索引名)—–&gt;建议(MySQL不一定执行,会自动判断)</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#默认情况下
mysql&gt; explain select * from dish where name &#x3D; &#39;梅菜扣肉&#39;;
+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys                          | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name,idx_dish_name_price_code | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

#给mysql建议使用索引情况下----&gt;mysql会自动判断,如果建议的索引效率低,则不会执行建议的索引
mysql&gt; explain select * from dish use   index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>ignore index(索引名)——&gt;表示忽略某个索引,也就是不用的索引</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#忽略联合索引索引,会执行另外的索引
mysql&gt; explain select * from dish ignore  index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;
+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>force index(索引名)——&gt;强制Mysql执行某个索引</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#强制使用联合索引
mysql&gt; explain select * from dish force  index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>尽量使用覆盖索引(查询使用了索引,并且需要返回的列,在索引中已经全部能够找到),减少select * .</p>
<p>覆盖索引的白话:就是要查询的字段都是设置了索引,建议直接覆盖所索引,就不需要回表查询了!</p>
<p>如果要查询的字段中包含没有索引的字段,那么会在二级索引找到有索引字段的值后拿到挂在叶子节点底下的主键值获取者约束唯一字段的值去聚集函数中进行回表查询,如下图所示:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v1fz2cj20wx0f60vb.jpg" alt="image-20220510171143926"></p>
<p>解决方案:就是将没有加入索引的字段也加上索引,实现索引覆盖效果,效率提高,尽量不用select * 不然大概率都会进行回表查询,性能就会下降</p>
<h1 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h1><p>当字段类型为字符串(varcahr,text等)时,有时候需要索引很长的字符串,这会让索引变得很大,查询时,浪费大量的磁盘IO,影响查询效率.此时可以只将字符串的一部分前缀,建立索引,这样可以大大节约索引空间,从而提高索引效率</p>
<p>语法:</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#创建前缀索引
create index idx_xxxx on table_name(colum(n));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>前缀长度:<br>可以根据索引的有选择性来决定,而选择性是指不重复的索引值(基数)和数据表的记录总数的比值,索引选择性越高则查询效率越高,唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的. </p>
<pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#查询email中不为空的数据
select count( email)&#x2F;count(*) from tb_user;
#查询email中不重复的数据
select count(distinct email) from tb_user;
#查询emai中不重复数据的选择性 &#x2F;不重复数据&#x2F;总条目数
select count(distinct email)&#x2F;count(*) from tb_user;
#查询emai中不重复数据的选择性 &#x2F;不重复数据&#x2F;总条目数的前5个字符(降低索引的体积)
select count(distinct substring(email,1,5))&#x2F;count(*) from tb_user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v3t7zuj20xu0fjwh6.jpg" alt="image-20220510212318350"></p>
<h1 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v95x4hj20wb0e4dij.jpg" alt="image-20220510220527020"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v9t2zpj20xb0f2q50.jpg" alt="image-20220510220551724"></p>
<h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>1.针对数据量大,且查询比较频繁的表建立索引</p>
<p>2.针对常作为查询条件(where),排序(order by),分组(group by)操作的字段建立索引</p>
<p>3.尽量选择区分度高的列作为索引,尽量建立唯一索引,区分度越高,使用的效率就越高.</p>
<p>4.如果是字符串类型的字段,字段的长度较长,可以针对于字段的特点,建立前缀索引</p>
<p>5.尽量使用联合索引,减少单例索引,查询时,联合索引很多时候可以覆盖索引,节省存储空间,避免回表,提高查询效率.</p>
<p>6.要控制索引的数量,索引并不是多多益善,索引越多,维护索引结构的代价就越大,会影响增删改的效率</p>
<p>7.如果索引列不能存储NULL值,请再创建表使用NOT NULL约束它.当优化器知道每列是否包含NULL值时,可以更好的确定那个索引最有效的用于查询.</p>
<h1 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h1><p>1.索引概述</p>
<blockquote>
<p>索引是高效获取数据的数据结构,它是有序的</p>
</blockquote>
<p>2.索引结构</p>
<blockquote>
<p>B+Tree:所有的数据都会出现在叶子节点,而且叶子节点形成了一个双向链表</p>
<p>Hash:检索性能高,直接算出哈希值定位到检索数据,如果存在哈希碰撞,则会形成链表,在寻着链表找对应的值,检索性能比较高,但是缺点就是只能进行等值(精确)匹配,不支持范围查询,和索引的排序—-&gt;(memory引擎使用)</p>
</blockquote>
<p>3.索引分类</p>
<blockquote>
<p>主键索引,唯一索引,常规索引,全文索引</p>
<p>在innodb引擎中,根据索引的存储结构分为两类:聚集索引,二级索引</p>
<p>聚集索引:必须存在,且只能有一个,最大特点就是这个B+Tree叶子节点的数据是这一行的数据,默认主键索引就是聚集索引,没有主键会选择第一个唯一索引作为聚集索引</p>
<p>二级索引:B+Tree叶子节点的底下挂的是主键</p>
</blockquote>
<p>4.索引语法</p>
<blockquote>
<p>create [unique] index xxx on xxx(xxx);</p>
<p>Show index from xxxx;</p>
<p>Drop index xxx on xxx;</p>
</blockquote>
<p>5.SQL性能分析</p>
<blockquote>
<p>执行频次,慢查询日志,profile,explain</p>
</blockquote>
<p>6.索引使用</p>
<blockquote>
<p> 联合索引:必须严格遵守最左前缀法则</p>
<p>索引失效</p>
<p>SQL提示</p>
<p>覆盖索引</p>
<p>前缀索引</p>
<p>单例&#x2F;联合索引</p>
</blockquote>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/10/Mysql%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/">Mysql存储引擎</a>
            </div>
            <p class="sub">5月 10 2022</p>
            <div class="post-content">
                
                    <h1 id="MYSQL体系结构-连接层"><a href="#MYSQL体系结构-连接层" class="headerlink" title="MYSQL体系结构:连接层"></a>MYSQL体系结构:连接层</h1><p>最上层是一些客户端的链接服务,主要完成一些类似于链接处理,授权认证,及相关的安全方案.服务器也会安全接入的每个客户端验证它所具有的操作权限</p>
<h1 id="MYSQL体系结构-服务层"><a href="#MYSQL体系结构-服务层" class="headerlink" title="MYSQL体系结构:服务层"></a>MYSQL体系结构:服务层</h1><p>第二层架构主要完成大多数的核心服务功能,如SQL接口,并完成缓存查询,Sql的分析和优化,部分内置函数的执行.所有跨存储引擎的功能也是在这一层实现的,如过程,函数等</p>
<h1 id="MYSQL体系结构-引擎层"><a href="#MYSQL体系结构-引擎层" class="headerlink" title="MYSQL体系结构:引擎层"></a>MYSQL体系结构:引擎层</h1><p>存储引擎真正的负责了Mysql中数据的存储和提取,服务器通过API和存储引擎进行通信.不同的存储引擎距有不同的功能,这样我们可以根据自己的需要,来选取核实的存储引擎.存储引擎是可插拔式的</p>
<h1 id="MYSQL体系结构-存储层"><a href="#MYSQL体系结构-存储层" class="headerlink" title="MYSQL体系结构:存储层"></a>MYSQL体系结构:存储层</h1><p>主要是将数据存储在文件系统上,并且完成与存储引擎的交互</p>
<h1 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h1><p>存储引擎就是存储数据,建立索引,更新&#x2F;查询数据等技术的实现方式.</p>
<p>指定存储引擎的语句:ENGINE&#x3D;INNODB &lt;—-可替换</p>
<p>查看当前数据库支持的存储引擎:SHOW ENGINES</p>
<p>没有指定存储引擎时,默认为InnoDB</p>
<p><strong>存储引擎是基于表的么人不是基于库的,所以存储引擎也被称为表类型</strong></p>
<h1 id="InnoDB存储引擎的特点"><a href="#InnoDB存储引擎的特点" class="headerlink" title="InnoDB存储引擎的特点"></a>InnoDB存储引擎的特点</h1><p>InnoDB介绍:</p>
<p>InnoDB是一种兼顾高可靠性的高性能的通用存储引擎,在Mysql5.5之后,InnoDB是默认的MYSQL存储引擎</p>
<p>InnoDB特点:</p>
<p>DML(增删改操作)操作遵循ACID模型,支持事务</p>
<p>行级锁,提高并发访问性能</p>
<p>支持外检Foreign key约束,保证数据的完整性和正确性</p>
<p>InnoDB文件:</p>
<p>xxx.ibd:xxx代表的是表名,innoDB引擎的每张表都会对应这样的一个表空间文件,存储该表的表结构(frm 8.0前  ,sdi 8.0后),数据和索引. 参数:innodb_flie_per_table如果打开,代表 每一张表都代表一个表空间</p>
<h1 id="查看ibd文件"><a href="#查看ibd文件" class="headerlink" title="查看ibd文件"></a>查看ibd文件</h1><p>idb文件是不能直接打开的,里面记录的都是二进制数据,如果非要打开看可以使用cmd输入—–&gt;   ibd2sdi xxx.idb</p>
<h1 id="ibd文件存储结构"><a href="#ibd文件存储结构" class="headerlink" title="ibd文件存储结构"></a>ibd文件存储结构</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq7wjv0rj20pw0ccq4e.jpg" alt="image-20220510095308222"></p>
<h1 id="MyISAM存储引擎的特点"><a href="#MyISAM存储引擎的特点" class="headerlink" title="MyISAM存储引擎的特点"></a>MyISAM存储引擎的特点</h1><p>介绍:</p>
<p>MyISAM是MySQL早期默认的存储引擎</p>
<p>特点:</p>
<p>不支持事务,不支持外键</p>
<p>支持表锁,不支持行锁</p>
<p>访问速度快 </p>
<p>文件:</p>
<p>xxx.sdi:存储表结构信息(存储的json格式数据)</p>
<p>xxx.MYD:存储数据</p>
<p>xxx.MYI:存储索引</p>
<h1 id="Memory存储引擎的特点"><a href="#Memory存储引擎的特点" class="headerlink" title="Memory存储引擎的特点"></a>Memory存储引擎的特点</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq80a7hfj20mg089jrl.jpg" alt=" "></p>
<h1 id="三个存储引擎的区别"><a href="#三个存储引擎的区别" class="headerlink" title="三个存储引擎的区别"></a>三个存储引擎的区别</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq7sxlvrj20ni09eaaq.jpg" alt="image-20220510100124777"></p>

                
            </div>
        </article>
    
</div>
<div class="side-bar">


    <div class="avator" id="avator">
    <div class="title">
        <a href="#" class="text-underline">这是爷</a>
    </div>
        <img src="WechatIMG68.jpeg" class="ava-img">
        <h3 class="author">张鸣昊</h3>
        <div class="icon-list">
        <a href="yourweibo"><i class="iconfont icon-weibo icon-item"></i></a>
        <a href="mailto:youremail"><i class="iconfont icon-email icon-item"></i></a>
        <a href="yourgithub"><i class="iconfont icon-github icon-item"></i></a>
        <a href="yourlinkedin"><i class="iconfont icon-linkedin icon-item"></i></a>
        </div>
    <div class="tags">
    <h3 class="tags-title">Tags</h3>
    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quiet/" rel="tag">Quiet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E9%A2%98/" rel="tag">主题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E4%B8%BB%E9%A2%98/" rel="tag">静态主题</a><span class="tag-list-count">1</span></li></ul>
</div>
    </div>
</div>


</section>

    <nav class="page-nav">
    
    
        <a class="next" href="/page/2/">
            <span class="next-text">下一页</span>
            <i class="iconfont icon-right"></i>
        </a>
    
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Zmhaoo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
