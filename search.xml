<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Feign如何加请求头?</title>
      <link href="/2022/06/09/Feign%E5%A6%82%E4%BD%95%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
      <url>/2022/06/09/Feign%E5%A6%82%E4%BD%95%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>Feign的拦截器RequestInterceptor</p><p>SpringCloud的微服务使用Feign进行服务间调用的时候可以使用RequestInterceptor统一拦截请求来完成设置header等相关请求，但RequestInterceptor和ClientHttpRequestInterceptor有点不同，它拿不到原本的请求，所以要通过其他方法来获取原本的请求</p><p>首先创建自定义的RequestInterceptor</p><p>这里通过RequestContextHolder获取到当前的request</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyFeignInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">RequestInterceptor</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">RequestTemplate</span> template<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ServletRequestAttributes</span> servletRequestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span><span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"===request: &#123;&#125;"</span><span class="token punctuation">,</span> template<span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是Feign接口不是一个启动类,没有办法直接加载配置类,解决方法如下:</p><p>方式一:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"itemservice"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> <span class="token class-name">MyFeignInterceptor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ItemClient</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/item/list"</span><span class="token punctuation">)</span>    <span class="token class-name">PageResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span> <span class="token function">getPageInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"page"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> page<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>编写Feign接口时加上configuration &#x3D; MyFeignInterceptor.class参数</p></blockquote><p>方式二:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h322ppjsosj20dk08gmxa.jpg" alt="image-20220609163003448"></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.hmall.common.feignConfig.MyFeignInterceptor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>在resources下创建META-INF&#x2F;spring.factories实现自定义装配</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis和数据库如何保证数据同步?</title>
      <link href="/2022/06/06/Redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/06/06/Redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2022/06/03/Redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/06/03/Redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><p>本章是基于CentOS7下的Redis集群教程，包括：</p><ul><li>单机安装Redis</li><li>Redis主从</li><li>Redis分片集群</li></ul><h1 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1.单机安装Redis"></a>1.单机安装Redis</h1><h2 id="Linux版安装"><a href="#Linux版安装" class="headerlink" title="Linux版安装"></a>Linux版安装</h2><p>首先需要安装Redis所需要的依赖：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install -y gcc tcl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="/assets/image-20210629114325516.png" alt="image-20210629114325516"></p><p>例如，我放到了&#x2F;tmp目录：</p><p><img src="/assets/image-20210629114830642.png" alt="image-20210629114830642"></p><p>解压缩：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xvf redis-6.2.4.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压后：</p><p><img src="/assets/image-20210629114941810.png" alt="image-20210629114941810"></p><p>进入redis目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cd redis-6.2.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行编译命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出错，应该就安装成功了。</p><p>然后修改redis.conf文件中的一些配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问</span><span class="token attr-name">bind</span> <span class="token attr-value">0.0.0.0</span><span class="token comment"># 数据库数量，设置为1</span><span class="token attr-name">databases</span> <span class="token attr-value">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动Redis：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止redis服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-Redis主从集群"><a href="#2-Redis主从集群" class="headerlink" title="2.Redis主从集群"></a>2.Redis主从集群</h1><h2 id="2-1-集群结构"><a href="#2-1-集群结构" class="headerlink" title="2.1.集群结构"></a>2.1.集群结构</h2><p>我们搭建的主从集群结构如图：</p><p><img src="/assets/image-20210630111505799.png" alt="image-20210630111505799"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.150.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7002</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7003</td><td align="center">slave</td></tr></tbody></table><h2 id="2-2-准备实例和配置"><a href="#2-2-准备实例和配置" class="headerlink" title="2.2.准备实例和配置"></a>2.2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 创建目录mkdir 7001 7002 7003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如图：</p><p><img src="/assets/image-20210630113929868.png" alt="image-20210630113929868"></p><p>2）恢复原始配置</p><p>修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 开启RDB</span><span class="token comment"># save ""</span><span class="token attr-name">save</span> <span class="token attr-value">3600 1</span><span class="token attr-name">save</span> <span class="token attr-value">300 100</span><span class="token attr-name">save</span> <span class="token attr-value">60 10000</span><span class="token comment"># 关闭AOF</span><span class="token attr-name">appendonly</span> <span class="token attr-value">no</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-6.2.4&#x2F;redis.conf文件拷贝到三个目录中（在&#x2F;tmp目录执行下列命令）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 方式一：逐个拷贝cp redis-6.2.4&#x2F;redis.conf 7001cp redis-6.2.4&#x2F;redis.conf 7002cp redis-6.2.4&#x2F;redis.conf 7003# 方式二：管道组合命令，一键拷贝echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4）修改每个实例的端口、工作目录</p><p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在&#x2F;tmp目录执行下列命令）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sed -i -e &#39;s&#x2F;6379&#x2F;7001&#x2F;g&#39; -e &#39;s&#x2F;dir .\&#x2F;&#x2F;dir \&#x2F;tmp\&#x2F;7001\&#x2F;&#x2F;g&#39; 7001&#x2F;redis.confsed -i -e &#39;s&#x2F;6379&#x2F;7002&#x2F;g&#39; -e &#39;s&#x2F;dir .\&#x2F;&#x2F;dir \&#x2F;tmp\&#x2F;7002\&#x2F;&#x2F;g&#39; 7002&#x2F;redis.confsed -i -e &#39;s&#x2F;6379&#x2F;7003&#x2F;g&#39; -e &#39;s&#x2F;dir .\&#x2F;&#x2F;dir \&#x2F;tmp\&#x2F;7003\&#x2F;&#x2F;g&#39; 7003&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># redis实例的声明 IP</span><span class="token attr-name">replica-announce-ip</span> <span class="token attr-value">192.168.200.137</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每个目录都要改，我们一键完成修改（在&#x2F;tmp目录执行下列命令）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 逐一执行sed -i &#39;1a replica-announce-ip 192.168.200.137&#39; 7001&#x2F;redis.confsed -i &#39;1a replica-announce-ip 192.168.200.137&#39; 7002&#x2F;redis.confsed -i &#39;1a replica-announce-ip 192.168.200.137&#39; 7003&#x2F;redis.conf# 或者一键修改printf &#39;%s\n&#39; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#39;1a replica-announce-ip 192.168.200.137&#39; &#123;&#125;&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3.启动"></a>2.3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 第1个redis-server 7001&#x2F;redis.conf# 第2个redis-server 7002&#x2F;redis.conf# 第3个redis-server 7003&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动后：</p><p><img src="/assets/image-20210630183914491.png" alt="image-20210630183914491"></p><p>如果要一键停止，可以运行下面命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">printf &#39;%s\n&#39; 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-4-开启主从关系"><a href="#2-4-开启主从关系" class="headerlink" title="2.4.开启主从关系"></a>2.4.开启主从关系</h2><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">slaveof &lt;masterip&gt; &lt;masterport&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong><font color='red'>注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>这里我们为了演示方便，使用方式二。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 连接 7002redis-cli -p 7002# 执行slaveofslaveof 192.168.150.101 7001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过redis-cli命令连接7003，执行下面命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 连接 7003redis-cli -p 7003# 执行slaveofslaveof 192.168.150.101 7001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后连接 7001节点，查看集群状态：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 连接 7001redis-cli -p 7001# 查看状态info replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="/assets/image-20210630201258802.png" alt="image-20210630201258802"></p><h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5.测试"></a>2.5.测试</h2><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 123</code></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p></li><li><p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p><h1 id="3-搭建哨兵集群"><a href="#3-搭建哨兵集群" class="headerlink" title="3.搭建哨兵集群"></a>3.搭建哨兵集群</h1><h2 id="3-1-集群结构"><a href="#3-1-集群结构" class="headerlink" title="3.1.集群结构"></a>3.1.集群结构</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p><img src="/assets/image-20210701215227018.png" alt="image-20210701215227018"></p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.150.101</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.150.101</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.150.101</td><td align="center">27003</td></tr></tbody></table><h2 id="3-2-准备实例和配置"><a href="#3-2-准备实例和配置" class="headerlink" title="3.2.准备实例和配置"></a>3.2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 创建目录mkdir s1 s2 s3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如图：</p><p><img src="/assets/image-20210701215534714.png" alt="image-20210701215534714"></p><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">port 27001sentinel announce-ip 192.168.200.137sentinel monitor mymaster 192.168.200.137 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir "/tmp/s1"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值</li></ul></li></ul><p>然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 方式一：逐个拷贝cp s1&#x2F;sentinel.conf s2cp s1&#x2F;sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1&#x2F;sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sed -i -e &#39;s&#x2F;27001&#x2F;27002&#x2F;g&#39; -e &#39;s&#x2F;s1&#x2F;s2&#x2F;g&#39; s2&#x2F;sentinel.confsed -i -e &#39;s&#x2F;27001&#x2F;27003&#x2F;g&#39; -e &#39;s&#x2F;s1&#x2F;s3&#x2F;g&#39; s3&#x2F;sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3.启动"></a>3.3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 第1个redis-sentinel s1&#x2F;sentinel.conf# 第2个redis-sentinel s2&#x2F;sentinel.conf# 第3个redis-sentinel s3&#x2F;sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动后：</p><p><img src="/assets/image-20210701220714104.png" alt="image-20210701220714104"></p><h2 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4.测试"></a>3.4.测试</h2><p>尝试让master节点7001宕机，查看sentinel日志：</p><p><img src="/assets/image-20210701222857997.png" alt="image-20210701222857997"></p><p>查看7003的日志：</p><p><img src="/assets/image-20210701223025709.png" alt="image-20210701223025709"></p><p>查看7002的日志：</p><p><img src="/assets/image-20210701223131264.png" alt="image-20210701223131264"></p><h1 id="4-搭建分片集群"><a href="#4-搭建分片集群" class="headerlink" title="4.搭建分片集群"></a>4.搭建分片集群</h1><h2 id="4-1-集群结构"><a href="#4-1-集群结构" class="headerlink" title="4.1.集群结构"></a>4.1.集群结构</h2><p>分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5i3p82j20ee0gjq3n.jpg" alt="image-20210702164116027"></p><p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p><table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.150.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7002</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7003</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8001</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8002</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8003</td><td align="center">slave</td></tr></tbody></table><h2 id="4-2-准备实例和配置"><a href="#4-2-准备实例和配置" class="headerlink" title="4.2.准备实例和配置"></a>4.2.准备实例和配置</h2><p>删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 删除旧的，避免配置干扰rm -rf 7001 7002 7003# 创建目录mkdir 7001 7002 7003 8001 8002 8003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">port 6379<span class="token comment"># 开启集群功能</span>cluster-enabled yes<span class="token comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span>cluster-config-file /tmp/6379/nodes.conf<span class="token comment"># 节点心跳失败的超时时间</span>cluster-node-timeout 5000<span class="token comment"># 持久化文件存放目录</span>dir /tmp/6379<span class="token comment"># 绑定地址</span>bind 0.0.0.0<span class="token comment"># 让redis后台运行</span>daemonize yes<span class="token comment"># 注册的实例ip</span>replica-announce-ip 192.168.200.137<span class="token comment"># 保护模式</span>protected-mode no<span class="token comment"># 数据库数量</span>databases 1<span class="token comment"># 日志</span>logfile /tmp/6379/run.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将这个文件拷贝到每个目录下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 执行拷贝echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 修改配置文件printf &#39;%s\n&#39; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i &#39;s&#x2F;6379&#x2F;&#123;&#125;&#x2F;g&#39; &#123;&#125;&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-启动"><a href="#4-3-启动" class="headerlink" title="4.3.启动"></a>4.3.启动</h2><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入&#x2F;tmp目录cd &#x2F;tmp# 一键启动所有服务printf &#39;%s\n&#39; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过ps查看状态：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ps -ef | grep redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现服务都已经正常启动：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5j8oofj20xz05pgnz.jpg" alt="image-20210702174255799"></p><p>如果要关闭所有进程，可以执行命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ps -ef | grep redis | awk &#39;&#123;print $2&#125;&#39; | xargs kill<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者（推荐这种方式）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">printf &#39;%s\n&#39; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-4-创建集群"><a href="#4-4-创建集群" class="headerlink" title="4.4.创建集群"></a>4.4.创建集群</h2><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p><p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p><p>1）Redis5.0之前</p><p>Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p> <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 安装依赖yum -y install zlib ruby rubygemsgem install redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后通过命令来管理集群：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入redis的src目录cd &#x2F;tmp&#x2F;redis-6.2.4&#x2F;src# 创建集群.&#x2F;redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2）Redis5.0以后</p><p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli --cluster create --cluster-replicas 1 192.168.200.137:7001 192.168.200.137:7002 192.168.200.137:7003 192.168.200.137:8001 192.168.200.137:8002 192.168.200.137:8003<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令说明：</p><ul><li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul><p>运行后的样子：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5lqnkaj217b0jqgul.jpg" alt="image-20210702181101969"></p><p>这里输入yes，则集群开始创建：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5mkum9j20qw0mudnn.jpg" alt="image-20210702181215705"></p><p>通过命令可以查看集群状态：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli -p 7001 cluster nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5pxms7j218504ln0t.jpg" alt="image-20210702181922809"></p><h2 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5.测试"></a>4.5.测试</h2><p>尝试连接7001节点，存储一个数据：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 连接redis-cli -p 7001# 存储数据set num 123# 读取数据get num# 再次存储set a 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果悲剧了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5rblk7j20fm051mxs.jpg" alt="image-20210702182343979"></p><p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli -c -p 7001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这次可以了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uu5sms7qj20k0078jsg.jpg" alt="image-20210702182602145"></p>]]></content>
      
      
      <categories>
          
          <category> Redis相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群分布式缓存</title>
      <link href="/2022/06/03/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2022/06/03/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>– 基于Redis集群解决单机Redis存在的问题</p><p>单机的Redis存在四大问题：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgyhxcgj20w20dcta1.jpg" alt="image-20210725144240631"></p><h1 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1.Redis持久化"></a>1.Redis持久化</h1><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1.RDB持久化"></a>1.1.RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1.执行时机"></a>1.1.1.执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgwz629j20us05dt9f.jpg" alt="image-20210725144536958"></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>查看日志信息：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgwis4zj20l002gq3e.jpg" alt="1647075780141"></p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgv6pc3j20w5034dgc.jpg" alt="image-20210725144725943"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>查看日志信息：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgur5uzj20mp01t74r.jpg" alt="1647075843288"></p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB</span><span class="token attr-name">save</span> <span class="token attr-value">900 1  </span><span class="token attr-name">save</span> <span class="token attr-value">300 10  </span><span class="token attr-name">save</span> <span class="token attr-value">60 10000 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>RDB的其它配置也可以在redis.conf文件中设置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><span class="token attr-name">rdbcompression</span> <span class="token attr-value">yes</span><span class="token comment"># RDB文件名称</span><span class="token attr-name">dbfilename</span> <span class="token attr-value">dump.rdb  </span><span class="token comment"># 文件保存的路径目录</span><span class="token attr-name">dir</span> <span class="token attr-value">./ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2.RDB原理"></a>1.1.2.RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgp5lekj21620f740k.jpg" alt="image-20210725151319695"></p><h3 id="1-1-3-小结"><a href="#1-1-3-小结" class="headerlink" title="1.1.3.小结"></a>1.1.3.小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="1-2-AOF持久化"><a href="#1-2-AOF持久化" class="headerlink" title="1.2.AOF持久化"></a>1.2.AOF持久化</h2><h3 id="1-2-1-AOF原理"><a href="#1-2-1-AOF原理" class="headerlink" title="1.2.1.AOF原理"></a>1.2.1.AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgmojrvj20pi0ccdgk.jpg" alt="image-20210725151543640"></p><h3 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2.AOF配置"></a>1.2.2.AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 是否开启AOF功能，默认是no</span><span class="token attr-name">appendonly</span> <span class="token attr-value">yes</span><span class="token comment"># AOF文件的名称</span><span class="token attr-name">appendfilename</span> <span class="token attr-value">"appendonly.aof"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 表示每执行一次写命令，立即记录到AOF文件</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">always </span><span class="token comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">everysec </span><span class="token comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">no</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种策略对比：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvglbs7tj20s004o0tj.jpg" alt="image-20210725151654046"></p><h3 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3.AOF文件重写"></a>1.2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgkfc1cj20qy03q0su.jpg" alt="image-20210725151729118"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><span class="token attr-name">auto-aof-rewrite-percentage</span> <span class="token attr-value">100</span><span class="token comment"># AOF文件体积最小多大以上才触发重写 </span><span class="token attr-name">auto-aof-rewrite-min-size</span> <span class="token attr-value">64mb </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3.RDB与AOF对比"></a>1.3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgjem1dj20xa0c3ac8.jpg" alt="image-20210725151940515"></p><h1 id="2-Redis主从"><a href="#2-Redis主从" class="headerlink" title="2.Redis主从"></a>2.Redis主从</h1><h2 id="2-1-搭建主从架构"><a href="#2-1-搭建主从架构" class="headerlink" title="2.1.搭建主从架构"></a>2.1.搭建主从架构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgi3btwj21010gsmya.jpg" alt="image-20210725152037611"></p><p>具体搭建流程参考课前资料《Redis集群.md》：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgh5g5sj205e061745.jpg" alt="image-20210725152052501"> </p><h2 id="2-2-主从数据同步原理"><a href="#2-2-主从数据同步原理" class="headerlink" title="2.2.主从数据同步原理"></a>2.2.主从数据同步原理</h2><h3 id="2-2-1-全量同步"><a href="#2-2-1-全量同步" class="headerlink" title="2.2.1.全量同步"></a>2.2.1.全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgfulv7j20y70j3768.jpg" alt="image-20210725152222497"></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgdcjixj20yf0i1q4x.jpg" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h3 id="2-2-2-增量同步"><a href="#2-2-2-增量同步" class="headerlink" title="2.2.2.增量同步"></a>2.2.2.增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgcgxhpj20xm0dkab9.jpg" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="2-2-3-repl-backlog原理"><a href="#2-2-3-repl-backlog原理" class="headerlink" title="2.2.3.repl_backlog原理"></a>2.2.3.repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvgb244bj206a06rdfs.jpg" alt="image-20210725153359022"> </p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvga1j0sj206n070glm.jpg" alt="image-20210725153524190"> </p><p>直到数组被填满：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvg8l7jij206m07dt8q.jpg" alt="image-20210725153715910"> </p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvg4z9tcj205m06x74b.jpg" alt="image-20210725153937031"> </p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvg6q8o8j2062071q30.jpg" alt="image-20210725154155984"> </p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvg26frpj211i03q751.jpg" alt="image-20210725154216392"></p><h2 id="2-3-主从同步优化"><a href="#2-3-主从同步优化" class="headerlink" title="2.3.主从同步优化"></a>2.3.主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p>主从从架构图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvg0bbiyj210c0bgabh.jpg" alt="image-20210725154405899"></p><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4.小结"></a>2.4.小结</h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><h1 id="3-Redis哨兵"><a href="#3-Redis哨兵" class="headerlink" title="3.Redis哨兵"></a>3.Redis哨兵</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h2 id="3-1-哨兵原理"><a href="#3-1-哨兵原理" class="headerlink" title="3.1.哨兵原理"></a>3.1.哨兵原理</h2><h3 id="3-1-1-集群结构和作用"><a href="#3-1-1-集群结构和作用" class="headerlink" title="3.1.1.集群结构和作用"></a>3.1.1.集群结构和作用</h3><p>哨兵的结构如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfyx4cbj20ms0h50uf.jpg" alt="image-20210725154528072"></p><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h3 id="3-1-2-集群监控原理"><a href="#3-1-2-集群监控原理" class="headerlink" title="3.1.2.集群监控原理"></a>3.1.2.集群监控原理</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfxh8ysj20ic0bddh1.jpg" alt="image-20210725154632354"></p><h3 id="3-1-3-集群故障恢复原理"><a href="#3-1-3-集群故障恢复原理" class="headerlink" title="3.1.3.集群故障恢复原理"></a>3.1.3.集群故障恢复原理</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfw2rpbj20na0ghabc.jpg" alt="image-20210725154816841"></p><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h2 id="3-2-搭建哨兵集群"><a href="#3-2-搭建哨兵集群" class="headerlink" title="3.2.搭建哨兵集群"></a>3.2.搭建哨兵集群</h2><p>具体搭建流程参考课前资料《Redis集群.md》：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvftm32oj205e061745.jpg" alt="image-20210725155019276"> </p><h2 id="3-3-RedisTemplate"><a href="#3-3-RedisTemplate" class="headerlink" title="3.3.RedisTemplate"></a>3.3.RedisTemplate</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p><h3 id="3-3-1-导入Demo工程"><a href="#3-3-1-导入Demo工程" class="headerlink" title="3.3.1.导入Demo工程"></a>3.3.1.导入Demo工程</h3><p>首先，我们引入课前资料提供的Demo工程：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfst5jbj205g05xa9x.jpg" alt="image-20210725155124958"> </p><h3 id="3-3-2-引入依赖"><a href="#3-3-2-引入依赖" class="headerlink" title="3.3.2.引入依赖"></a>3.3.2.引入依赖</h3><p>在项目的pom文件中引入依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3-配置Redis地址"><a href="#3-3-3-配置Redis地址" class="headerlink" title="3.3.3.配置Redis地址"></a>3.3.3.配置Redis地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">spring<span class="token operator">:</span>  redis<span class="token operator">:</span>    sentinel<span class="token operator">:</span>      master<span class="token operator">:</span> mymaster      nodes<span class="token operator">:</span>        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27001</span>        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27002</span>        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27003</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4-配置读写分离"><a href="#3-3-4-配置读写分离" class="headerlink" title="3.3.4.配置读写分离"></a>3.3.4.配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">LettuceClientConfigurationBuilderCustomizer</span> <span class="token function">clientConfigurationBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> clientConfigurationBuilder <span class="token operator">-></span> clientConfigurationBuilder<span class="token punctuation">.</span><span class="token function">readFrom</span><span class="token punctuation">(</span><span class="token class-name">ReadFrom</span><span class="token punctuation">.</span>REPLICA_PREFERRED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul><h1 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4.Redis分片集群"></a>4.Redis分片集群</h1><h2 id="4-1-搭建分片集群"><a href="#4-1-搭建分片集群" class="headerlink" title="4.1.搭建分片集群"></a>4.1.搭建分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfplctqj20lf0hjta1.jpg" alt="image-20210725155747294"></p><p>分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><p>具体搭建流程参考课前资料《Redis集群.md》：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfo2vwwj205e061745.jpg" alt="image-20210725155806288"> </p><h2 id="4-2-散列插槽"><a href="#4-2-散列插槽" class="headerlink" title="4.2.散列插槽"></a>4.2.散列插槽</h2><h3 id="4-2-1-插槽原理"><a href="#4-2-1-插槽原理" class="headerlink" title="4.2.1.插槽原理"></a>4.2.1.插槽原理</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfmm87lj20gf03g3zc.jpg" alt="image-20210725155820320"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvflbixyj20fy03f74m.jpg" alt="image-20210725155850200"> </p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p><h3 id="4-2-1-小结"><a href="#4-2-1-小结" class="headerlink" title="4.2.1.小结"></a>4.2.1.小结</h3><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h2 id="4-3-集群伸缩"><a href="#4-3-集群伸缩" class="headerlink" title="4.3.集群伸缩"></a>4.3.集群伸缩</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfjvw1nj20fw05kaap.jpg" alt="image-20210725160138290"></p><p>比如，添加节点的命令：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfip02ij2145072n0b.jpg" alt="image-20210725160448139"></p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p><ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li></ul><p>这里需要两个新的功能：</p><ul><li>添加一个节点到集群中</li><li>将部分插槽分配到新插槽</li></ul><h3 id="4-3-2-创建新的redis实例"><a href="#4-3-2-创建新的redis实例" class="headerlink" title="4.3.2.创建新的redis实例"></a>4.3.2.创建新的redis实例</h3><p>创建一个文件夹：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mkdir 7004<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拷贝配置文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cp redis.conf &#x2F;7004<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件：</p><p>&#x3D;&#x3D;注意，原有资料有问题&#x3D;&#x3D;</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sed -i -e &#39;s&#x2F;6379&#x2F;7004&#x2F;g&#39;  7004&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-server 7004&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-3-添加新节点到redis"><a href="#4-3-3-添加新节点到redis" class="headerlink" title="4.3.3.添加新节点到redis"></a>4.3.3.添加新节点到redis</h3><p>添加节点的语法如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfip02ij2145072n0b.jpg" alt="image-20210725160448139"></p><p>执行命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli --cluster add-node  192.168.200.137:7004 192.168.150.101:7001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过命令查看集群状态：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli -p 7001 cluster nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图，7004加入了集群，并且默认是一个master节点：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfhmdgaj2145072n0b.jpg" alt="image-20210725161007099"></p><p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p><h3 id="4-3-4-转移插槽"><a href="#4-3-4-转移插槽" class="headerlink" title="4.3.4.转移插槽"></a>4.3.4.转移插槽</h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfg9n4uj20ps02qdg2.jpg" alt="image-20210725161241793"></p><p>如上图所示，num的插槽为2765.</p><p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfex6cpj20od0fzjtu.jpg" alt="image-20210725161401925"></p><p>具体命令如下：</p><p>建立连接：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfdtwp0j20oj011t8s.jpg" alt="image-20210725161506241"></p><p>得到下面的反馈：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfch2r3j20r904yt9f.jpg" alt="image-20210725161540841"></p><p>询问要移动多少个插槽，我们计划是3000个：</p><p>新的问题来了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfbf5gwj20nc048aaj.jpg" alt="image-20210725161637152"></p><p>那个node来接收这些插槽？？</p><p>显然是7004，那么7004节点的id是多少呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvfakvb1j20lx06wgn4.jpg" alt="image-20210725161731738"></p><p>复制这个id，然后拷贝到刚才的控制台后：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf9xb0fj20wy08z40q.jpg" alt="image-20210725161817642"></p><p>这里询问，你的插槽是从哪里移动过来的？</p><ul><li>all：代表全部，也就是三个节点各转移一部分</li><li>具体的id：目标节点的id</li><li>done：没有了</li></ul><p>这里我们要从7001获取，因此填写7001的id：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf906qhj20t909xq5h.jpg" alt="image-20210725162030478"></p><p>填完后，点击done，这样插槽转移就准备好了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf7fxwnj20od05p407.jpg" alt="image-20210725162101228"></p><p>确认要转移吗？输入yes：</p><p>然后，通过命令查看结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf6aay6j20ii00vwee.jpg" alt="image-20210725162145497"> </p><p>可以看到： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf64m87j214b07qwi1.jpg" alt="image-20210725162224058"></p><p>目的达成。</p><h3 id="4-3-5-删除集群中的一个节点"><a href="#4-3-5-删除集群中的一个节点" class="headerlink" title="4.3.5 删除集群中的一个节点"></a>4.3.5 删除集群中的一个节点</h3><p>注意：在删除master节点之前，要先保证当前master节点中的槽要先转移到别的master的节点上</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf4xr65j20vb01wjsf.jpg" alt="1647100011943"></p><p>第一步，转移槽到别的节点上</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#语法：redis-cli --cluster reshard IP:port#具体命令redis-cli  --cluster reshard 192.168.200.137:7004<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf3jqlzj20j20fnq8m.jpg" alt="1647100103457"></p><p>第二步，删除节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#语法redis-cli --cluster del-node IP:port 节点的id#具体命令redis-cli --cluster del-node 192.168.200.137:7004 0746ccdcd7bb03cd86470998e9a9aabcb11b397d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf2l8zzj20vl02cab6.jpg" alt="1647100372962"></p><p>第三步，查看集群节点信息，发现没有了7004节点</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf1mhmcj2147049jv3.jpg" alt="1647100403487"></p><h2 id="4-4-故障转移"><a href="#4-4-故障转移" class="headerlink" title="4.4.故障转移"></a>4.4.故障转移</h2><p>集群初识状态是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf0pt1tj20pl02wq4k.jpg" alt="image-20210727161152065"></p><p>其中7001、7002、7003都是master，我们计划让7002宕机。</p><h3 id="4-4-1-自动故障转移"><a href="#4-4-1-自动故障转移" class="headerlink" title="4.4.1.自动故障转移"></a>4.4.1.自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli -p 7002 shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvezw62lj20v20390ur.jpg" alt="image-20210725162319490"></p><p>3）最后是确定下线，自动提升一个slave为新的master：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvf3yfnhj20v203ddht.jpg" alt="image-20210725162408979"></p><p>4）当7002再次启动，就会变为一个slave节点了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uveyoxcuj212e04lwhl.jpg" alt="image-20210727160803386"></p><h3 id="4-4-2-手动故障转移"><a href="#4-4-2-手动故障转移" class="headerlink" title="4.4.2.手动故障转移"></a>4.4.2.手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvexgtc1j20l60gfab8.jpg" alt="image-20210725162441407"></p><p>这种failover命令可以指定三种模式：</p><ul><li>缺省：默认的流程，如图1~6歩</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul><p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uveu9omdj20jq01zq2z.jpg" alt="image-20210727160037766"></p><p>效果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvev7ec1j20pl02wq4k.jpg" alt="image-20210727161152065"></p><h2 id="4-5-RedisTemplate访问分片集群"><a href="#4-5-RedisTemplate访问分片集群" class="headerlink" title="4.5.RedisTemplate访问分片集群"></a>4.5.RedisTemplate访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">cluster</span><span class="token punctuation">:</span>      <span class="token key atrule">nodes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7001</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7002</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">7003</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8001</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8002</span>        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8003</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装和集群Elasticsearch</title>
      <link href="/2022/06/03/%E5%AE%89%E8%A3%85elasticsearch/"/>
      <url>/2022/06/03/%E5%AE%89%E8%A3%85elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h1><h1 id="1-部署单点es"><a href="#1-部署单点es" class="headerlink" title="1.部署单点es"></a>1.部署单点es</h1><h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker network create es-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p><p>课前资料提供了镜像的tar包：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7omds7j20da085js6.jpg" alt="image-20210510165308064"></p><p>大家将其上传到虚拟机中，然后运行命令加载即可：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 导入数据docker load -i es.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同理还有<code>kibana</code>的tar包也需要这样做。</p><h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run -d \--name es \    -e &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; \    -e &quot;discovery.type&#x3D;single-node&quot; \    -v es-data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \    -v es-plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \    --privileged \    --network es-net \    -p 9200:9200 \    -p 9300:9300 \elasticsearch:7.12.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.150.101:9200/">http://192.168.150.101:9200</a> 即可看到elasticsearch的响应结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7nacafj20kx0gfwgz.jpg" alt="image-20210506101053676"></p><h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run -d \--name kibana \-e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;es:9200 \--network&#x3D;es-net \-p 5601:5601  \kibana:7.12.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker logs -f kibana<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看运行日志，当查看到下面的日志，说明成功：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7lx07xj215s0a0aeu.jpg" alt="image-20210109105135812"></p><p>此时，在浏览器输入地址访问：<a href="http://192.168.150.101:5601，即可看到结果">http://192.168.150.101:5601，即可看到结果</a></p><h2 id="2-2-DevTools"><a href="#2-2-DevTools" class="headerlink" title="2.2.DevTools"></a>2.2.DevTools</h2><p>kibana中提供了一个DevTools界面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7kgei6j20v60et76j.jpg" alt="image-20210506102630393"></p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入容器内部docker exec -it elasticsearch &#x2F;bin&#x2F;bash# 在线下载并安装.&#x2F;bin&#x2F;elasticsearch-plugin  install https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.12.1&#x2F;elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker volume inspect es-plugins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"CreatedAt"</span><span class="token operator">:</span> <span class="token string">"2022-05-06T10:06:34+08:00"</span><span class="token punctuation">,</span>        <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>        <span class="token property">"Labels"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>        <span class="token property">"Mountpoint"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/es-plugins/_data"</span><span class="token punctuation">,</span>        <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"es-plugins"</span><span class="token punctuation">,</span>        <span class="token property">"Options"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>        <span class="token property">"Scope"</span><span class="token operator">:</span> <span class="token string">"local"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7ijiokj20di06074p.jpg" alt="image-20210506110249144"></p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7h6xosj20y209tq4p.jpg" alt="image-20210506110704293"></p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 4、重启容器docker restart es<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 查看es日志docker logs -f es<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p></li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /_analyze<span class="token punctuation">&#123;</span>  <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>  <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"黑马程序员学习java太棒了"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"tokens"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"黑马"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"程序员"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"程序"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"员"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_CHAR"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"学习"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">7</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">4</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"java"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">7</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"ENGLISH"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">5</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"太棒了"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">6</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"太棒"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">13</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_WORD"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">7</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"了"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">13</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"CN_CHAR"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">8</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p><p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7ex5a8j20kx0a5tbe.jpg" alt="image-20210506112225508"></p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">properties</span> <span class="token name">SYSTEM</span> <span class="token string">"http://java.sun.com/dtd/properties.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comment</span><span class="token punctuation">></span></span>IK Analyzer 扩展配置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comment</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ext_dict<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>ext.dic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">传智播客奥力给<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4）重启elasticsearch </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker restart es# 查看 日志docker logs -f elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7dpygpj22lk0lcgw8.jpg" alt="image-20201115230900504"></p><p>日志中已经成功加载ext.dic配置文件</p><p>5）测试效果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /_analyze<span class="token punctuation">&#123;</span>  <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>  <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"传智播客Java就业超过90%,奥力给！"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p></blockquote><h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">properties</span> <span class="token name">SYSTEM</span> <span class="token string">"http://java.sun.com/dtd/properties.dtd"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comment</span><span class="token punctuation">></span></span>IK Analyzer 扩展配置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comment</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--用户可以在这里配置自己的扩展字典--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ext_dict<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>ext.dic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>         <span class="token comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ext_stopwords<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>stopword.dic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）在 stopword.dic 添加停用词</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">习大大<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4）重启elasticsearch </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志中已经成功加载stopword.dic配置文件</p><p>5）测试效果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /_analyze<span class="token punctuation">&#123;</span>  <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>  <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"传智播客Java就业率超过95%,习大大都点赞,奥力给！"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p></blockquote><h1 id="4-部署es集群"><a href="#4-部署es集群" class="headerlink" title="4.部署es集群"></a>4.部署es集群</h1><p>我们会在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。</p><p>部署es集群可以直接使用docker-compose来完成，但这要求你的Linux虚拟机至少有<strong>4G</strong>的内存空间</p><h2 id="4-1-创建es集群"><a href="#4-1-创建es集群" class="headerlink" title="4.1.创建es集群"></a>4.1.创建es集群</h2><p>首先编写一个docker-compose文件，内容如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">version: &#39;2.2&#39;services:  es01:    image: elasticsearch:7.12.1    container_name: es01    environment:      - node.name&#x3D;es01      - cluster.name&#x3D;es-docker-cluster      - discovery.seed_hosts&#x3D;es02,es03      - cluster.initial_master_nodes&#x3D;es01,es02,es03      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot;    volumes:      - data01:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data    ports:      - 9200:9200    networks:      - elastic  es02:    image: elasticsearch:7.12.1    container_name: es02    environment:      - node.name&#x3D;es02      - cluster.name&#x3D;es-docker-cluster      - discovery.seed_hosts&#x3D;es01,es03      - cluster.initial_master_nodes&#x3D;es01,es02,es03      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot;    volumes:      - data02:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data    ports:      - 9201:9200    networks:      - elastic  es03:    image: elasticsearch:7.12.1    container_name: es03    environment:      - node.name&#x3D;es03      - cluster.name&#x3D;es-docker-cluster      - discovery.seed_hosts&#x3D;es01,es02      - cluster.initial_master_nodes&#x3D;es01,es02,es03      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot;    volumes:      - data03:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data    networks:      - elastic    ports:      - 9202:9200volumes:  data01:    driver: local  data02:    driver: local  data03:    driver: localnetworks:  elastic:    driver: bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>es运行需要修改一些linux系统权限，修改<code>/etc/sysctl.conf</code>文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vi &#x2F;etc&#x2F;sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加下面的内容：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vm.max_map_count&#x3D;262144<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行命令，让配置生效：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sysctl -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过docker-compose启动集群：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2-集群状态监控"><a href="#4-2-集群状态监控" class="headerlink" title="4.2.集群状态监控"></a>4.2.集群状态监控</h2><p>kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。</p><p>这里推荐使用cerebro来监控es集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a></p><p>课前资料已经提供了安装包：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv7b3ogmj20bb04wq39.jpg" alt="image-20210602220751081"></p><p>解压即可使用，非常方便。</p><p>解压好的目录如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv79nom6j20ao04qa9y.jpg" alt="image-20210602220824668"></p><p>进入对应的bin目录：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv78pllnj20b504rq2y.jpg" alt="image-20210602220846137"></p><p>双击其中的cerebro.bat文件即可启动服务。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv77m4szj20u50av0vt.jpg" alt="image-20210602220941101"></p><p>访问<a href="http://localhost:9000/">http://localhost:9000</a> 即可进入管理界面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv76agfxj20hz0fzdg6.jpg" alt="image-20210602221115763"></p><p>输入你的elasticsearch的任意节点的地址和端口，点击connect即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv75fwimj21c70klgog.jpg" alt="image-20210109181106866"></p><p>绿色的条，代表集群处于绿色（健康状态）。</p><h2 id="4-3-创建索引库"><a href="#4-3-创建索引库" class="headerlink" title="4.3.创建索引库"></a>4.3.创建索引库</h2><h3 id="1）利用kibana的DevTools创建索引库"><a href="#1）利用kibana的DevTools创建索引库" class="headerlink" title="1）利用kibana的DevTools创建索引库"></a>1）利用kibana的DevTools创建索引库</h3><p>在DevTools中输入指令：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /itcast<span class="token punctuation">&#123;</span>  <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// 分片数量</span>    <span class="token property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token comment">// 副本数量</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// mapping映射定义 ...</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）利用cerebro创建索引库"><a href="#2）利用cerebro创建索引库" class="headerlink" title="2）利用cerebro创建索引库"></a>2）利用cerebro创建索引库</h3><p>利用cerebro还可以创建索引库：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv742tdcj20gi05974p.jpg" alt="image-20210602221409524"></p><p>填写索引库信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv733od7j20eq0ac3yy.jpg" alt="image-20210602221520629"></p><p>点击右下角的create按钮：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv72517bj20hi078jra.jpg" alt="image-20210602221542745"></p><h2 id="4-4-查看分片效果"><a href="#4-4-查看分片效果" class="headerlink" title="4.4.查看分片效果"></a>4.4.查看分片效果</h2><p>回到首页，即可查看索引库分片效果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uv71d4yej20qt0jv0ut.jpg" alt="image-20210602221914483"></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch使用02</title>
      <link href="/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/"/>
      <url>/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎02"><a href="#分布式搜索引擎02" class="headerlink" title="分布式搜索引擎02"></a>分布式搜索引擎02</h1><p>在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p><p>所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p><h1 id="1-DSL查询文档"><a href="#1-DSL查询文档" class="headerlink" title="1.DSL查询文档"></a>1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p><h2 id="1-1-DSL查询分类"><a href="#1-1-DSL查询分类" class="headerlink" title="1.1.DSL查询分类"></a>1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p></li><li><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"查询类型"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"查询条件"</span><span class="token operator">:</span> <span class="token string">"条件值"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 查询所有</span>GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h2 id="1-2-全文检索查询"><a href="#1-2-全文检索查询" class="headerlink" title="1.2.全文检索查询"></a>1.2.全文检索查询</h2><h3 id="1-2-1-使用场景"><a href="#1-2-1-使用场景" class="headerlink" title="1.2.1.使用场景"></a>1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuuqv987j20sg056q3k.jpg" alt="image-20210721165326938"></p><p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p><h3 id="1-2-2-基本语法"><a href="#1-2-2-基本语法" class="headerlink" title="1.2.2.基本语法"></a>1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token string">"TEXT"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mulit_match语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"multi_match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"TEXT"</span><span class="token punctuation">,</span>      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"FIELD1"</span><span class="token punctuation">,</span> <span class="token string">" FIELD12"</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-示例"><a href="#1-2-3-示例" class="headerlink" title="1.2.3.示例"></a>1.2.3.示例</h3><p>match查询示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuvrjdnoj21cu0gcgoj.jpg" alt="image-20210721170455419"></p><p>multi_match查询示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuvsrexkj21cx0gaadh.jpg" alt="image-20210721170720691"></p><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p><p>但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</p><h3 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4.总结"></a>1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h2 id="1-3-精准查询"><a href="#1-3-精准查询" class="headerlink" title="1.3.精准查询"></a>1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li><li>text:被标注该类型的字段会先进行分词处理，然后再执行查询操作</li><li>keyword:被标注该类型的字段不会进行分词处理，</li></ul><h3 id="1-3-1-term查询"><a href="#1-3-1-term查询" class="headerlink" title="1.3.1.term查询"></a>1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// term查询</span>GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"VALUE"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuvug07pj21790fh772.jpg" alt="image-20210721171655308"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuvv1y66j210b0cvdh9.jpg" alt="image-20210721171838378"></p><h3 id="1-3-2-range查询"><a href="#1-3-2-range查询" class="headerlink" title="1.3.2.range查询"></a>1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// range查询</span>GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"gte"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 这里的gte代表大于等于，gt则代表大于</span>        <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token comment">// lte代表小于等于，lt则代表小于</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuvxftn0j21560biq51.jpg" alt="image-20210721172307172"></p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><p>精确查询常见的有哪些？</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h2 id="1-4-地理坐标查询"><a href="#1-4-地理坐标查询" class="headerlink" title="1.4.地理坐标查询"></a>1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><p>附近的酒店：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuw15g1rj20ad0b2dgl.jpg" alt="image-20210721172645103"> </p><p>附近的车：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuw21spoj20870dy0ta.jpg" alt="image-20210721172654880"> </p><h3 id="1-4-1-矩形范围查询"><a href="#1-4-1-矩形范围查询" class="headerlink" title="1.4.1.矩形范围查询"></a>1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuw4w8e1g209c04qtcw.gif" alt="DKV9HZbVS6"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p>语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// geo_bounding_box查询</span>GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"geo_bounding_box"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"top_left"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左上点</span>          <span class="token property">"lat"</span><span class="token operator">:</span> <span class="token number">31.1</span><span class="token punctuation">,</span>          <span class="token property">"lon"</span><span class="token operator">:</span> <span class="token number">121.5</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token property">"bottom_right"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 右下点</span>          <span class="token property">"lat"</span><span class="token operator">:</span> <span class="token number">30.9</span><span class="token punctuation">,</span>          <span class="token property">"lon"</span><span class="token operator">:</span> <span class="token number">121.7</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。</p><h3 id="1-4-2-附近查询"><a href="#1-4-2-附近查询" class="headerlink" title="1.4.2.附近查询"></a>1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuw7ddh5g20f608zaln.gif" alt="vZrdKAh19C"></p><p>语法说明：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// geo_distance 查询</span>GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"geo_distance"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"distance"</span><span class="token operator">:</span> <span class="token string">"15km"</span><span class="token punctuation">,</span> <span class="token comment">// 半径</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token string">"31.21,121.5"</span> <span class="token comment">// 圆心</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuw8xiepj20zn0d6ac4.jpg" alt="image-20210721175443234"></p><p>发现共有47家酒店。</p><p>然后把半径缩短到3公里：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwaeu9kj210c0d2tas.jpg" alt="image-20210721182031475"></p><p>可以发现，搜索到的酒店数量减少到了5家。</p><h2 id="1-5-复合查询"><a href="#1-5-复合查询" class="headerlink" title="1.5.复合查询"></a>1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="1-5-1-相关性算分"><a href="#1-5-1-相关性算分" class="headerlink" title="1.5.1.相关性算分"></a>1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    <span class="token property">"_score"</span> <span class="token operator">:</span> <span class="token number">17.850193</span><span class="token punctuation">,</span>    <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"虹桥如家酒店真不错"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token property">"_score"</span> <span class="token operator">:</span> <span class="token number">12.259849</span><span class="token punctuation">,</span>    <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"外滩如家酒店真不错"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token property">"_score"</span> <span class="token operator">:</span> <span class="token number">11.91091</span><span class="token punctuation">,</span>    <span class="token property">"_source"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"迪士尼如家酒店真不错"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwcuoi6j20nn0ag3z3.jpg" alt="image-20210721190152134"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwfi5b3j20pc05fq31.jpg" alt="image-20210721190416214"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwh1n87j20gd0bk756.jpg" alt="image-20210721190907320"></p><p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><h3 id="1-5-2-算分函数查询"><a href="#1-5-2-算分函数查询" class="headerlink" title="1.5.2.算分函数查询"></a>1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwjwc91j20kl0983ze.jpg" alt="image-20210721191144560"></p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><h4 id="1）语法说明"><a href="#1）语法说明" class="headerlink" title="1）语法说明"></a>1）语法说明</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwkt59aj21350fgjv2.jpg" alt="image-20210721191544750"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><h4 id="2）示例"><a href="#2）示例" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand &#x3D; “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"function_score"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  # 分词查询all(brand<span class="token punctuation">,</span>name<span class="token punctuation">,</span>city)包含如家酒店的都查询出来  数量=<span class="token number">199</span>        <span class="token property">"all"</span><span class="token operator">:</span> <span class="token string">"如家酒店"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"functions"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> #表示从上面查询的结果中过滤品牌为如家的数据  数量小于或者<span class="token number">199</span>            <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"brand"</span><span class="token operator">:</span> <span class="token string">"如家"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">3</span>  #权重        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"boost_mode"</span><span class="token operator">:</span> <span class="token string">"sum"</span>  #权重模式，sum表示相加  原有数据_score+weight    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwni79jj21180cc40f.jpg" alt="image-20210721193152520"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwoy4qaj212y0fsjv0.jpg" alt="image-20210721193458182"></p><h4 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><h3 id="1-5-3-布尔查询"><a href="#1-5-3-布尔查询" class="headerlink" title="1.5.3.布尔查询"></a>1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwqz05vj20rc07daar.jpg" alt="image-20210721193822848"></p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p><p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><h4 id="1）语法示例："><a href="#1）语法示例：" class="headerlink" title="1）语法示例："></a>1）语法示例：</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span><span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"city"</span><span class="token operator">:</span> <span class="token string">"上海"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"should"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span><span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"brand"</span><span class="token operator">:</span> <span class="token string">"皇冠假日"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"brand"</span><span class="token operator">:</span> <span class="token string">"华美达"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"must_not"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span> <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"price"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">500</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span> <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"score"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"gte"</span><span class="token operator">:</span> <span class="token number">45</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）示例-1"><a href="#2）示例-1" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li><li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li><li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwtvvflj217b0hi786.jpg" alt="image-20210721194744183"></p><h4 id="3）小结-1"><a href="#3）小结-1" class="headerlink" title="3）小结"></a>3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h1 id="2-搜索结果处理"><a href="#2-搜索结果处理" class="headerlink" title="2.搜索结果处理"></a>2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1.排序"></a>2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><h3 id="2-1-1-普通字段排序"><a href="#2-1-1-普通字段排序" class="headerlink" title="2.1.1.普通字段排序"></a>2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token string">"desc"</span>  <span class="token comment">// 排序字段、排序方式ASC、DESC</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwvkzh7j20ih09vaac.jpg" alt="image-20210721195728306"></p><h3 id="2-1-2-地理坐标排序"><a href="#2-1-2-地理坐标排序" class="headerlink" title="2.1.2.地理坐标排序"></a>2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"_geo_distance"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"FIELD"</span> <span class="token operator">:</span> <span class="token string">"纬度，经度"</span><span class="token punctuation">,</span> <span class="token comment">// 文档中geo_point类型的字段名、目标坐标点</span>          <span class="token property">"order"</span> <span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">,</span> <span class="token comment">// 排序方式</span>          <span class="token property">"unit"</span> <span class="token operator">:</span> <span class="token string">"km"</span> <span class="token comment">// 排序的距离单位</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuwyhwkqj213x0degof.jpg" alt="image-20210721200214690"></p><h2 id="2-2-分页"><a href="#2-2-分页" class="headerlink" title="2.2.分页"></a>2.2.分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><h3 id="2-2-1-基本的分页"><a href="#2-2-1-基本的分页" class="headerlink" title="2.2.1.基本的分页"></a>2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"from"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 分页开始的位置，默认为0</span>  <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 期望获取的文档总数</span>  <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span><span class="token property">"price"</span><span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-深度分页问题"><a href="#2-2-2-深度分页问题" class="headerlink" title="2.2.2.深度分页问题"></a>2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"from"</span><span class="token operator">:</span> <span class="token number">990</span><span class="token punctuation">,</span> <span class="token comment">// 分页开始的位置，默认为0</span>  <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 期望获取的文档总数</span>  <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span><span class="token property">"price"</span><span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uux071cej20lk0830t2.jpg" alt="image-20210721200643029"></p><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uux3zvdij20mt0epmye.jpg" alt="image-20210721201003229"></p><p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><h3 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3.小结"></a>2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h2 id="2-3-高亮"><a href="#2-3-高亮" class="headerlink" title="2.3.高亮"></a>2.3.高亮</h2><h3 id="2-3-1-高亮原理"><a href="#2-3-1-高亮原理" class="headerlink" title="2.3.1.高亮原理"></a>2.3.1.高亮原理</h3><p>什么是高亮显示呢？</p><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uux5r9xfj20fu0d7abs.jpg" alt="image-20210721202705030"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><h3 id="2-3-2-实现高亮"><a href="#2-3-2-实现高亮" class="headerlink" title="2.3.2.实现高亮"></a>2.3.2.实现高亮</h3><p><strong>高亮的语法</strong>：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token string">"TEXT"</span> <span class="token comment">// 查询条件，高亮一定要使用全文检索查询</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"highlight"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 指定要高亮的字段</span>      <span class="token property">"FIELD"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"pre_tags"</span><span class="token operator">:</span> <span class="token string">"&lt;em>"</span><span class="token punctuation">,</span>  <span class="token comment">// 用来标记高亮字段的前置标签</span>        <span class="token property">"post_tags"</span><span class="token operator">:</span> <span class="token string">"&lt;/em>"</span> <span class="token comment">// 用来标记高亮字段的后置标签</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false</li></ul><p><strong>示例</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uux86pi2j212w0f277j.jpg" alt="image-20210721203349633"></p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4.总结"></a>2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uux9wyi5j20m30j4die.jpg" alt="image-20210721203657850"></p><h1 id="3-RestClient查询文档"><a href="#3-RestClient查询文档" class="headerlink" title="3.RestClient查询文档"></a>3.RestClient查询文档</h1><p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul><h2 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1.快速入门"></a>3.1.快速入门</h2><p>我们以match_all查询为例</p><h3 id="3-1-1-发起查询请求"><a href="#3-1-1-发起查询请求" class="headerlink" title="3.1.1.发起查询请求"></a>3.1.1.发起查询请求</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxc1wv3j21400c4taq.jpg" alt="image-20210721203950559"></p><p>代码解读：</p><ul><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxcxwjzj20j90dggnh.jpg" alt="image-20210721215640790"></p><p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxebtfwj20gy0a9jtl.jpg" alt="image-20210721215729236"></p><h3 id="3-1-2-解析响应"><a href="#3-1-2-解析响应" class="headerlink" title="3.1.2.解析响应"></a>3.1.2.解析响应</h3><p>响应结果的解析：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxfa8mfj213v0jejvj.jpg" alt="image-20210721214221057"></p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h3 id="3-1-3-完整代码"><a href="#3-1-3-完整代码" class="headerlink" title="3.1.3.完整代码"></a>3.1.3.完整代码</h3><p>完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testMatchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备DSL</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.1.获取总条数</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"共搜索到"</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"条数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.2.文档数组</span>    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.3.遍历</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取文档source</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 反序列化</span>        <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hotelDoc = "</span> <span class="token operator">+</span> hotelDoc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3><p>查询的基本步骤是：</p><ol><li><p>创建SearchRequest对象</p></li><li><p>准备Request.source()，也就是DSL。</p><p>① QueryBuilders来构建查询条件</p><p>② 传入Request.source() 的 query() 方法</p></li><li><p>发送请求，得到结果</p></li><li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p></li></ol><h2 id="3-2-match查询"><a href="#3-2-match查询" class="headerlink" title="3.2.match查询"></a>3.2.match查询</h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxhl36ij209y0dzq3l.jpg" alt="image-20210721215923060"> </p><p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxiyjgsj20jx04gmxm.jpg" alt="image-20210721215843099"> </p><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备DSL</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span> <span class="token string">"如家"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-精确查询"><a href="#3-3-精确查询" class="headerlink" title="3.3.精确查询"></a>3.3.精确查询</h2><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p>查询条件构造的API如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxlb43mj20hv04gjrt.jpg" alt="image-20210721220305140"> </p><h2 id="3-4-布尔查询"><a href="#3-4-布尔查询" class="headerlink" title="3.4.布尔查询"></a>3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxmmc8rj214w0enq5g.jpg" alt="image-20210721220927286"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备DSL</span>    <span class="token comment">// 2.1.准备BooleanQuery</span>    <span class="token class-name">BoolQueryBuilder</span> boolQuery <span class="token operator">=</span> <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">boolQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.2.添加term</span>    boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">,</span> <span class="token string">"杭州"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.3.添加range</span>    boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">rangeQuery</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lte</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>boolQuery<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-排序、分页"><a href="#3-5-排序、分页" class="headerlink" title="3.5.排序、分页"></a>3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p><p>对应的API如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxokbmhj214g0c8myx.jpg" alt="image-20210721221121266"></p><p>完整代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testPageAndSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 页码，每页大小</span>    <span class="token keyword">int</span> page <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备DSL</span>    <span class="token comment">// 2.1.query</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.2.排序 sort</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">,</span> <span class="token class-name">SortOrder</span><span class="token punctuation">.</span>ASC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.3.分页 from、size</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-高亮"><a href="#3-6-高亮" class="headerlink" title="3.6.高亮"></a>3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li><li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li></ul><h3 id="3-6-1-高亮请求构建"><a href="#3-6-1-高亮请求构建" class="headerlink" title="3.6.1.高亮请求构建"></a>3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxpwlthj213v0fdgne.jpg" alt="image-20210721221744883"></p><p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testHighlight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备DSL</span>    <span class="token comment">// 2.1.query</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span> <span class="token string">"如家"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.2.高亮</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">highlighter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HighlightBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">requireFieldMatch</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;注意：如果多个字段进行高亮设置，必须设置高亮的时候加入requireFieldMatch(false)&#x3D;&#x3D;</p><h3 id="3-6-2-高亮结果解析"><a href="#3-6-2-高亮结果解析" class="headerlink" title="3.6.2.高亮结果解析"></a>3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxs9x3gj215a0j143a.jpg" alt="image-20210721222057212"></p><p>代码解读：</p><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><p>完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.1.获取总条数</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"共搜索到"</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"条数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.2.文档数组</span>    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.3.遍历</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取文档source</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 反序列化</span>        <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取高亮结果</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HighlightField</span><span class="token punctuation">></span></span> highlightFields <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getHighlightFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>highlightFields<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 根据字段名获取高亮结果</span>            <span class="token class-name">HighlightField</span> highlightField <span class="token operator">=</span> highlightFields<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>highlightField <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 获取高亮值</span>                <span class="token class-name">String</span> name <span class="token operator">=</span> highlightField<span class="token punctuation">.</span><span class="token function">getFragments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 覆盖非高亮结果</span>                hotelDoc<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hotelDoc = "</span> <span class="token operator">+</span> hotelDoc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-黑马旅游案例"><a href="#4-黑马旅游案例" class="headerlink" title="4.黑马旅游案例"></a>4.黑马旅游案例</h1><p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。</p><p>我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8090，就能看到项目页面了：">http://localhost:8090，就能看到项目页面了：</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxuytn2j21510j8n02.jpg" alt="image-20210721223159598"></p><h2 id="4-1-酒店搜索和分页"><a href="#4-1-酒店搜索和分页" class="headerlink" title="4.1.酒店搜索和分页"></a>4.1.酒店搜索和分页</h2><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p><h3 id="4-1-1-需求分析"><a href="#4-1-1-需求分析" class="headerlink" title="4.1.1.需求分析"></a>4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxw83csj20nx06t74o.jpg" alt="image-20210721223859419"></p><p>点击搜索按钮，可以看到浏览器控制台发出了请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxx28cxj20ht064dg8.jpg" alt="image-20210721224033789"></p><p>请求参数如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuxxw1t3j20jb05o3yl.jpg" alt="image-20210721224112708"></p><p>由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：&#x2F;hotel&#x2F;list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li>步骤一：定义实体类，接收请求参数的JSON对象</li><li>步骤二：编写controller，接收页面的请求</li><li>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页</li></ul><h3 id="4-1-2-定义实体类"><a href="#4-1-2-定义实体类" class="headerlink" title="4.1.2.定义实体类"></a>4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p><p>1）请求参数</p><p>前端请求的json结构如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"搜索关键字"</span><span class="token punctuation">,</span>    <span class="token property">"page"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token property">"sortBy"</span><span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestParams</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> page<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> sortBy<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）返回值</p><p>分页查询，需要返回分页结果PageResult，包含两个属性：</p><ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PageResult</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> total<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HotelDoc</span><span class="token punctuation">></span></span> hotels<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PageResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">PageResult</span><span class="token punctuation">(</span><span class="token class-name">Long</span> total<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HotelDoc</span><span class="token punctuation">></span></span> hotels<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>total <span class="token operator">=</span> total<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hotels <span class="token operator">=</span> hotels<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-3-定义controller"><a href="#4-1-3-定义controller" class="headerlink" title="4.1.3.定义controller"></a>4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：&#x2F;hotel&#x2F;list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hotel"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">IHotelService</span> hotelService<span class="token punctuation">;</span><span class="token comment">// 搜索酒店数据</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">PageResult</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> hotelService<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-4-实现搜索业务"><a href="#4-1-4-实现搜索业务" class="headerlink" title="4.1.4.实现搜索业务"></a>4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。</p><p>1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 根据关键字搜索酒店信息 * @param params 请求参数对象，包含用户输入的关键字  * @return 酒店文档列表 */</span><span class="token class-name">PageResult</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">RestHighLevelClient</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span><span class="token class-name">RestClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>        <span class="token class-name">HttpHost</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://192.168.150.101:9200"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">PageResult</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.准备Request</span>        <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.准备DSL</span>        <span class="token comment">// 2.1.query</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 2.2.分页</span>        <span class="token keyword">int</span> page <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.发送请求</span>        <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.解析响应</span>        <span class="token keyword">return</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果解析</span><span class="token keyword">private</span> <span class="token class-name">PageResult</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 4.解析响应</span>    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.1.获取总条数</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// 4.2.文档数组</span>    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.3.遍历</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HotelDoc</span><span class="token punctuation">></span></span> hotels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取文档source</span>        <span class="token class-name">String</span> json <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 反序列化</span>        <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 放入集合</span>        hotels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4.4.封装返回</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PageResult</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> hotels<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-酒店结果过滤"><a href="#4-2-酒店结果过滤" class="headerlink" title="4.2.酒店结果过滤"></a>4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能</p><h3 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1.需求分析"></a>4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuy1oo2cj20pd06e3z0.jpg" alt="image-20210722091940726"></p><p>传递的参数如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuy2phgoj209u0andg6.jpg" alt="image-20210722092051994"> </p><p>包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li>修改请求参数的对象RequestParams，接收上述参数</li><li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li></ul><h3 id="4-2-2-修改实体类"><a href="#4-2-2-修改实体类" class="headerlink" title="4.2.2.修改实体类"></a>4.2.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestParams</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> page<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> sortBy<span class="token punctuation">;</span>    <span class="token comment">// 下面是新增的过滤条件参数</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> minPrice<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> maxPrice<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-3-修改搜索业务"><a href="#4-2-3-修改搜索业务" class="headerlink" title="4.2.3.修改搜索业务"></a>4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。</p><p>在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p><ul><li>品牌过滤：是keyword类型，用term查询</li><li>星级过滤：是keyword类型，用term查询</li><li>价格过滤：是数值类型，用range查询</li><li>城市过滤：是keyword类型，用term查询</li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuy4jzhxj20wb0im77q.jpg" alt="image-20210722092935453"></p><p>buildBasicQuery的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildBasicQuery</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">,</span> <span class="token class-name">SearchRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.构建BooleanQuery</span>    <span class="token class-name">BoolQueryBuilder</span> boolQuery <span class="token operator">=</span> <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">boolQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.关键字搜索</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3.城市条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4.品牌条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"brand"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 5.星级条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"starName"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 6.价格</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span>                         <span class="token punctuation">.</span><span class="token function">rangeQuery</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">gte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">lte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 7.放入source</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>boolQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-我周边的酒店"><a href="#4-3-我周边的酒店" class="headerlink" title="4.3.我周边的酒店"></a>4.3.我周边的酒店</h2><p>需求：我附近的酒店</p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuy7cz7hj20a60b53yq.jpg" alt="image-20210722093414542"> </p><p>并且，在前端会发起查询请求，将你的坐标发送到服务端：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuy86r6cj209m04v74g.jpg" alt="image-20210722093642382"> </p><p>我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li>修改RequestParams参数，接收location字段</li><li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li></ul><h3 id="4-3-2-修改实体类"><a href="#4-3-2-修改实体类" class="headerlink" title="4.3.2.修改实体类"></a>4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestParams</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> page<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> sortBy<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> minPrice<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> maxPrice<span class="token punctuation">;</span>    <span class="token comment">// 我当前的地理坐标</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-3-距离排序API"><a href="#4-3-3-距离排序API" class="headerlink" title="4.3.3.距离排序API"></a>4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p><ul><li>普通字段排序</li><li>地理坐标排序</li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /indexName/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"price"</span><span class="token operator">:</span> <span class="token string">"asc"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"_geo_distance"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"FIELD"</span> <span class="token operator">:</span> <span class="token string">"纬度，经度"</span><span class="token punctuation">,</span>          <span class="token property">"order"</span> <span class="token operator">:</span> <span class="token string">"asc"</span><span class="token punctuation">,</span>          <span class="token property">"unit"</span> <span class="token operator">:</span> <span class="token string">"km"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的java代码示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyazqekj213f0fjtb1.jpg" alt="image-20210722095227059"></p><h3 id="4-3-4-添加距离排序"><a href="#4-3-4-添加距离排序" class="headerlink" title="4.3.4.添加距离排序"></a>4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuybgp5uj20wf0mc42j.jpg" alt="image-20210722095902314"></p><p>完整代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">PageResult</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.准备Request</span>        <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.准备DSL</span>        <span class="token comment">// 2.1.query</span>        <span class="token function">buildBasicQuery</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2.分页</span>        <span class="token keyword">int</span> page <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.3.排序</span>        <span class="token class-name">String</span> location <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>location <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>location<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">SortBuilders</span>                                  <span class="token punctuation">.</span><span class="token function">geoDistanceSort</span><span class="token punctuation">(</span><span class="token string">"location"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GeoPoint</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span>                                  <span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token class-name">SortOrder</span><span class="token punctuation">.</span>ASC<span class="token punctuation">)</span>                                  <span class="token punctuation">.</span><span class="token function">unit</span><span class="token punctuation">(</span><span class="token class-name">DistanceUnit</span><span class="token punctuation">.</span>KILOMETERS<span class="token punctuation">)</span>                                 <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 3.发送请求</span>        <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.解析响应</span>        <span class="token keyword">return</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-5-排序距离显示"><a href="#4-3-5-排序距离显示" class="headerlink" title="4.3.5.排序距离显示"></a>4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuye99mjj211b0gbdj3.jpg" alt="image-20210722100040674"></p><p>发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？</p><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyfvoz1j20hs0b575i.jpg" alt="image-20210722095648542"></p><p>因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。</p><p>我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelDoc</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> business<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> pic<span class="token punctuation">;</span>    <span class="token comment">// 排序时的 距离值</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> distance<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span><span class="token class-name">Hotel</span> hotel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>starName <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>business <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBusiness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>location <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getLatitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> hotel<span class="token punctuation">.</span><span class="token function">getLongitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pic <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）修改HotelService中的handleResponse方法</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuygrmn0j20s50n278l.jpg" alt="image-20210722100613966"></p><p>重启后测试，发现页面能成功显示距离了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyihn7fj21210gzjue.jpg" alt="image-20210722100838604"></p><p>&#x3D;&#x3D;注意：前端关于地图定位，有问题，因为高德地图定位功能在pc上不太好，需要在前端页面中把定位写死&#x3D;&#x3D;</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyjka4rj214v0jmq70.jpg" alt="1647527529680"></p><h2 id="4-4-酒店竞价排名"><a href="#4-4-酒店竞价排名" class="headerlink" title="4.4.酒店竞价排名"></a>4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶</p><h3 id="4-4-1-需求分析"><a href="#4-4-1-需求分析" class="headerlink" title="4.4.1.需求分析"></a>4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuylwth4j20dy0ctgmn.jpg" alt="image-20210722100947292"></p><p>页面会给指定的酒店添加<strong>广告</strong>标记。</p><p>那怎样才能让指定的酒店排名置顶呢？</p><p>我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。</p><p>比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li><p>给HotelDoc类添加isAD字段，Boolean类型</p></li><li><p>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</p></li><li><p>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</p></li></ol><h3 id="4-4-2-修改HotelDoc实体"><a href="#4-4-2-修改HotelDoc实体" class="headerlink" title="4.4.2.修改HotelDoc实体"></a>4.4.2.修改HotelDoc实体</h3><p>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyo711uj20k00fmtax.jpg" alt="image-20210722101908062"></p><h3 id="4-4-3-添加广告标记"><a href="#4-4-3-添加广告标记" class="headerlink" title="4.4.3.添加广告标记"></a>4.4.3.添加广告标记</h3><p>接下来，我们挑几个酒店，添加isAD字段，设置为true：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /hotel/_update/<span class="token number">1902197537</span><span class="token punctuation">&#123;</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"isAD"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>POST /hotel/_update/<span class="token number">2056126831</span><span class="token punctuation">&#123;</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"isAD"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>POST /hotel/_update/<span class="token number">1989806195</span><span class="token punctuation">&#123;</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"isAD"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>POST /hotel/_update/<span class="token number">2056105938</span><span class="token punctuation">&#123;</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"isAD"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-4-添加算分函数查询"><a href="#4-4-4-添加算分函数查询" class="headerlink" title="4.4.4.添加算分函数查询"></a>4.4.4.添加算分函数查询</h3><p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p><p>function_score查询结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuypmr4uj21350fgjv2.jpg" alt="image-20210721191544750"></p><p>对应的JavaAPI如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuyqz9kfj214p0gen0u.jpg" alt="image-20210722102850818"></p><p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p><p>修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildBasicQuery</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">,</span> <span class="token class-name">SearchRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.构建BooleanQuery</span>    <span class="token class-name">BoolQueryBuilder</span> boolQuery <span class="token operator">=</span> <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">boolQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关键字搜索</span>    <span class="token class-name">String</span> key <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 城市条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 品牌条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"brand"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 星级条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"starName"</span><span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 价格</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span>                         <span class="token punctuation">.</span><span class="token function">rangeQuery</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">gte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">lte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2.算分控制</span>    <span class="token class-name">FunctionScoreQueryBuilder</span> functionScoreQuery <span class="token operator">=</span>        <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">functionScoreQuery</span><span class="token punctuation">(</span>        <span class="token comment">// 原始查询，相关性算分的查询</span>        boolQuery<span class="token punctuation">,</span>        <span class="token comment">// function score的数组</span>        <span class="token keyword">new</span> <span class="token class-name">FunctionScoreQueryBuilder<span class="token punctuation">.</span>FilterFunctionBuilder</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 其中的一个function score 元素</span>            <span class="token keyword">new</span> <span class="token class-name">FunctionScoreQueryBuilder<span class="token punctuation">.</span>FilterFunctionBuilder</span><span class="token punctuation">(</span>                <span class="token comment">// 过滤条件</span>                <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"isAD"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// 算分函数</span>                <span class="token class-name">ScoreFunctionBuilders</span><span class="token punctuation">.</span><span class="token function">weightFactorFunction</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>functionScoreQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch使用01</title>
      <link href="/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E01/"/>
      <url>/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E01/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎01–-elasticsearch基础"><a href="#分布式搜索引擎01–-elasticsearch基础" class="headerlink" title="分布式搜索引擎01– elasticsearch基础"></a>分布式搜索引擎01– elasticsearch基础</h1><h1 id="1-初识elasticsearch"><a href="#1-初识elasticsearch" class="headerlink" title="1.初识elasticsearch"></a>1.初识elasticsearch</h1><h2 id="1-1-了解ES"><a href="#1-1-了解ES" class="headerlink" title="1.1.了解ES"></a>1.1.了解ES</h2><h3 id="1-1-1-elasticsearch的作用"><a href="#1-1-1-elasticsearch的作用" class="headerlink" title="1.1.1.elasticsearch的作用"></a>1.1.1.elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p><p>例如：</p><ul><li><p>在GitHub搜索代码</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumdeqj5j20pn08g75i.jpg" alt="image-20210720193623245"></p></li><li><p>在电商网站搜索商品</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumen5b4j20os0b50uj.jpg" alt="image-20210720193633483"></p></li><li><p>在百度搜索答案</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumfhl3xj20jh0ahjt3.jpg" alt="image-20210720193641907"></p></li><li><p>在打车软件搜索附近的车</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumhx9y4j20870dy0ta.jpg" alt="image-20210720193648044"></p></li></ul><h3 id="1-1-2-ELK技术栈"><a href="#1-1-2-ELK技术栈" class="headerlink" title="1.1.2.ELK技术栈"></a>1.1.2.ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumk6t65j20n90d6dh2.jpg" alt="image-20210720194008781"></p><p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuml327oj20pt0f975d.jpg" alt="image-20210720194230265"></p><h3 id="1-1-3-elasticsearch和lucene"><a href="#1-1-3-elasticsearch和lucene" class="headerlink" title="1.1.3.elasticsearch和lucene"></a>1.1.3.elasticsearch和lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumnrmyrj21460haq4q.jpg" alt="image-20210720194547780"></p><p><strong>elasticsearch</strong>的发展历史：</p><ul><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uump9mh3j213g0fmabx.jpg" alt="image-20210720195001221"></p><h3 id="1-1-4-为什么不是其他搜索技术？"><a href="#1-1-4-为什么不是其他搜索技术？" class="headerlink" title="1.1.4.为什么不是其他搜索技术？"></a>1.1.4.为什么不是其他搜索技术？</h3><p>目前比较知名的搜索引擎技术排名：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumqw32gj20j609ign9.jpg" alt="image-20210720195142535"></p><p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumrob09j20qf0g7aaz.jpg" alt="image-20210720195306484"></p><h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>什么是elasticsearch？</p><ul><li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li></ul><p>什么是elastic stack（ELK）？</p><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><p>什么是Lucene？</p><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h2 id="1-2-倒排索引"><a href="#1-2-倒排索引" class="headerlink" title="1.2.倒排索引"></a>1.2.倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="1-2-1-正向索引"><a href="#1-2-1-正向索引" class="headerlink" title="1.2.1.正向索引"></a>1.2.1.正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumwqm9xj213o0hhmyp.jpg" alt="image-20210720195531539"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code></p><p>2）逐行获取数据，比如id为1的数据</p><p>3）判断数据中的title是否符合用户搜索条件</p><p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h3 id="1-2-2-倒排索引"><a href="#1-2-2-倒排索引" class="headerlink" title="1.2.2.倒排索引"></a>1.2.2.倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uumzm1qmj20t60ai0tp.jpg" alt="image-20210720200457207"></p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p><p>4）拿着文档id到正向索引中查找具体文档。</p><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uun0ntbpj20w60jhwgv.jpg" alt="image-20210720201115192"></p><p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p><h3 id="1-2-3-正向和倒排"><a href="#1-2-3-正向和倒排" class="headerlink" title="1.2.3.正向和倒排"></a>1.2.3.正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p></li><li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p></li></ul><p>是不是恰好反过来了？</p><p>那么两者方式的优缺点是什么呢？</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="1-3-es的一些概念"><a href="#1-3-es的一些概念" class="headerlink" title="1.3.es的一些概念"></a>1.3.es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="1-3-1-文档和字段"><a href="#1-3-1-文档和字段" class="headerlink" title="1.3.1.文档和字段"></a>1.3.1.文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uun2wc2gj211p0fign7.jpg" alt="image-20210720202707797"></p><p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h3 id="1-3-2-索引和映射"><a href="#1-3-2-索引和映射" class="headerlink" title="1.3.2.索引和映射"></a>1.3.2.索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uun4vo5tj21570g676f.jpg" alt="image-20210720203022172"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="1-3-3-mysql与elasticsearch"><a href="#1-3-3-mysql与elasticsearch" class="headerlink" title="1.3.3.mysql与elasticsearch"></a>1.3.3.mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p><p>并不是如此，两者各自有自己的擅长支出：</p><ul><li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p></li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uun75nhkj20qn09njrp.jpg" alt="image-20210720203534945"></p><h2 id="1-4-安装es、kibana"><a href="#1-4-安装es、kibana" class="headerlink" title="1.4.安装es、kibana"></a>1.4.安装es、kibana</h2><h3 id="1-4-1-安装"><a href="#1-4-1-安装" class="headerlink" title="1.4.1.安装"></a>1.4.1.安装</h3><h3 id="1-4-2-分词器"><a href="#1-4-2-分词器" class="headerlink" title="1.4.2.分词器"></a>1.4.2.分词器</h3><blockquote><p>参考安装ElasticSearch文章 </p></blockquote><h3 id="1-4-3-总结"><a href="#1-4-3-总结" class="headerlink" title="1.4.3.总结"></a>1.4.3.总结</h3><p>分词器的作用是什么？</p><ul><li>创建倒排索引时对文档分词</li><li>用户搜索时，对输入的内容分词</li></ul><p>IK分词器有几种模式？</p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>IK分词器如何拓展词条？如何停用词条？</p><ul><li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li><li>在词典中添加拓展词条或者停用词条</li></ul><h1 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2.索引库操作"></a>2.索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p><h2 id="2-1-mapping映射属性"><a href="#2-1-mapping映射属性" class="headerlink" title="2.1.mapping映射属性"></a>2.1.mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">21</span><span class="token punctuation">,</span>    <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">52.1</span><span class="token punctuation">,</span>    <span class="token property">"isMarried"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"info"</span><span class="token operator">:</span> <span class="token string">"黑马程序员Java讲师"</span><span class="token punctuation">,</span>    <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"zy@itcast.cn"</span><span class="token punctuation">,</span>    <span class="token property">"score"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">99.1</span><span class="token punctuation">,</span> <span class="token number">99.5</span><span class="token punctuation">,</span> <span class="token number">98.9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"firstName"</span><span class="token operator">:</span> <span class="token string">"云"</span><span class="token punctuation">,</span>        <span class="token property">"lastName"</span><span class="token operator">:</span> <span class="token string">"赵"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h2 id="2-2-索引库的CRUD"><a href="#2-2-索引库的CRUD" class="headerlink" title="2.2.索引库的CRUD"></a>2.2.索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p><h3 id="2-2-1-创建索引库和映射"><a href="#2-2-1-创建索引库和映射" class="headerlink" title="2.2.1.创建索引库和映射"></a>2.2.1.创建索引库和映射</h3><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /索引库名称<span class="token punctuation">&#123;</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"字段名"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_smart"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"字段名2"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"false"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"字段名3"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"object"</span><span class="token punctuation">,</span>        <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"子字段"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>     <span class="token comment">// ...略</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#创建索引库PUT &#x2F;heima&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;        &quot;info&quot;:&#123;            &quot;type&quot;: &quot;text&quot;,            &quot;analyzer&quot;: &quot;ik_smart&quot;        &#125;,        &quot;email&quot;:&#123;          &quot;type&quot;: &quot;keyword&quot;,          &quot;index&quot;: false        &#125;,        &quot;name&quot;:&#123;          &quot;type&quot;: &quot;object&quot;,           &quot;properties&quot;: &#123;              &quot;firstName&quot;:&#123;                  &quot;type&quot;:&quot;keyword&quot;              &#125;,              &quot;lastName&quot;:&#123;                   &quot;type&quot;:&quot;keyword&quot;              &#125;          &#125;        &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果截图</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuonqr3oj212k0gxgnq.jpg" alt="1646668293597"></p><h3 id="2-2-2-查询索引库"><a href="#2-2-2-查询索引库" class="headerlink" title="2.2.2.查询索引库"></a>2.2.2.查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：&#x2F;索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式</strong>：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;索引库名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuopgtq8j20oc0dqab6.jpg" alt="image-20210720211019329"></p><h3 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3.修改索引库"></a>2.2.3.修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /索引库名/_mapping<span class="token punctuation">&#123;</span>  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"新字段名"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuos38kaj20ss06qmxp.jpg" alt="image-20210720212357390"></p><h3 id="2-2-4-删除索引库"><a href="#2-2-4-删除索引库" class="headerlink" title="2.2.4.删除索引库"></a>2.2.4.删除索引库</h3><p><strong>语法：</strong></p><ul><li><p>请求方式：DELETE</p></li><li><p>请求路径：&#x2F;索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式：</strong></p><pre class="line-numbers language-none"><code class="language-none">DELETE &#x2F;索引库名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在kibana中测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuouokshj20wc05bjrp.jpg" alt="image-20210720212123420"></p><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5.总结"></a>2.2.5.总结</h3><p>索引库操作有哪些？</p><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h1><h2 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1.新增文档"></a>3.1.新增文档</h2><p><strong>语法：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /索引库名/_doc/文档id<span class="token punctuation">&#123;</span>    <span class="token property">"字段1"</span><span class="token operator">:</span> <span class="token string">"值1"</span><span class="token punctuation">,</span>    <span class="token property">"字段2"</span><span class="token operator">:</span> <span class="token string">"值2"</span><span class="token punctuation">,</span>    <span class="token property">"字段3"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"子属性1"</span><span class="token operator">:</span> <span class="token string">"值3"</span><span class="token punctuation">,</span>        <span class="token property">"子属性2"</span><span class="token operator">:</span> <span class="token string">"值4"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /heima/_doc/<span class="token number">1</span><span class="token punctuation">&#123;</span>    <span class="token property">"info"</span><span class="token operator">:</span> <span class="token string">"黑马程序员Java讲师"</span><span class="token punctuation">,</span>    <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"zy@itcast.cn"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"firstName"</span><span class="token operator">:</span> <span class="token string">"云"</span><span class="token punctuation">,</span>        <span class="token property">"lastName"</span><span class="token operator">:</span> <span class="token string">"赵"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>响应：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuowl9svj20qo09qt9q.jpg" alt="image-20210720212933362"></p><h2 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2.查询文档"></a>3.2.查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><p><strong>语法：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /<span class="token punctuation">&#123;</span>索引库名称<span class="token punctuation">&#125;</span>/_doc/<span class="token punctuation">&#123;</span>id<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>通过kibana查看数据：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">GET</span> <span class="token operator">/</span>heima<span class="token operator">/</span>_doc<span class="token operator">/</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看结果：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uup0c1z6j20xj0bmt9n.jpg" alt="image-20210720213345003"></p><h2 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3.删除文档"></a>3.3.删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">DELETE</span> <span class="token operator">/</span><span class="token punctuation">&#123;</span>索引库名<span class="token punctuation">&#125;</span><span class="token operator">/</span>_doc<span class="token operator">/</span>id值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"># 根据id删除数据DELETE /heima/_doc/<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uup2ng0uj20sn09et9f.jpg" alt="image-20210720213634918"></p><h2 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4.修改文档"></a>3.4.修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h3 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1.全量修改"></a>3.4.1.全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /<span class="token punctuation">&#123;</span>索引库名<span class="token punctuation">&#125;</span>/_doc/文档id<span class="token punctuation">&#123;</span>    <span class="token property">"字段1"</span><span class="token operator">:</span> <span class="token string">"值1"</span><span class="token punctuation">,</span>    <span class="token property">"字段2"</span><span class="token operator">:</span> <span class="token string">"值2"</span><span class="token punctuation">,</span>    <span class="token comment">// ... 略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /heima/_doc/<span class="token number">1</span><span class="token punctuation">&#123;</span>  <span class="token property">"info"</span><span class="token operator">:</span><span class="token string">"黑马程序员高级Java讲师"</span><span class="token punctuation">,</span>  <span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"zy@itcast.cn"</span><span class="token punctuation">,</span>  <span class="token property">"name"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"firstName"</span><span class="token operator">:</span><span class="token string">"云"</span><span class="token punctuation">,</span>    <span class="token property">"lastName"</span><span class="token operator">:</span><span class="token string">"赵"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-增量修改"><a href="#3-4-2-增量修改" class="headerlink" title="3.4.2.增量修改"></a>3.4.2.增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /<span class="token punctuation">&#123;</span>索引库名<span class="token punctuation">&#125;</span>/_update/文档id<span class="token punctuation">&#123;</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>         <span class="token property">"字段名"</span><span class="token operator">:</span> <span class="token string">"新的值"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /heima/_update/<span class="token number">1</span><span class="token punctuation">&#123;</span>  <span class="token property">"doc"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"ZhaoYun@itcast.cn"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-查询全部文档"><a href="#3-5-查询全部文档" class="headerlink" title="3.5 查询全部文档"></a>3.5 查询全部文档</h2><p>查看当前索引库中所有的文档，查询用GET请求</p><p>语法：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /<span class="token punctuation">&#123;</span>索引库名称<span class="token punctuation">&#125;</span>/_search<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET heima/_search<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uup7s5hxj20dm0hz75t.jpg" alt="1646670314636"></p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6.总结"></a>3.6.总结</h2><p>文档操作有哪些？</p><ul><li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id   { json文档 }</li><li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>修改文档：<ul><li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li><li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li></ul></li></ul><h1 id="4-RestClient-操作索引库"><a href="#4-RestClient-操作索引库" class="headerlink" title="4.RestClient 操作索引库"></a>4.RestClient 操作索引库</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uupa522ij214k0dmjtn.jpg" alt="image-20210720214555863"></p><p>我们学习的是Java HighLevel Rest Client客户端API</p><h2 id="4-0-导入Demo工程"><a href="#4-0-导入Demo工程" class="headerlink" title="4.0.导入Demo工程"></a>4.0.导入Demo工程</h2><h3 id="4-0-1-导入数据"><a href="#4-0-1-导入数据" class="headerlink" title="4.0.1.导入数据"></a>4.0.1.导入数据</h3><p>首先导入课前资料提供的数据库数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqzxb2ij204h02t744.jpg" alt="image-20210720220400297"> </p><p>数据结构如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tb_hotel<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店名称；例：7天酒店'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店地址；例：航头路'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>price<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店价格；例：329'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店评分；例：45，就是4.5分'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>brand<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店品牌；例：如家'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'所在城市；例：上海'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>star_name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店星级，从低到高分别是：1星到5星，1钻到5钻'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>business<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'商圈；例：虹桥'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>latitude<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'纬度；例：31.2497'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>longitude<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'经度；例：120.3925'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>pic<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'酒店图片；例:/img/1.jpg'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-0-2-导入项目"><a href="#4-0-2-导入项目" class="headerlink" title="4.0.2.导入项目"></a>4.0.2.导入项目</h3><p>然后导入课前资料提供的项目:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqxl82bj203d03wjr7.jpg" alt="image-20210720220503411"> </p><p>项目结构如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuquvxy5j210f0getbn.jpg" alt="image-20210720220647541"></p><h3 id="4-0-3-mapping映射分析"><a href="#4-0-3-mapping映射分析" class="headerlink" title="4.0.3.mapping映射分析"></a>4.0.3.mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用ik_max_word</li></ul><p>来看下酒店数据的索引库结构:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /hotel<span class="token punctuation">&#123;</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"name"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"address"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"price"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"score"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"brand"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"city"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"starName"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"business"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"location"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"geo_point"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"pic"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"all"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p>地理坐标说明：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqsgfnaj213906hwfh.jpg" alt="image-20210720222110126"></p><p>copy_to说明：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuq2skklj20r20ae3zc.jpg" alt="image-20210720222221516"></p><h3 id="4-0-4-初始化RestClient"><a href="#4-0-4-初始化RestClient" class="headerlink" title="4.0.4.初始化RestClient"></a>4.0.4.初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>分为三步：</p><p>1）引入es的RestHighLevelClient依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.elasticsearch.client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>elasticsearch-rest-high-level-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elasticsearch.version</span><span class="token punctuation">></span></span>7.12.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elasticsearch.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3）初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RestHighLevelClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span><span class="token class-name">RestClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>        <span class="token class-name">HttpHost</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://192.168.150.101:9200"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpHost</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestHighLevelClient</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">AfterEach</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">BeforeEach</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelIndexTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">RestHighLevelClient</span> client<span class="token punctuation">;</span>        <span class="token comment">//测试是否连上ES</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span><span class="token class-name">RestClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>                <span class="token class-name">HttpHost</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://192.168.150.101:9200"</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@AfterEach</span>    <span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;注意：在测试类中点击测试@Test的方法，启动发现会报错&#x3D;&#x3D;</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqos4myj20wu02mwf8.jpg" alt="1646674375714"></p><p>&#x3D;&#x3D;解决办法：&#x3D;&#x3D;</p><p>在pom.xml中的引入ES的依赖中排除这几个jackson的依赖即可</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.elasticsearch.client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>elasticsearch-rest-high-level-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-smile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-yaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-cbor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1-创建索引库"><a href="#4-1-创建索引库" class="headerlink" title="4.1.创建索引库"></a>4.1.创建索引库</h2><h3 id="4-1-1-代码解读"><a href="#4-1-1-代码解读" class="headerlink" title="4.1.1.代码解读"></a>4.1.1.代码解读</h3><p>创建索引库的API如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuq53oftj213m0l10xf.jpg" alt="image-20210720223049408"></p><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h3 id="4-1-2-完整示例"><a href="#4-1-2-完整示例" class="headerlink" title="4.1.2.完整示例"></a>4.1.2.完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>constants</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelConstants</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MAPPING_TEMPLATE <span class="token operator">=</span> <span class="token string">"&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"  \"mappings\": &#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"    \"properties\": &#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"id\": &#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"name\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"text\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"analyzer\": \"ik_max_word\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"copy_to\": \"all\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"address\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"index\": false\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"price\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"integer\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"score\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"integer\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"brand\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"copy_to\": \"all\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"city\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"copy_to\": \"all\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"starName\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"business\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"location\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"geo_point\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"pic\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"keyword\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"index\": false\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"      \"all\":&#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"type\": \"text\",\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"analyzer\": \"ik_max_word\"\n"</span> <span class="token operator">+</span>            <span class="token string">"      &#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"    &#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"  &#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"&#125;"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">createHotelIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.创建Request对象</span>    <span class="token class-name">CreateIndexRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateIndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备请求的参数：DSL语句</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>MAPPING_TEMPLATE<span class="token punctuation">,</span> <span class="token class-name">XContentType</span><span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;注意：CreateIndexRequest的包必须是import org.elasticsearch.client.indices.CreateIndexRequest;&#x3D;&#x3D;</p><h2 id="4-2-删除索引库"><a href="#4-2-删除索引库" class="headerlink" title="4.2.删除索引库"></a>4.2.删除索引库</h2><p>删除索引库的DSL语句非常简单：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE /hotel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testDeleteHotelIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.创建Request对象</span>    <span class="token class-name">DeleteIndexRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeleteIndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-判断索引库是否存在"><a href="#4-3-判断索引库是否存在" class="headerlink" title="4.3.判断索引库是否存在"></a>4.3.判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此与删除的Java代码流程是类似的。依然是三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testExistsHotelIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.创建Request对象</span>    <span class="token class-name">GetIndexRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetIndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.发送请求</span>    <span class="token keyword">boolean</span> exists <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.输出</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>exists <span class="token operator">?</span> <span class="token string">"索引库已经存在！"</span> <span class="token operator">:</span> <span class="token string">"索引库不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4.总结"></a>4.4.总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h1 id="5-RestClient操作文档"><a href="#5-RestClient操作文档" class="headerlink" title="5.RestClient操作文档"></a>5.RestClient操作文档</h1><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p><ul><li>初始化RestHighLevelClient</li><li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span></span><span class="token class-name">Hotel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">IHotelService</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">AfterEach</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">BeforeEach</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelDocumentTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">IHotelService</span> hotelService<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">RestHighLevelClient</span> client<span class="token punctuation">;</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span><span class="token class-name">RestClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>                <span class="token class-name">HttpHost</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://192.168.150.101:9200"</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@AfterEach</span>    <span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-1-新增文档"><a href="#5-1-新增文档" class="headerlink" title="5.1.新增文档"></a>5.1.新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><h3 id="5-1-1-索引库实体类"><a href="#5-1-1-索引库实体类" class="headerlink" title="5.1.1.索引库实体类"></a>5.1.1.索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"tb_hotel"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hotel</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span>INPUT<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> business<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> longitude<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> latitude<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> pic<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelDoc</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> business<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> pic<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span><span class="token class-name">Hotel</span> hotel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>starName <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>business <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBusiness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>location <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getLatitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> hotel<span class="token punctuation">.</span><span class="token function">getLongitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pic <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-2-语法说明"><a href="#5-1-2-语法说明" class="headerlink" title="5.1.2.语法说明"></a>5.1.2.语法说明</h3><p>新增文档的DSL语句如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /<span class="token punctuation">&#123;</span>索引库名<span class="token punctuation">&#125;</span>/_doc/<span class="token number">1</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>    <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">21</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的java代码如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuq7edxkj215i0b1dig.jpg" alt="image-20210720230027240"></p><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求</li></ul><p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p><h3 id="5-1-3-完整代码"><a href="#5-1-3-完整代码" class="headerlink" title="5.1.3.完整代码"></a>5.1.3.完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li><li>hotel对象需要转为HotelDoc对象</li><li>HotelDoc需要序列化为json格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）根据id查询酒店数据Hotel</li><li>2）将Hotel封装为HotelDoc</li><li>3）将HotelDoc序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testAddDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.根据id查询酒店数据</span>    <span class="token class-name">Hotel</span> hotel <span class="token operator">=</span> hotelService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span><span class="token number">61083L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.转换为文档类型</span>    <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span>hotel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.将HotelDoc转json</span>    <span class="token class-name">String</span> json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1.准备Request对象</span>    <span class="token class-name">IndexRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备Json文档</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">XContentType</span><span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-查询文档"><a href="#5-2-查询文档" class="headerlink" title="5.2.查询文档"></a>5.2.查询文档</h2><h3 id="5-2-1-语法说明"><a href="#5-2-1-语法说明" class="headerlink" title="5.2.1.语法说明"></a>5.2.1.语法说明</h3><p>查询的DSL语句如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_doc/<span class="token punctuation">&#123;</span>id<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuq99cwaj213k0emwhf.jpg" alt="image-20210720230811674"></p><p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是GetRequest</li><li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>3）解析结果，就是对JSON做反序列化</li></ul><h3 id="5-2-2-完整代码"><a href="#5-2-2-完整代码" class="headerlink" title="5.2.2.完整代码"></a>5.2.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testGetDocumentById</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">GetRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">,</span> <span class="token string">"61082"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.发送请求，得到响应</span>    <span class="token class-name">GetResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.解析响应结果</span>    <span class="token class-name">String</span> json <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-删除文档"><a href="#5-3-删除文档" class="headerlink" title="5.3.删除文档"></a>5.3.删除文档</h2><p>删除的DSL为是这样的：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE /hotel/_doc/<span class="token punctuation">&#123;</span>id<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testDeleteDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">DeleteRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeleteRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">,</span> <span class="token string">"61083"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-修改文档"><a href="#5-4-修改文档" class="headerlink" title="5.4.修改文档"></a>5.4.修改文档</h2><h3 id="5-4-1-语法说明"><a href="#5-4-1-语法说明" class="headerlink" title="5.4.1.语法说明"></a>5.4.1.语法说明</h3><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><p>代码示例如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqblbj2j211x0crgny.jpg" alt="image-20210720231040875"></p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是UpdateRequest</li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><h3 id="5-4-2-完整代码"><a href="#5-4-2-完整代码" class="headerlink" title="5.4.2.完整代码"></a>5.4.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testUpdateDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.准备Request</span>    <span class="token class-name">UpdateRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UpdateRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">,</span> <span class="token string">"61083"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备请求参数</span>    request<span class="token punctuation">.</span><span class="token function">doc</span><span class="token punctuation">(</span>        <span class="token string">"price"</span><span class="token punctuation">,</span> <span class="token string">"952"</span><span class="token punctuation">,</span>        <span class="token string">"starName"</span><span class="token punctuation">,</span> <span class="token string">"四钻"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5-批量导入文档"><a href="#5-5-批量导入文档" class="headerlink" title="5.5.批量导入文档"></a>5.5.批量导入文档</h2><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li><p>利用mybatis-plus查询酒店数据</p></li><li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p></li><li><p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p></li></ul><h3 id="5-5-1-语法说明"><a href="#5-5-1-语法说明" class="headerlink" title="5.5.1.语法说明"></a>5.5.1.语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqeda1fj20m308nmz5.jpg" alt="image-20210720232105943"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuqczi2oj20t50b1tay.jpg" alt="image-20210720232431383"></p><p>其实还是三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><h3 id="5-5-2-完整代码"><a href="#5-5-2-完整代码" class="headerlink" title="5.5.2.完整代码"></a>5.5.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testBulkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 批量查询酒店数据</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Hotel</span><span class="token punctuation">></span></span> hotels <span class="token operator">=</span> hotelService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1.创建Request</span>    <span class="token class-name">BulkRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BulkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.准备参数，添加多个新增的Request</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Hotel</span> hotel <span class="token operator">:</span> hotels<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 2.1.转换为文档类型HotelDoc</span>        <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span>hotel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2.创建新增文档的Request对象</span>        request<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">XContentType</span><span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3.发送请求</span>    client<span class="token punctuation">.</span><span class="token function">bulk</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6.小结"></a>5.6.小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch使用03</title>
      <link href="/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/"/>
      <url>/2022/06/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎03"><a href="#分布式搜索引擎03" class="headerlink" title="分布式搜索引擎03"></a>分布式搜索引擎03</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-数据聚合"><a href="#1-数据聚合" class="headerlink" title="1.数据聚合"></a>1.数据聚合</h1><p>**<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="1-1-聚合的种类"><a href="#1-1-聚合的种类" class="headerlink" title="1.1.聚合的种类"></a>1.1.聚合的种类</h2><p>聚合常见的有三类：</p><ul><li><p><strong>桶（Bucket）</strong>聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><p><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p><strong>注意：</strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><h2 id="1-2-DSL实现聚合"><a href="#1-2-DSL实现聚合" class="headerlink" title="1.2.DSL实现聚合"></a>1.2.DSL实现聚合</h2><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h3 id="1-2-1-Bucket聚合语法"><a href="#1-2-1-Bucket聚合语法" class="headerlink" title="1.2.1.Bucket聚合语法"></a>1.2.1.Bucket聚合语法</h3><p>语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span>  <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 定义聚合</span>    <span class="token property">"brandAgg"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">//给聚合起个名字</span>      <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 聚合的类型，按照品牌值聚合，所以选择term</span>        <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"brand"</span><span class="token punctuation">,</span> <span class="token comment">// 参与聚合的字段</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token comment">// 希望获取的聚合结果数量</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvauja6dj20hs0g9dhe.jpg" alt="image-20210723171948228"></p><h3 id="1-2-2-聚合结果排序"><a href="#1-2-2-聚合结果排序" class="headerlink" title="1.2.2.聚合结果排序"></a>1.2.2.聚合结果排序</h3><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"brandAgg"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"brand"</span><span class="token punctuation">,</span>        <span class="token property">"order"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"_count"</span><span class="token operator">:</span> <span class="token string">"asc"</span> <span class="token comment">// 按照_count升序排列</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">20</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-限定聚合范围"><a href="#1-2-3-限定聚合范围" class="headerlink" title="1.2.3.限定聚合范围"></a>1.2.3.限定聚合范围</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"price"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">200</span> <span class="token comment">// 只对200元以下的文档聚合</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"brandAgg"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"brand"</span><span class="token punctuation">,</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">20</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次，聚合得到的品牌明显变少了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvawv874j210k0d7dhw.jpg" alt="image-20210723172404836"></p><h3 id="1-2-4-Metric聚合语法"><a href="#1-2-4-Metric聚合语法" class="headerlink" title="1.2.4.Metric聚合语法"></a>1.2.4.Metric聚合语法</h3><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET /hotel/_search<span class="token punctuation">&#123;</span>  <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"brandAgg"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>       <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>         <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"brand"</span><span class="token punctuation">,</span>         <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">20</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"aggs"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span>        <span class="token property">"score_stats"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 聚合名称</span>          <span class="token property">"stats"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 聚合类型，这里stats可以计算min、max、avg等</span>            <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"score"</span> <span class="token comment">// 聚合字段，这里是score</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvay9gmuj20zy0gpq5g.jpg" alt="image-20210723172917636"></p><h3 id="1-2-5-小结"><a href="#1-2-5-小结" class="headerlink" title="1.2.5.小结"></a>1.2.5.小结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="1-3-RestAPI实现聚合"><a href="#1-3-RestAPI实现聚合" class="headerlink" title="1.3.RestAPI实现聚合"></a>1.3.RestAPI实现聚合</h2><h3 id="1-3-1-API语法"><a href="#1-3-1-API语法" class="headerlink" title="1.3.1.API语法"></a>1.3.1.API语法</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p><p>聚合条件的语法：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb02abnj210v0g7tb7.jpg" alt="image-20210723173057733"></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb1cu59j213z0jwdkc.jpg" alt="image-20210723173215728"></p><h3 id="1-3-2-业务需求"><a href="#1-3-2-业务需求" class="headerlink" title="1.3.2.业务需求"></a>1.3.2.业务需求</h3><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb3gp4lj20nx06rdgd.jpg" alt="image-20210723192605566"></p><p>分析：</p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb4p3npj20fv099mxt.jpg" alt="image-20210723193730799"></p><p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb5j6tqj20tn0823zo.jpg" alt="image-20210723203915982"></p><p>结果是一个Map结构：</p><ul><li>key是字符串，城市、星级、品牌、价格</li><li>value是集合，例如多个城市的名称</li></ul><h3 id="1-3-3-业务实现"><a href="#1-3-3-业务实现" class="headerlink" title="1.3.3.业务实现"></a>1.3.3.业务实现</h3><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"filters"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">getFilters</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> hotelService<span class="token punctuation">.</span><span class="token function">getFilters</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">filters</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">filters</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.准备Request</span>        <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.准备DSL</span>        <span class="token comment">// 2.1.query</span>        <span class="token function">buildBasicQuery</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2.设置size</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.3.聚合</span>        <span class="token function">buildAggregation</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.发出请求</span>        <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.解析结果</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Aggregations</span> aggregations <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getAggregations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.1.根据品牌名称，获取品牌结果</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> brandList <span class="token operator">=</span> <span class="token function">getAggByName</span><span class="token punctuation">(</span>aggregations<span class="token punctuation">,</span> <span class="token string">"brandAgg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"brand"</span><span class="token punctuation">,</span> brandList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.2.根据品牌名称，获取品牌结果</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> cityList <span class="token operator">=</span> <span class="token function">getAggByName</span><span class="token punctuation">(</span>aggregations<span class="token punctuation">,</span> <span class="token string">"cityAgg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">,</span> cityList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.3.根据品牌名称，获取品牌结果</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> starList <span class="token operator">=</span> <span class="token function">getAggByName</span><span class="token punctuation">(</span>aggregations<span class="token punctuation">,</span> <span class="token string">"starAgg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"starName"</span><span class="token punctuation">,</span> starList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildAggregation</span><span class="token punctuation">(</span><span class="token class-name">SearchRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aggregation</span><span class="token punctuation">(</span><span class="token class-name">AggregationBuilders</span>                                 <span class="token punctuation">.</span><span class="token function">terms</span><span class="token punctuation">(</span><span class="token string">"brandAgg"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"brand"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>                                <span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aggregation</span><span class="token punctuation">(</span><span class="token class-name">AggregationBuilders</span>                                 <span class="token punctuation">.</span><span class="token function">terms</span><span class="token punctuation">(</span><span class="token string">"cityAgg"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>                                <span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aggregation</span><span class="token punctuation">(</span><span class="token class-name">AggregationBuilders</span>                                 <span class="token punctuation">.</span><span class="token function">terms</span><span class="token punctuation">(</span><span class="token string">"starAgg"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">"starName"</span><span class="token punctuation">)</span>                                 <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>                                <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getAggByName</span><span class="token punctuation">(</span><span class="token class-name">Aggregations</span> aggregations<span class="token punctuation">,</span> <span class="token class-name">String</span> aggName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 4.1.根据聚合名称获取聚合结果</span>    <span class="token class-name">Terms</span> brandTerms <span class="token operator">=</span> aggregations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>aggName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.2.获取buckets</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Terms<span class="token punctuation">.</span>Bucket</span><span class="token punctuation">></span></span> buckets <span class="token operator">=</span> brandTerms<span class="token punctuation">.</span><span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.3.遍历</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> brandList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Terms<span class="token punctuation">.</span>Bucket</span> bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 4.4.获取key</span>        <span class="token class-name">String</span> key <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">getKeyAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        brandList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> brandList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/**     * 查询条件抽取     * @param params     * @param searchReuqest     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildBasicQuery</span><span class="token punctuation">(</span><span class="token class-name">RequestParams</span> params<span class="token punctuation">,</span><span class="token class-name">SearchRequest</span> searchReuqest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//采用布尔查询的操作，实现多条件查询</span>        <span class="token class-name">BoolQueryBuilder</span> boolQuery <span class="token operator">=</span> <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">boolQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.1 根据关键字查询</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">must</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span>params<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3.2 条件过滤</span>        <span class="token comment">//1.城市精确查询</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">,</span>params<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//2.品牌</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"brand"</span><span class="token punctuation">,</span>params<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3.星级</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"starName"</span><span class="token punctuation">,</span>params<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4.价格区间</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            boolQuery<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">rangeQuery</span><span class="token punctuation">(</span><span class="token string">"price"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMinPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lte</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">getMaxPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//相关性算分</span>        <span class="token class-name">FunctionScoreQueryBuilder</span> scoreQueryBuilder <span class="token operator">=</span> <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">functionScoreQuery</span><span class="token punctuation">(</span>                boolQuery<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">FunctionScoreQueryBuilder<span class="token punctuation">.</span>FilterFunctionBuilder</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">new</span> <span class="token class-name">FunctionScoreQueryBuilder<span class="token punctuation">.</span>FilterFunctionBuilder</span><span class="token punctuation">(</span>                                <span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"isAD"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token class-name">ScoreFunctionBuilders</span><span class="token punctuation">.</span><span class="token function">weightFactorFunction</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                        <span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        searchReuqest<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>scoreQueryBuilder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2.自动补全"></a>2.自动补全</h1><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb8x5ydj20ue07dwez.jpg" alt="image-20210723204936367"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h2 id="2-1-拼音分词器"><a href="#2-1-拼音分词器" class="headerlink" title="2.1.拼音分词器"></a>2.1.拼音分词器</h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvb9ub9nj20q30c4wf7.jpg" alt="image-20210723205932746"></p><p>课前资料中也提供了拼音分词器的安装包：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbbuj1aj20bu07pmxo.jpg" alt="image-20210723205722303"> </p><p>安装方式与IK分词器一样，分三步：</p><p>​    ①解压</p><p>​    ②上传到虚拟机中，elasticsearch的plugin目录</p><p>​    ③重启elasticsearch</p><p>​    ④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST /_analyze<span class="token punctuation">&#123;</span>  <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"如家酒店还不错"</span><span class="token punctuation">,</span>  <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"pinyin"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbd67mdj20cg0g0q3w.jpg" alt="image-20210723210126506"> </p><h2 id="2-2-自定义分词器"><a href="#2-2-自定义分词器" class="headerlink" title="2.2.自定义分词器"></a>2.2.自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p>文档分词时会依次由这三部分来处理文档：</p><p>   <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbgfc7xj216z08ndh0.jpg" alt="image-20210723210427878"></p><p>声明自定义分词器的语法如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT /test<span class="token punctuation">&#123;</span>  <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"analysis"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自定义分词器</span>        <span class="token property">"my_analyzer"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分词器名称</span>          <span class="token property">"tokenizer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>          <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token string">"py"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自定义tokenizer filter</span>        <span class="token property">"py"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 过滤器名称</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"pinyin"</span><span class="token punctuation">,</span> <span class="token comment">// 过滤器类型，这里是pinyin</span>  <span class="token property">"keep_full_pinyin"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>          <span class="token property">"keep_joined_full_pinyin"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"keep_original"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"limit_first_letter_length"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>          <span class="token property">"remove_duplicated_term"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"none_chinese_pinyin_tokenize"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"my_analyzer"</span><span class="token punctuation">,</span>        <span class="token property">"search_analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_smart"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbhv0auj20vf0hrjt9.jpg" alt="image-20210723211829150"></p><p>总结：</p><p>如何使用拼音分词器？</p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h2 id="2-3-自动补全查询"><a href="#2-3-自动补全查询" class="headerlink" title="2.3.自动补全查询"></a>2.3.自动补全查询</h2><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 创建索引库</span>PUT test<span class="token punctuation">&#123;</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"title"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"completion"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后插入下面的数据：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 示例数据</span>POST test/_doc<span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Sony"</span><span class="token punctuation">,</span> <span class="token string">"WH-1000XM3"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>POST test/_doc<span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"SK-II"</span><span class="token punctuation">,</span> <span class="token string">"PITERA"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>POST test/_doc<span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Nintendo"</span><span class="token punctuation">,</span> <span class="token string">"switch"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询的DSL语句如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 自动补全查询</span>GET /test/_search<span class="token punctuation">&#123;</span>  <span class="token property">"suggest"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"title_suggest"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token comment">// 关键字</span>      <span class="token property">"completion"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"field"</span><span class="token operator">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token comment">// 补全查询的字段</span>        <span class="token property">"skip_duplicates"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 跳过重复的</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token comment">// 获取前10条结果</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-实现酒店搜索框自动补全"><a href="#2-4-实现酒店搜索框自动补全" class="headerlink" title="2.4.实现酒店搜索框自动补全"></a>2.4.实现酒店搜索框自动补全</h2><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h3 id="2-4-1-修改酒店映射结构"><a href="#2-4-1-修改酒店映射结构" class="headerlink" title="2.4.1.修改酒店映射结构"></a>2.4.1.修改酒店映射结构</h3><p>代码如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">// 酒店数据索引库</span>PUT /hotel<span class="token punctuation">&#123;</span>  <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"analysis"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"text_anlyzer"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"tokenizer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>          <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token string">"py"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token property">"completion_analyzer"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"tokenizer"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>          <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token string">"py"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"filter"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"py"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"pinyin"</span><span class="token punctuation">,</span>          <span class="token property">"keep_full_pinyin"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>          <span class="token property">"keep_joined_full_pinyin"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"keep_original"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"limit_first_letter_length"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>          <span class="token property">"remove_duplicated_term"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          <span class="token property">"none_chinese_pinyin_tokenize"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"id"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"name"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"text_anlyzer"</span><span class="token punctuation">,</span>        <span class="token property">"search_analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_smart"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"address"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"price"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"score"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"brand"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"city"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"starName"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"business"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token string">"all"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"location"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"geo_point"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"pic"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"all"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>        <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"text_anlyzer"</span><span class="token punctuation">,</span>        <span class="token property">"search_analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_smart"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"suggestion"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"completion"</span><span class="token punctuation">,</span>          <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"completion_analyzer"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-修改HotelDoc实体"><a href="#2-4-2-修改HotelDoc实体" class="headerlink" title="2.4.2.修改HotelDoc实体"></a>2.4.2.修改HotelDoc实体</h3><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>pojo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelDoc</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> brand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> starName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> business<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> pic<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> distance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Boolean</span> isAD<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> suggestion<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span><span class="token class-name">Hotel</span> hotel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>starName <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getStarName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>business <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getBusiness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>location <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getLatitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> hotel<span class="token punctuation">.</span><span class="token function">getLongitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pic <span class="token operator">=</span> hotel<span class="token punctuation">.</span><span class="token function">getPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 组装suggestion</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>business<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>business<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brand<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token punctuation">,</span>split<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>business<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"、"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>business<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"、"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brand<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>suggestion<span class="token punctuation">,</span>split<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>suggestion <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brand<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>business<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-重新导入"><a href="#2-4-3-重新导入" class="headerlink" title="2.4.3.重新导入"></a>2.4.3.重新导入</h3><p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbm13apj20k60badgz.jpg" alt="image-20210723213546183"></p><h3 id="2-4-4-自动补全查询的JavaAPI"><a href="#2-4-4-自动补全查询的JavaAPI" class="headerlink" title="2.4.4.自动补全查询的JavaAPI"></a>2.4.4.自动补全查询的JavaAPI</h3><p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbnpl5xj216c0h8jvn.jpg" alt="image-20210723213759922"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbodn0hj216c0kejvx.jpg" alt="image-20210723213917524"></p><h3 id="2-4-5-实现搜索框自动补全"><a href="#2-4-5-实现搜索框自动补全" class="headerlink" title="2.4.5.实现搜索框自动补全"></a>2.4.5.实现搜索框自动补全</h3><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbpbuwaj20h808tjs0.jpg" alt="image-20210723214021062"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"suggestion"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getSuggestions</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> hotelService<span class="token punctuation">.</span><span class="token function">getSuggestions</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getSuggestions</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getSuggestions</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.准备Request</span>        <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.准备DSL</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suggest</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SuggestBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addSuggestion</span><span class="token punctuation">(</span>            <span class="token string">"suggestions"</span><span class="token punctuation">,</span>            <span class="token class-name">SuggestBuilders</span><span class="token punctuation">.</span><span class="token function">completionSuggestion</span><span class="token punctuation">(</span><span class="token string">"suggestion"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">prefix</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">skipDuplicates</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.发起请求</span>        <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.解析结果</span>        <span class="token class-name">Suggest</span> suggest <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getSuggest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.1.根据补全查询名称，获取补全结果</span>        <span class="token class-name">CompletionSuggestion</span> suggestions <span class="token operator">=</span> suggest<span class="token punctuation">.</span><span class="token function">getSuggestion</span><span class="token punctuation">(</span><span class="token string">"suggestions"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.2.获取options</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CompletionSuggestion<span class="token punctuation">.</span>Entry<span class="token punctuation">.</span>Option</span><span class="token punctuation">></span></span> options <span class="token operator">=</span> suggestions<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.3.遍历</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>options<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">CompletionSuggestion<span class="token punctuation">.</span>Entry<span class="token punctuation">.</span>Option</span> option <span class="token operator">:</span> options<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> text <span class="token operator">=</span> option<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-数据同步"><a href="#3-数据同步" class="headerlink" title="3.数据同步"></a>3.数据同步</h1><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbr4sabj20x50a3jsf.jpg" alt="image-20210723214758392"></p><h2 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1.思路分析"></a>3.1.思路分析</h2><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听binlog</li></ul><h3 id="3-1-1-同步调用"><a href="#3-1-1-同步调用" class="headerlink" title="3.1.1.同步调用"></a>3.1.1.同步调用</h3><p>方案一：同步调用</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbslj4zj215o0esjsu.jpg" alt="image-20210723214931869"></p><p>基本步骤如下：</p><ul><li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li></ul><h3 id="3-1-2-异步通知"><a href="#3-1-2-异步通知" class="headerlink" title="3.1.2.异步通知"></a>3.1.2.异步通知</h3><p>方案二：异步通知</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbvfjvdj215r0il0ud.jpg" alt="image-20210723215140735"></p><p>流程如下：</p><ul><li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li><li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li></ul><h3 id="3-1-3-监听binlog"><a href="#3-1-3-监听binlog" class="headerlink" title="3.1.3.监听binlog"></a>3.1.3.监听binlog</h3><p>方案三：监听binlog</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbweapzj215c0fh760.jpg" alt="image-20210723215518541"></p><p>流程如下：</p><ul><li>给mysql开启binlog功能</li><li>mysql完成增、删、改操作都会记录在binlog中</li><li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li></ul><h3 id="3-1-4-选择"><a href="#3-1-4-选择" class="headerlink" title="3.1.4.选择"></a>3.1.4.选择</h3><p>方式一：同步调用</p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务耦合度高</li></ul><p>方式二：异步通知</p><ul><li>优点：低耦合，实现难度一般</li><li>缺点：依赖mq的可靠性</li></ul><p>方式三：监听binlog</p><ul><li>优点：完全解除服务间耦合</li><li>缺点：开启binlog增加数据库负担、实现复杂度高</li></ul><h2 id="3-2-实现数据同步"><a href="#3-2-实现数据同步" class="headerlink" title="3.2.实现数据同步"></a>3.2.实现数据同步</h2><h3 id="3-2-1-思路"><a href="#3-2-1-思路" class="headerlink" title="3.2.1.思路"></a>3.2.1.思路</h3><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h3 id="3-2-2-导入demo"><a href="#3-2-2-导入demo" class="headerlink" title="3.2.2.导入demo"></a>3.2.2.导入demo</h3><p>导入课前资料提供的hotel-admin项目：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvbzn0qtj20g306j3za.jpg" alt="image-20210723220237930"></p><p>运行后，访问 <a href="http://localhost:8099/">http://localhost:8099</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvc0j8s3j21340hf0uf.jpg" alt="image-20210723220354464"></p><p>其中包含了酒店的CRUD功能：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvc1es4xj20rh0il41o.jpg" alt="image-20210723220511090"></p><h3 id="3-2-3-声明交换机、队列"><a href="#3-2-3-声明交换机、队列" class="headerlink" title="3.2.3.声明交换机、队列"></a>3.2.3.声明交换机、队列</h3><p>MQ结构如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvc4bgguj211b0920u8.jpg" alt="image-20210723215850307"></p><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--amqp--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）声明队列交换机名称"><a href="#2）声明队列交换机名称" class="headerlink" title="2）声明队列交换机名称"></a>2）声明队列交换机名称</h4><p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>constatnts</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConstants</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 交换机     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> HOTEL_EXCHANGE <span class="token operator">=</span> <span class="token string">"hotel.topic"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 监听新增和修改的队列     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> HOTEL_INSERT_QUEUE <span class="token operator">=</span> <span class="token string">"hotel.insert.queue"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 监听删除的队列     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> HOTEL_DELETE_QUEUE <span class="token operator">=</span> <span class="token string">"hotel.delete.queue"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 新增或修改的RoutingKey     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> HOTEL_INSERT_KEY <span class="token operator">=</span> <span class="token string">"hotel.insert"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 删除的RoutingKey     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> HOTEL_DELETE_KEY <span class="token operator">=</span> <span class="token string">"hotel.delete"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）声明队列交换机"><a href="#3）声明队列交换机" class="headerlink" title="3）声明队列交换机"></a>3）声明队列交换机</h4><p>在hotel-demo中，定义配置类，声明队列、交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>constants<span class="token punctuation">.</span></span><span class="token class-name">MqConstants</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Binding</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">BindingBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Queue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">TopicExchange</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TopicExchange</span> <span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TopicExchange</span><span class="token punctuation">(</span><span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_EXCHANGE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">insertQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_INSERT_QUEUE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">deleteQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_DELETE_QUEUE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">insertQueueBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">insertQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_INSERT_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">deleteQueueBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">deleteQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_DELETE_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-4-发送MQ消息"><a href="#3-2-4-发送MQ消息" class="headerlink" title="3.2.4.发送MQ消息"></a>3.2.4.发送MQ消息</h3><p>在hotel-admin中的增、删、改业务中分别发送MQ消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvc6kbgqj21960ofn3u.jpg" alt="image-20210723221843816"></p><h3 id="3-2-5-接收MQ消息"><a href="#3-2-5-接收MQ消息" class="headerlink" title="3.2.5.接收MQ消息"></a>3.2.5.接收MQ消息</h3><p>hotel-demo接收到MQ消息要做的事情包括：</p><ul><li>新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库</li><li>删除消息：根据传递的hotel的id删除索引库中的一条数据</li></ul><p>1）首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中新增新增、删除业务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insertById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中实现业务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.准备Request</span>        <span class="token class-name">DeleteRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeleteRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">,</span> id<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.发送请求</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 0.根据id查询酒店数据</span>        <span class="token class-name">Hotel</span> hotel <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 转换为文档类型</span>        <span class="token class-name">HotelDoc</span> hotelDoc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HotelDoc</span><span class="token punctuation">(</span>hotel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.准备Request对象</span>        <span class="token class-name">IndexRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexRequest</span><span class="token punctuation">(</span><span class="token string">"hotel"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span>hotel<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.准备Json文档</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>hotelDoc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">XContentType</span><span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.发送请求</span>        client<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）编写监听器</p><p>在hotel-demo中的<code>cn.itcast.hotel.mq</code>包新增一个类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>mq</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>constants<span class="token punctuation">.</span></span><span class="token class-name">MqConstants</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>hotel<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">IHotelService</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RabbitListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotelListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">IHotelService</span> hotelService<span class="token punctuation">;</span>    <span class="token comment">/**     * 监听酒店新增或修改的业务     * @param id 酒店id     */</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_INSERT_QUEUE<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenHotelInsertOrUpdate</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        hotelService<span class="token punctuation">.</span><span class="token function">insertById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 监听酒店删除的业务     * @param id 酒店id     */</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">MqConstants</span><span class="token punctuation">.</span>HOTEL_DELETE_QUEUE<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenHotelDelete</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        hotelService<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-集群"><a href="#4-集群" class="headerlink" title="4.集群"></a>4.集群</h1><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica ）</li></ul><p><strong>ES集群相关概念</strong>:</p><ul><li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p></li><li><p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p></li><li><p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p><p>解决问题：数据量太大，单点存储量有限的问题。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvca3z26j20kj0ammxo.jpg" alt="image-20200104124440086"></p><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote></li><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p><p>​</p></li></ul><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcbv3zrj20n60l840n.jpg" alt="image-20200104124551912"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li>node0：保存了分片0和1</li><li>node1：保存了分片0和2</li><li>node2：保存了分片1和2</li></ul><h2 id="4-1-搭建ES集群"><a href="#4-1-搭建ES集群" class="headerlink" title="4.1.搭建ES集群"></a>4.1.搭建ES集群</h2><p>参考课前资料的文档：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcd36k2j20gs07g0tl.jpg" alt="image-20210723222732427"> </p><p>其中的第四章节：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcelojdj20bb09eq3i.jpg" alt="image-20210723222812619"> </p><h2 id="4-2-集群脑裂问题"><a href="#4-2-集群脑裂问题" class="headerlink" title="4.2.集群脑裂问题"></a>4.2.集群脑裂问题</h2><h3 id="4-2-1-集群职责划分"><a href="#4-2-1-集群职责划分" class="headerlink" title="4.2.1.集群职责划分"></a>4.2.1.集群职责划分</h3><p>elasticsearch中集群节点有不同的职责划分：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvch3lpfj21640ffgo5.jpg" alt="image-20210723223008967"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master节点：对CPU要求高，但是内存要求第</li><li>data节点：对CPU和内存要求都高</li><li>coordinating节点：对网络带宽、CPU要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的es集群职责划分如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvciai4bj216z0ibdi2.jpg" alt="image-20210723223629142"></p><h3 id="4-2-2-脑裂问题"><a href="#4-2-2-脑裂问题" class="headerlink" title="4.2.2.脑裂问题"></a>4.2.2.脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcl40daj21260dadgk.jpg" alt="image-20210723223804995"></p><p>此时，node2和node3认为node1宕机，就会重新选主：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvck85j2j211z0diwf7.jpg" alt="image-20210723223845754"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcmj803j211h09tdge.jpg" alt="image-20210723224000555"></p><p>解决脑裂的方案是，要求选票超过(master候选资格节点数量) &#x2F; 2 + 1才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="4-2-3-小结"><a href="#4-2-3-小结" class="headerlink" title="4.2.3.小结"></a>4.2.3.小结</h3><p>master eligible节点的作用是什么？</p><ul><li>参与集群选主</li><li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li></ul><p>data节点的作用是什么？</p><ul><li>数据的CRUD</li></ul><p>coordinator节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="4-3-集群分布式存储"><a href="#4-3-集群分布式存储" class="headerlink" title="4.3.集群分布式存储"></a>4.3.集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p><h3 id="4-3-1-分片存储测试"><a href="#4-3-1-分片存储测试" class="headerlink" title="4.3.1.分片存储测试"></a>4.3.1.分片存储测试</h3><p>插入三条数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcpdd9dj20pf098js3.jpg" alt="image-20210723225006058"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcq98xvj20nt08t3z7.jpg" alt="image-20210723225034637"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcr8hmrj20rk08jjs3.jpg" alt="image-20210723225112029"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvctih0kj20pl0biwfd.jpg" alt="image-20210723225227928"></p><p>结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvcx89tsj20h40j175f.jpg" alt="image-20210723225342120"></p><h3 id="4-3-2-分片存储原理"><a href="#4-3-2-分片存储原理" class="headerlink" title="4.3.2.分片存储原理"></a>4.3.2.分片存储原理</h3><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd0l85aj20i602aq2y.jpg" alt="image-20210723224354904"></p><p>说明：</p><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd21jijj218y0jrgnt.jpg" alt="image-20210723225436084"></p><p>解读：</p><ul><li>1）新增一个id&#x3D;1的文档</li><li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li><li>3）shard-2的主分片在node3节点，将数据路由到node3</li><li>4）保存文档</li><li>5）同步给shard-2的副本replica-2，在node2节点</li><li>6）返回结果给coordinating-node节点</li></ul><h2 id="4-4-集群分布式查询"><a href="#4-4-集群分布式查询" class="headerlink" title="4.4.集群分布式查询"></a>4.4.集群分布式查询</h2><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd3fnpwj20o90dbjsd.jpg" alt="image-20210723225809848"></p><h2 id="4-5-集群故障转移"><a href="#4-5-集群故障转移" class="headerlink" title="4.5.集群故障转移"></a>4.5.集群故障转移</h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd5atwzj213q0at3ze.jpg" alt="image-20210723225945963"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p>2）突然，node1发生了故障：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd5r1n6j21170a13zi.jpg" alt="image-20210723230020574"></p><p>宕机后的第一件事，需要重新选主，例如选中了node2：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd6p5lbj210s09mdgq.jpg" alt="image-20210723230055974"></p><p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uvd8abx9j211w0aogmt.jpg" alt="image-20210723230216642"></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch学习总结</title>
      <link href="/2022/06/02/Elasticsearch%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/02/Elasticsearch%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch版本控制"><a href="#Elasticsearch版本控制" class="headerlink" title="Elasticsearch版本控制"></a>Elasticsearch版本控制</h1><p><strong>1.为什么要进行版本控制CAS无锁</strong><br>为了保证数据再多线程操作下的准确性</p><p><strong>2.悲观锁和乐观锁</strong><br>悲观锁：假设会发生并发冲突，屏蔽一切可能违反数据准确性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作是检查是否违反数据完整性。</p><p><strong>3.内部版本控制和外部版本控制</strong><br>内部版本控制：_version自增长，修改数据后，_version会自动的加1</p><p><strong>外部版本控制：为了保持_version与外部版本控制的数值一致</strong><br>使用version_type&#x3D;external检查数据当前的version值是否小于请求中的version值</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RbbitMq的使用</title>
      <link href="/2022/06/02/RabbitMQ/"/>
      <url>/2022/06/02/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uufzk8kcj215j0gtmyd.jpg" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uug0sh9xj21780iumzm.jpg" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uug35skej20ko03q3ym.jpg" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：</p><p><img src="/assets/image-20210717162628635.png" alt="image-20210717162628635"></p><p>MQ的基本结构：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uug5h2bkj212x0gydhv.jpg" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uug6xqu6j215g0jv77a.jpg" alt="image-20210717163332646"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uug95vbhj206g034glj.jpg" alt="image-20210717163253264"></p><p>导入后可以看到结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuga3jevj20ce05d3yl.jpg" alt="image-20210717163604330"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugbzsccj20yn05zglu.jpg" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Channel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Connection</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ConnectionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublisherTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.150.101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.发送消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, rabbitmq!"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息成功：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5.关闭通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.150.101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.订阅消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span> <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span>                                       <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 5.处理消息</span>                <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugfanx1j20m50dvmxp.jpg" alt="image-20210717164024967"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugh51iej20le0clmxt.jpg" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--AMQP依赖，包含RabbitMQ--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.150.101 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> itcast <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 队列名称</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        <span class="token comment">// 消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.150.101 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> itcast <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>listener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RabbitListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugjhyayj20yt0d30tc.jpg" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称</span>    <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, message_"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenWorkQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span> <span class="token operator">+</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenWorkQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2........接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span> <span class="token operator">+</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-x2F-订阅"><a href="#3-3-发布-x2F-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><p>发布订阅的模型如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuglp5zrj213r0cut9t.jpg" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugon16pj213c0bzaaz.jpg" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugrfevyj20xv07dq3m.jpg" alt="image-20210717165509466"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugsuug2j20r80983zj.jpg" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Binding</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">BindingBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">FanoutExchange</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Queue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 声明交换机     * @return Fanout类型交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"itcast.fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第1个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue1<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第2个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue2</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue2<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称</span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"itcast.fanout"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, everyone!"</span><span class="token punctuation">;</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugvnq02j218r0dqta9.jpg" alt="image-20210717170041447"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uugx2ce7j20xd0ccab4.jpg" alt="image-20210717170223317"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称</span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuh1r9u3j21am0fh41d.jpg" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuh4j75mj20z509pwff.jpg" alt="image-20210717170829229"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * topicExchange     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendTopicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称</span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"喜报！孙悟空大战哥斯拉，胜!"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"china.news"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token string">"china.#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token string">"#.news"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuh6w0wej20wf086ta4.jpg" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 准备消息</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuh9q0suj212h0asgnz.jpg" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">MessageConverter</span> <span class="token function">jsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> RabbitMq相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Es集群脑裂情况</title>
      <link href="/2022/06/02/Es%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E6%83%85%E5%86%B5/"/>
      <url>/2022/06/02/Es%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集群脑裂是什么？"><a href="#1-集群脑裂是什么？" class="headerlink" title="1.集群脑裂是什么？"></a>1.集群脑裂是什么？</h1><blockquote><p>所谓脑裂问题，就是同一个集群中的不同节点，对于集群的状态有了不一样的理解，比如集群中存在两个master，正常情况下我们集群中只能有一个master节点。</p></blockquote><h1 id="2-集群脑裂场景举例"><a href="#2-集群脑裂场景举例" class="headerlink" title="2.集群脑裂场景举例"></a>2.集群脑裂场景举例</h1><p>如果因为网络的故障，导致一个集群被划分成了两片，每片都有多个node，以及一个master，那么集群中就出现了两个master了。但是因为master是集群中非常重要的一个角色，主宰了集群状态的维护，以及shard的分配，因此如果有两个master，可能会导致数据异常。<br>如：</p><p>节点1在启动时被选举为主节点并保存主分片标记为0P，而节点2保存副本分片标记为0R。<br>现在，如果在两个节点之间的通讯中断了，会发生什么？由于网络问题或只是因为其中一个节点无响应,这是有可能发生的。</p><p>两个节点都相信对方已经挂了。节点1不需要做什么，因为它本来就被选举为主节点。但是节点2会自动选举它自己为主节点，因为它相信集群的一部分没有主节点了。<br>在elasticsearch集群，是有主节点来决定将分片平均的分布到节点上的。节点2保存的是复制分片，但它相信主节点不可用了。所以它会自动提升Node2节点为主节点。</p><p>现在我们的集群在一个不一致的状态了。打在节点1上的索引请求会将索引数据分配在主节点，同时打在节点2的请求会将索引数据放在分片上。在这种情况下，分片的两份数据分开了，如果不做一个全量的重索引很难对它们进行重排序。在更坏的情况下，一个对集群无感知的索引客户端（例如，使用REST接口的）,这个问题非常透明难以发现，无论哪个节点被命中索引请求仍然在每次都会成功完成。问题只有在搜索数据时才会被隐约发现：取决于搜索请求命中了哪个节点，结果都会不同。</p><h1 id="3-脑裂解决方案"><a href="#3-脑裂解决方案" class="headerlink" title="3.脑裂解决方案"></a>3.脑裂解决方案</h1><p>在elasticsearch.yml中配置属性：discovery.zen.minimum_master_nodes，它的值默认是1，这个参数的作用，就是告诉es直到有足够的master候选节点支持时，才可以选举出一个master，否则就不要选举出一个master。<br>这个参数设置有个算法就是：master候选资格节点数量 &#x2F; 2 + 1，所有有资格成为master的节点都需要加上这个配置。<br>假设我们有10个节点，都能维护数据，也都有资格成为master节点，那么quorum就是10 &#x2F; 2 + 1 &#x3D; 6；假设我们有5个节点，那么quorum就是5&#x2F;2 + 1 &#x3D; 3。</p><h1 id="4-分析：为什么master候选节点最少三个（minimum-master-nodes是如何避免脑裂问题产生的）"><a href="#4-分析：为什么master候选节点最少三个（minimum-master-nodes是如何避免脑裂问题产生的）" class="headerlink" title="4.分析：为什么master候选节点最少三个（minimum_master_nodes是如何避免脑裂问题产生的）"></a>4.分析：为什么master候选节点最少三个（minimum_master_nodes是如何避免脑裂问题产生的）</h1><p>思考一下，如果你只有两台节点，那么是无法使用官方的这个配置公式的，（这也就是为什么我们之前建议最少要三台机器能成为主节点），两台的话会出现各种各样的问题，为什么呢？<br>思考一下假设集群中共有2个节点，discovery.zen.minimum_master_nodes分别设置成2和1会怎么样？<br>如果我们有2个节点，都可以是master候选节点，那么quorum是2 &#x2F; 2 + 1 &#x3D; 2。此时就有问题了，因为如果一个node挂掉了，这么这时节点发生变更，那么只剩下一个master候选节点，是无法满足quorum数量的，也就无法选举出新的master，集群就彻底挂掉了。此时就只能将这个参数设置为1，但是这就无法阻止脑裂的发生了。<br>那么思考一下三台行不行呢？<br>node1为主节点 node2、3是数据节点，3&#x2F;2+1 &#x3D; 2，也是至少两台支持才能成为master。<br>1）如果主节点和两个数据节点因为网络不稳定失去联系，两个数据节点是可以正常通信的，那么此时那个单独的master节点因为没有指定数量的候选master node在自己当前所在的集群内，因此就会取消当前master的角色，尝试重新选举，但是无法选举成功。然后另外一个网络区域内的node因为无法连接到master，就会发起重新选举，因为有两个master候选节点，满足了quorum，因此可以成功选举出一个master。此时集群中就会还是只有一个master，不会出现脑裂。<br>2）如果master和另外一个node在一个网络区域内，然后一个node单独在一个网络区域内。那么此时那个单独的node因为连接不上master，会尝试发起选举，但是因为master候选节点数量不到quorum，因此无法选举出master。而另外一个网络区域内，原先的那个master还会继续工作。这也可以保证集群内只有一个master节点。<br>3）如果三台相互之间都无法通信，同上分析，则也不会出现脑裂问题。<br>综上所述，一个生产环境的es集群，至少要有3个节点，三台主节点通过在elasticsearch.yml中配置discovery.zen.minimum_master_nodes: 2，就可以避免脑裂问题的产生。</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装及使用</title>
      <link href="/2022/05/26/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/"/>
      <url>/2022/05/26/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltn82vyzj213t0u0gqt.jpg" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltn8w7vtj215x0u0793.jpg" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><blockquote></blockquote><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731154257653.png" alt="image-20210731154257653"></p><blockquote><p>总结:</p><p>第一步，当我们客户端发起指令，去dockerhub或者私有仓库去拉取指定的镜像，把该镜像存储在当前Linux系统中的本地镜像中</p><p>第二不，由客户端发起指令，创建容器的指令，去基于本地镜像中的指定镜像，然后通过创建容器的命令，从而生成指定的容器，</p></blockquote><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker</p><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><h4 id="1-4-1-检查centos7的内核命令"><a href="#1-4-1-检查centos7的内核命令" class="headerlink" title="1.4.1 检查centos7的内核命令"></a>1.4.1 检查centos7的内核命令</h4><pre class="line-numbers language-none"><code class="language-none">uname -r <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2lto06f4pj21ka0u0ag6.jpg" alt="1567261735176"></p><h4 id="1-4-2-centos7的ip地址"><a href="#1-4-2-centos7的ip地址" class="headerlink" title="1.4.2 centos7的ip地址"></a>1.4.2 centos7的ip地址</h4><p>查看ip地址命令</p><pre class="line-numbers language-none"><code class="language-none">ip addr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/1567262080798.png" alt="1567262080798"></p><h4 id="1-4-3-更改静态ip地址"><a href="#1-4-3-更改静态ip地址" class="headerlink" title="1.4.3 更改静态ip地址"></a>1.4.3 更改静态ip地址</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">1、找到配置文件cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;vi ifcfg-ens33TYPE&#x3D;EthernetPROXY_METHOD&#x3D;noneBROWSER_ONLY&#x3D;noBOOTPROTO&#x3D;staticDEFROUTE&#x3D;yesIPADDR&#x3D;192.168.200.132NETMASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.200.2DNS1&#x3D;114.114.114.114DNS2&#x3D;8.8.8.8IPV4_FAILURE_FATAL&#x3D;noIPV6INIT&#x3D;yesIPV6_AUTOCONF&#x3D;yesIPV6_DEFROUTE&#x3D;yesIPV6_FAILURE_FATAL&#x3D;noIPV6_ADDR_GEN_MODE&#x3D;stable-privacyNAME&#x3D;ens33UUID&#x3D;b8fd5718-51f5-48f8-979b-b9f1f7a5ebf2DEVICE&#x3D;ens33ONBOOT&#x3D;yes重启网卡service network restart测试网卡ping www.baidu.com 如果有字节输出，则表示网络正常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker安装与启动："><a href="#Docker安装与启动：" class="headerlink" title="Docker安装与启动："></a>Docker安装与启动：</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1、yum 包更新到最新,需要几分钟时间(注意:也可以直接跨过)</span><span class="token attr-name">sudo</span> <span class="token attr-value">yum update</span><span class="token comment"># 2、作用：安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><span class="token attr-name">sudo</span> <span class="token attr-value">yum install -y yum-utils device-mapper-persistent-data lvm2</span><span class="token comment"># 3、 设置yum源</span><span class="token comment"># 3.1、方案一：使用ustc的（默认的）</span><span class="token attr-name">sudo</span> <span class="token attr-value">yum-config-manager --add-repo http://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><span class="token comment"># 3.2、方案二：使用阿里云（推荐使用）</span><span class="token attr-name">sudo</span> <span class="token attr-value">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><span class="token comment"># 4、 安装docker；出现输入的界面都按 y</span><span class="token attr-name">sudo</span> <span class="token attr-value">yum install -y docker-ce</span><span class="token comment"># 5、 查看docker版本</span><span class="token attr-name">docker</span> <span class="token attr-value">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-设置镜像加速器"><a href="#2-设置镜像加速器" class="headerlink" title="2.设置镜像加速器"></a>2.设置镜像加速器</h4><p>默认的镜像是ustc，而ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。<br><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>1、 编辑文件&#x2F;etc&#x2F;docker&#x2F;daemon.json</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 执行如下命令：</span><span class="token attr-name">mkdir</span> <span class="token attr-value">/etc/docker  表示创建一个文件夹</span><span class="token comment">#如果有该文件则进入编辑状态，如果没有，则创建该文件然后进入编辑状态</span><span class="token attr-name">vi</span> <span class="token attr-value">/etc/docker/daemon.json  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、在当前文件中加入阿里云的加速器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">&#123;<span class="token attr-name">  "registry-mirrors"</span><span class="token punctuation">:</span> <span class="token attr-value">["https://ft1yhcgs.mirror.aliyuncs.com"]</span>&#125;注意：[“自己的镜像加速器地址”]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><p>4、重启操作</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">systemctl daemon-reload</span><span class="token attr-name">sudo</span> <span class="token attr-value">systemctl restart docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-Docker启动与停止命令"><a href="#3-Docker启动与停止命令" class="headerlink" title="3.Docker启动与停止命令"></a>3.Docker启动与停止命令</h4><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 关闭</span><span class="token attr-name">systemctl</span> <span class="token attr-value">stop firewalld</span><span class="token comment"># 禁止开机启动防火墙</span><span class="token attr-name">systemctl</span> <span class="token attr-value">disable firewalld</span><span class="token comment"># 启动docker服务：</span><span class="token attr-name">systemctl</span> <span class="token attr-value">start docker</span><span class="token comment"># 停止docker服务：</span><span class="token attr-name">systemctl</span> <span class="token attr-value">stop docker</span><span class="token comment"># 重启docker服务：</span><span class="token attr-name">systemctl</span> <span class="token attr-value">restart docker</span><span class="token comment"># 查看docker服务状态：</span><span class="token attr-name">systemctl</span> <span class="token attr-value">status docker</span><span class="token comment"># 设置开机启动docker服务：</span><span class="token attr-name">systemctl</span> <span class="token attr-value">enable docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731155649535.png" alt="image-20210731155649535"></p><h4 id="常用镜像命令集："><a href="#常用镜像命令集：" class="headerlink" title="常用镜像命令集："></a>常用镜像命令集：</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#查看本地镜像</span><span class="token attr-name">docker</span> <span class="token attr-value">images </span><span class="token comment"># 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</span><span class="token attr-name">docker</span> <span class="token attr-value">search 镜像名称</span><span class="token comment"># 拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本 </span><span class="token attr-name">docker</span> <span class="token attr-value">pull 镜像名称</span><span class="token comment"># 可以按照镜像id删除镜像，命令如下：</span><span class="token attr-name">docker</span> <span class="token attr-value">rmi 镜像id</span><span class="token comment"># 删除所有镜像,注意：包含着docker images -q的符号是波浪号那个键</span><span class="token attr-name">docker</span> <span class="token attr-value">rmi `docker images -q`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像迁移与备份命令："><a href="#镜像迁移与备份命令：" class="headerlink" title="镜像迁移与备份命令："></a>镜像迁移与备份命令：</h4><p>其中涉及到的命令有： </p><p>​    docker commit 将容器保存为镜像 </p><p>​    docker save 将镜像备份为tar文件 </p><p>​    docker load 根据tar文件恢复为镜像</p><p>容器保存为镜像命令</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#命令形式：</span><span class="token attr-name">docker</span> <span class="token attr-value">commit 现有容器名称  镜像名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：该容器必须是停止状态。并且当前本地镜像中没有该镜像名称</p></blockquote><p>将镜像备份成tar文件命令</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#命令形式：</span><span class="token attr-name">docker</span> <span class="token attr-value">save –o tar文件名 镜像名</span><span class="token comment">#-o 输出到的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据tar文件恢复为镜像命令</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#命令形式：</span><span class="token attr-name">docker</span> <span class="token attr-value">load -i tar文件名 </span><span class="token comment">#-i 输入的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker save --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker save -o [保存的目标文件名称] [镜像名称]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker save -o nginx.tar nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker rmi nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后运行命令，加载本地文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker load -i nginx.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>容器，也是docker中的核心概念，容器是由镜像运行产生的运行实例。镜像和容器的关系，就如同Java语言中类和对象的关系。</p><p>Docker提供的关于容器的操作有：<br>        查看容器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#查看正在运行的容器使用命令</span><span class="token attr-name">docker</span> <span class="token attr-value">ps</span><span class="token comment">#查看所有容器使用命令</span><span class="token attr-name">docker</span> <span class="token attr-value">ps -a </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        创建容器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#创建并运行一个容器，处于运行状态</span><span class="token attr-name">docker</span> <span class="token attr-value">run </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        进入容器内部</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">exec -it 容器名称 bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        启动容器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">start 容器名称[或者容器ID]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        停止容器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">stop 容器名称[或者容器ID]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件拷贝</p><p>将linux宿主机中的文件拷贝到容器内可以使用命令：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#第一步， 在Linux中创建一个文件abc.txt</span><span class="token attr-name">touch</span> <span class="token attr-value">abc.txt</span><span class="token comment">#第二步，复制abc.txt到nginx的容器的   /表示根目录</span><span class="token attr-name">docker</span> <span class="token attr-value">cp 文件名称 容器名称:/ </span><span class="token comment">#示例：</span><span class="token attr-name">docker</span> <span class="token attr-value">cp abc.txt nginx:/</span><span class="token comment">#第三步， 进入nginx容器</span><span class="token attr-name">docker</span> <span class="token attr-value">exec -it nginx /bin/bash</span><span class="token comment"># 第四步，查看容器 / 目录下文件 是否有该文件</span>ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>docker这个命令是在linux系统中安装的，所以说容器中没有docker这个命令</p></blockquote><p>将文件从容器内拷贝出来到linux宿主机使用命令：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><span class="token comment">#进入容器后创建文件cba.txt</span><span class="token attr-name">touch</span> <span class="token attr-value">cba.txt</span><span class="token comment"># 退出容器</span>exit<span class="token comment"># 在Linux宿主机器执行复制；将容器mycentos2的/cba.txt文件复制到 宿主机器的/root目录下</span><span class="token attr-name">docker</span> <span class="token attr-value">cp nginx:/cba.txt  /root</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    查看容器ip地址</p><p>可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） </p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 在linux宿主机下查看 nginx 的ip </span><span class="token attr-name">docker</span> <span class="token attr-value">inspect nginxclear</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <img src="/Users/zhangminghao/BLOG/source/_posts/assets/1653489681946.png" alt="1653489681946"></p><p>删除容器</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#删除指定的容器：</span><span class="token attr-name">docker</span> <span class="token attr-value">rm 容器名称（容器ID） </span><span class="token comment">#删除所有容器：</span><span class="token attr-name">docker</span> <span class="token attr-value">rm `docker ps -a -q` </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：只能删除停止状态下的容器</p></blockquote><p>暂停容器：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#让一个运行的容器暂停</span><span class="token attr-name">docker</span> <span class="token attr-value">pause nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>让一个容器从暂停状态恢复运行</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">unpause nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>&#x3D;&#x3D;可以基于已有的镜像来创建和启动容器&#x3D;&#x3D;，创建与启动容器使用命令：docker run<br>参数说明：<br>-i：表示运行容器<br>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。（&#x3D;&#x3D;其实加入该命令就表示是创建的是交互式容器&#x3D;&#x3D;）<br>–name :为创建的容器命名。</p><p>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。(&#x3D;&#x3D;其实就是目录挂载&#x3D;&#x3D;)<br>-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。(&#x3D;&#x3D;其实加上该命令表示就是创建的是守护式容器&#x3D;&#x3D;)<br>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射(&#x3D;&#x3D;加上该命令可以被window系统访问该容器&#x3D;&#x3D;)</p><h4 id="1）交互式容器-前台启动"><a href="#1）交互式容器-前台启动" class="headerlink" title="1）交互式容器(前台启动)"></a>1）交互式容器(前台启动)</h4><p>以交互式方式创建并启动容器，启动完成后，直接进入当前容器。使用exit命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入停止状态。</p><p>创建并运行nginx容器的命令：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#命令</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it --name=容器名称 -p 80:80  镜像名称  bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2）守护式容器-后台启动"><a href="#2）守护式容器-后台启动" class="headerlink" title="2）守护式容器(后台启动)"></a>2）守护式容器(后台启动)</h4><p>创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。命令如下（容器名称不能重复）：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#创建并启动守护式容器</span><span class="token attr-name">docker</span> <span class="token attr-value">run -di --name=容器名称 镜像名称</span><span class="token comment">#登录进入容器命令为：</span><span class="token attr-name">docker</span> <span class="token attr-value">exec -it 容器名称 (或者 容器ID)  /bin/bash</span><span class="token comment">#exit退出时，容器不会停止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）-创建Nginx容器"><a href="#3）-创建Nginx容器" class="headerlink" title="3） 创建Nginx容器"></a>3） 创建Nginx容器</h4><p>命令</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run -di --name=mynginx -p 80:80 nginx </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731163255863.png" alt="image-20210731163255863"></p><blockquote><p>宿主机和容器的关系解析</p><p>1、window系统和虚拟机中的centos系统：<br>   在window系统上安装了虚拟机vmware，在vmware中安装了centos系统。<br>宿主机就是window系统电脑， 虚拟机就是centos<br>2、docker容器和linux(centos)：<br>   linux是宿主机，docker是容器，也就是说docker寄存在linux系统上</p></blockquote><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker exec -it mn bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 查看目录下文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltowvyu1j21ka0u0ag6.jpg" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sed -i -e &#39;s#Welcome to nginx#传智教育欢迎您#g&#39; -e &#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;#g&#39; index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">#创建数据卷docker volume create html#查看所有数据docker volume ls#查看数据卷详细信息卷docker volume inspect html#删除所有没有使用的数据卷docker volume prune#删除单个数据卷docker volume rm html#如果直接做数据卷挂载,挂载数据卷不存在,那么他会自动创建数据卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数据卷作用:将容器与数据分离,解耦合,方便操作容器内数据,保证数据安全</strong></p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h3 id="2-3-2-挂载数据卷"><a href="#2-3-2-挂载数据卷" class="headerlink" title="2.3.2.挂载数据卷"></a>2.3.2.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run \  --name mn \  -di   -v html:&#x2F;root&#x2F;html \  -p 8080:80  nginx \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>1、 创建容器并挂载数据卷到容器内的HTML目录</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#在Linux的root目录下创建一个html文件夹mkdir html#创建nginx容器并且目录挂载 docker run -di --name&#x3D;mn -v &#x2F;root&#x2F;html&#x2F;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -p 80:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、访问nginx</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/1653492155287.png" alt="1653492155287"></p><p>发现展示的页面是403，这不是报错，而是因为我们nginx容器中的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html中并没有任何html文件导致的。所以我们要执行第三步</p><p>3、从本地的nginx中找一个index.html存储到Linux系统中的&#x2F;root&#x2F;html文件夹中即可</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#上传index.html到&#x2F;root&#x2F;html中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、再访问nginx</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/1653492416335.png" alt="1653492416335"></p><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><p>命令：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#创建目录：</span><span class="token attr-name">mkdir</span> <span class="token attr-value">-p  /tmp/mysql/conf</span><span class="token attr-name">mkdir</span> <span class="token attr-value">-p  /tmp/mysql/data</span><span class="token comment">#创建容器</span><span class="token attr-name">docker</span> <span class="token attr-value">run \ --name=mysql2 \ -e MYSQL_ROOT_PASSWORD=root \ -p 3306:3306 \ --platform linux/amd64 \ -v  /tmp/mysql/data:/var/lib/mysql \      </span><span class="token attr-name"> -v</span> <span class="token attr-value"> /tmp/mysql/conf:/etc/mysql/conf.d \ </span><span class="token attr-name"> -di</span> <span class="token attr-value">\ mysql:5.7.25</span><span class="token comment">#上传资料中的hmy.cnf到mysql容器中的/etc/mysql/conf.d文件夹下</span><span class="token comment">#最后测试mysql</span><span class="token comment">#启动mysql时mac本有可能出现不兼容问题,只要在启动命令加上以下命令就可以或者用mysql:8-oracle</span><span class="token attr-name">--platform</span> <span class="token attr-value">linux/amd64</span><span class="token attr-name">docker</span> <span class="token attr-value">run --name mysql1 -e MYSQL_ROOT_PASSWORD=root -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hm.cnf -v /tmp/mysql/data/:/var/lib/mysql -d mysql:8-oracle</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltp1x63dj21ka0u0ag6.jpg" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltp6dtspj21ka0u0ag6.jpg" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR&#x3D;&#x2F;usr&#x2F;local# 拷贝jdk和java项目的包COPY .&#x2F;jdk8.tar.gz $JAVA_DIR&#x2F;#最终使用的是这行COPY .&#x2F;docker-demo.jar &#x2F;tmp&#x2F;app.jar# 安装JDKRUN cd $JAVA_DIR \ &amp;&amp; tar -xf .&#x2F;jdk8.tar.gz \ &amp;&amp; mv .&#x2F;jdk1.8.0_144 .&#x2F;java8# 配置环境变量ENV JAVA_HOME&#x3D;$JAVA_DIR&#x2F;java8ENV PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar &#x2F;tmp&#x2F;app.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker build -t javaweb:1.0 .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建并运行当前容器</p></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run -di --name=javaweb -p 8090:8090 javaweb:1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM java:8-alpineCOPY .&#x2F;app.jar &#x2F;tmp&#x2F;app.jarEXPOSE 8090ENTRYPOINT java -jar &#x2F;tmp&#x2F;app.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li></ul><pre class="line-numbers language-none"><code class="language-none">docker build -t javaweb:2.0 .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>⑤ 使用docker run创建容器并运行</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run -di --name=javaweb -p 8090:8090 javaweb:2.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">version<span class="token operator">:</span> <span class="token string">"3.8"</span> services<span class="token operator">:</span>  mysql<span class="token operator">:</span>    image<span class="token operator">:</span> mysql<span class="token operator">:</span><span class="token number">5.7</span>.<span class="token number">25</span>    environment<span class="token operator">:</span>     MYSQL_ROOT_PASSWORD<span class="token operator">:</span> <span class="token number">123</span>     volumes<span class="token operator">:</span>     - <span class="token string">"/tmp/mysql/data:/var/lib/mysql"</span>     - <span class="token string">"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf"</span>  web<span class="token operator">:</span>    build<span class="token operator">:</span> .    ports<span class="token operator">:</span>     - <span class="token string">"8090:8090"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。它<strong>是一个定义和运行多容器的</strong> <strong>docker应用工具</strong>。使用compose，你能通过YMAL文件配置你自己的服务，然后通过一个命令，你能使用配置文件 创建和运行所有的服务。</p><h4 id="安装DockerCompose"><a href="#安装DockerCompose" class="headerlink" title="安装DockerCompose"></a>安装DockerCompose</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#国内资源(建议)curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.4&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose# 设置文件可执行权限 chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose # 查看版本信息 docker-compose -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/Users/zhangminghao/BLOG/source/_posts/assets/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.2"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">nacos</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server<span class="token punctuation">:</span>1.4.1    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MODE</span><span class="token punctuation">:</span> standalone    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8848:8848"</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> root    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"$PWD/mysql/data:/var/lib/mysql"</span>      <span class="token punctuation">-</span> <span class="token string">"$PWD/mysql/conf:/etc/mysql/conf.d/"</span>  <span class="token key atrule">userservice</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./user<span class="token punctuation">-</span>service  <span class="token key atrule">orderservice</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./order<span class="token punctuation">-</span>service  <span class="token key atrule">gateway</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./gateway    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"10010:10010"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server:1.4.1</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7</code>：镜像版本是mysql:5.7</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: root</code>：设置数据库root账户的密码为root</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltp94enoj21r30u0dmn.jpg" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/assets/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM java:8-alpineCOPY .&#x2F;app.jar &#x2F;tmp&#x2F;app.jarENTRYPOINT java -jar &#x2F;tmp&#x2F;app.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//mysql<span class="token punctuation">:</span>3306/cloud_order<span class="token punctuation">?</span>useSSL=false    <span class="token key atrule">username</span><span class="token punctuation">:</span> root    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> nacos<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos服务地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 服务打包的最终名称 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>app<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打包后：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltpkbn6hj21ka0u0ag6.jpg" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltppi3o5j21cq0bo0us.jpg" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="/assets/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltpl37kpj21ka0u0ag6.jpg" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltqacbmjj220o0smwkl.jpg" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><h4 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a><strong>私有仓库搭建与配置</strong></h4><p>Docker官方的Docker hub（<a href="https://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉取镜像/">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像</a> 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜 像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。 </p><p>私有仓库搭建步骤：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1、拉取私有仓库镜像 </span><span class="token attr-name">docker</span> <span class="token attr-value">pull registry </span><span class="token comment"># 2、启动私有仓库容器 </span><span class="token attr-name">docker</span> <span class="token attr-value">run -di --name=registry -p 5000:5000 registry </span><span class="token comment"># 3、打开浏览器 输入地址http://宿主机ip:5000/v2/_catalog，看到&#123;"repositories":[]&#125; 表示私有仓库 搭建成功 </span><span class="token comment"># 4、修改daemon.json </span><span class="token attr-name">vi</span> <span class="token attr-value">/etc/docker/daemon.json </span><span class="token comment"># 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将宿主机ip修改为自己宿主 机真实ip </span>&#123;<span class="token attr-name">  "registry-mirrors"</span><span class="token punctuation">:</span> <span class="token attr-value">["https://7oc12mqc.mirror.aliyuncs.com"],  #镜像加速器</span><span class="token attr-name">  "insecure-registries"</span><span class="token punctuation">:</span><span class="token attr-value">["192.168.200.140:5000"]                  #让docker去信任私有仓库</span>&#125;<span class="token comment"># 5、重启docker 服务 </span><span class="token attr-name">systemctl</span> <span class="token attr-value">daemon-reload</span><span class="token attr-name">systemctl</span> <span class="token attr-value">restart docker </span><span class="token attr-name">docker</span> <span class="token attr-value">start registry</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问私有仓库</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;IP:5000&#x2F;v2&#x2F;_catalog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ltq73aorj220o0smwkl.jpg" alt="1653496365512"></p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p> <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker tag nginx:latest 192.168.150.101:8080&#x2F;nginx:1.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>② 推送镜像</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker push 192.168.150.101:8080&#x2F;nginx:1.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>③ 拉取镜像</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker pull 192.168.150.101:8080&#x2F;nginx:1.0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebFlux和springMVC的区别</title>
      <link href="/2022/05/26/WebFlux%E5%92%8CspringMVC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/05/26/WebFlux%E5%92%8CspringMVC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<ol><li><h6 id="WebFlux使用场景"><a href="#WebFlux使用场景" class="headerlink" title="WebFlux使用场景"></a>WebFlux使用场景</h6></li></ol><p>  WebFlux 用于构建响应式 Web 服务。在详细介绍 WebFlux 之前，我们先梳理一下这个新框架的应用场景，了解应用场景才能帮助我们对所要采用的技术体系做出正确的选择。</p><p>因为 Reactor 这样的响应式库可以帮助我们构建一个异步的非阻塞流，并且为开发人员屏蔽了底层的技术复杂度。而基于 Reactor 框架的 WebFlux 进一步降低了开发响应式 Web 服务的难度。</p><p>微服务架构的兴起为 WebFlux 的应用提供了一个很好的场景。我们知道在一个微服务系统中，存在数十乃至数百个独立的微服务，它们相互通信以完成复杂的业务流程。这个过程势必会涉及大量的 I&#x2F;O 操作，尤其是阻塞式 I&#x2F;O 操作会整体增加系统的延迟并降低吞吐量。如果能够在复杂的流程中集成非阻塞、异步通信机制，我们就可以高效处理跨服务之间的网络请求。针对这种场景，WebFlux 是一种非常有效的解决方案。</p><ol start="2"><li>WebMVC 和WebFlux</li></ol><p>2.1 Spring WebMvc<br>Java中的传统的Web容器都是基于Servlet规范来实现的，Spring WebMvc 作为一种经典的Web框架实现，同样也是基于Servlet来实现的。Spring MVC 相信大家都非常熟悉，也是主流的开发框架。这里不在详细介绍，在我的计划中后面会出一系列源码阅读的文章包括Spring、WebMvc和Mybatis等。这里放一张架构图用来和WebFlux作为对比。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljb8yxhnj20i60bgmxv.jpg" alt="5ff17885bcd3b0fc5f5a05bb3e7b25d0"></p><p>2.2 Spring WebFlux<br>由于Spring WebMVC 在实现上并不允许在整个请求生命周期中都采用非阻塞式的操作方式。因此，Spring 在尽量沿用原有的开发模式以及 API 设计上提供了支持异步非阻塞的 Spring WebFlux 框架。</p><p>在使用WebFlux和WebMvc实际的使用并没有太大的区别，实际上WebFlux的核心组件基本都是SpringMvc核心组件的异步非阻塞实现版本。所以在有了差别不大的开发体验。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljbfqom1j20md0abdgt.jpg" alt="dcd412209a8bbd51b56f1bfb8a4ca04e"></p><p>2.3 对比两种实现的处理模型<br>Spring WebMvc是一种同步阻塞的处理模型，也就是说当请求过来时，工作线程开始处理请求后，然后开始阻塞等待DB或者IO操作完成，当IO结束是返回响应结果。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljblh031j20nw06zq3x.jpg" alt="baf29b5c7786244d46c0e5dcecd33686"></p><p>模型大概如上，可以看到工作线程的实际处理时间远小于花费在阻塞操作上的时间。这意味着工作线程会被 I&#x2F;O 读取或写入数据这一操作所阻塞。从这个简单的图中，我们可以得出结论，线程效率低下。同时，因为所有请求是排队的，相当于一个请求队列，所以接受请求和处理请求这两部分操作实际上是可以共享等待时间的。WebFlux 构建在非阻塞 API 之上，这意味着没有操作需要与 I&#x2F;O 阻塞线程进行交互。接受和处理请求的效率很高，如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljbp7kfvj20nl0920tw.jpg" alt="470e9c44c254743c7ca52efbe836ba5a"></p><p>将上图中所展示的异步非阻塞请求处理与前面的阻塞过程进行比较，我们会注意到，现在没有在读取请求数据时发生等待，工作线程高效接受新连接。然后，提供了非阻塞 I&#x2F;O 机制的底层操作系统会告诉我们请求数据是否已经接收完成，并且处理器可以在不阻塞的情况下进行处理。</p><p>2.4 性能差异<br>引用维护Spring 框架的 Pivotal 公司软件开发主管 Biju Kunjummen 的测试结果来对这一问题进行解答。</p><p>在 Biju Kunjummen 的测试用例中，他分别基于 WebMVC 所提供的阻塞式 RestTemplate 以及 WebFlux 所提供的非阻塞式 WebClient 工具类对远程 Web 服务发起请求。对于不同组的并发用户（300、1000、1500、3000、5000），他分别发送了一个 delay 属性设置为 300 ms 的请求，每个用户重复该场景 30 次，请求之间的延迟为 1 到 2 秒。测试用例中使用了 Gatling 这款工具来执行压测。</p><p>这里我们截取 300 和 3000 并发用户场景下的结果进行对比，如下面两张图所示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljctn5t1j20jk0cwjtf.jpg" alt="b2317a9f2c3d98f9320e3c9071e0db5a"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ljcffgskj20jn0d640r.jpg" alt="b15a8ab0a6f64b6a441650fb559a47fd"></p><p>可以看出在300并发时，两者并没有太大区别，当并发量上升时WebFlux就有压倒式优势了，所以异步框架更适合高并发的业务场景。</p><ol start="3"><li>总结<br>本节主要对比了WebMvc 和 WebFlux两个Web框架，Spring已经为我们开发做了很大努力了，所以在合适的场景下这种异步框架还是非常可行的。但是还要考虑后期其它异步框架是否能够完善，全链路异步才能发挥异步最大的优势。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装Docker</title>
      <link href="/2022/05/26/Centos7%E5%AE%89%E8%A3%85Docker/"/>
      <url>/2022/05/26/Centos7%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><pre class="line-numbers language-none"><code class="language-none">yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine \                  docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install -y yum-utils \           device-mapper-persistent-data \           lvm2 --skip-broken<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后更新本地镜像源：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 设置docker镜像源yum-config-manager \    --add-repo \    https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo    sed -i &#39;s&#x2F;download.docker.com&#x2F;mirrors.aliyun.com\&#x2F;docker-ce&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repoyum makecache fast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后输入命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过命令启动docker：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后输入命令，可以查看docker版本：</p><pre class="line-numbers language-none"><code class="language-none">docker -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuc20yxlj20ku02j74m.jpg" alt="image-20210418154704436"> </p><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 安装curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.23.1&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2uuc49m8ej20by07kdga.jpg" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 修改权限chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 补全命令curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;docker&#x2F;compose&#x2F;1.29.1&#x2F;contrib&#x2F;completion&#x2F;bash&#x2F;docker-compose &gt; &#x2F;etc&#x2F;bash_completion.d&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果这里出现错误，需要修改自己的hosts文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; &#x2F;etc&#x2F;hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run -d \    --restart&#x3D;always \    --name registry\    -p 5000:5000 \    -v registry-data:&#x2F;var&#x2F;lib&#x2F;registry \    registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.0'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">registry</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> registry    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./registry<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/var/lib/registry  <span class="token key atrule">ui</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> joxit/docker<span class="token punctuation">-</span>registry<span class="token punctuation">-</span>ui<span class="token punctuation">:</span>static    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 8080<span class="token punctuation">:</span><span class="token number">80</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> REGISTRY_TITLE=传智教育私有仓库      <span class="token punctuation">-</span> REGISTRY_URL=http<span class="token punctuation">:</span>//registry<span class="token punctuation">:</span><span class="token number">5000</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 打开要修改的文件vi &#x2F;etc&#x2F;docker&#x2F;daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http:&#x2F;&#x2F;192.168.150.101:5000&quot;]    记得加逗号# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gateway网关</title>
      <link href="/2022/05/25/Gateway%E7%BD%91%E5%85%B3/"/>
      <url>/2022/05/25/Gateway%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Gateway服务网关"><a href="#1-Gateway服务网关" class="headerlink" title="1.Gateway服务网关"></a><strong>1.Gateway服务网关</strong></h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="1-1-为什么需要网关"><a href="#1-1-为什么需要网关" class="headerlink" title="1.1.为什么需要网关"></a><strong>1.1.为什么需要网关</strong></h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714210131152.png?lastModify=1653489702" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="1-2-gateway快速入门"><a href="#1-2-gateway快速入门" class="headerlink" title="1.2.gateway快速入门"></a><strong>1.2.gateway快速入门</strong></h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l1631tktj20pa0ajq40.jpg" alt="image-20210714210919458"></p><p>引入依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;  public static void main(String[] args) &#123;    SpringApplication.run(GatewayApplication.class, args);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714211908341.png?lastModify=1653489702" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16f2lupj20zl0hnwg3.jpg" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li>创建项目，引入nacos服务发现和gateway依赖</li><li>配置application.yml，包括服务基本信息、nacos地址、路由</li></ol><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则，</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="1-3-断言工厂"><a href="#1-3-断言工厂" class="headerlink" title="1.3.断言工厂"></a><strong>1.3.断言工厂</strong></h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">Weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="1-4-过滤器工厂"><a href="#1-4-过滤器工厂" class="headerlink" title="1.4.过滤器工厂"></a><strong>1.4.过滤器工厂</strong></h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714212312871.png?lastModify=1653489702" alt="image-20210714212312871"></p><h3 id="1-4-1-路由过滤器的种类"><a href="#1-4-1-路由过滤器的种类" class="headerlink" title="1.4.1.路由过滤器的种类"></a>1.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">AddRequestHeader</td><td align="left">给当前请求添加一个请求头</td></tr><tr><td align="left">RemoveRequestHeader</td><td align="left">移除请求中的一个请求头</td></tr><tr><td align="left">AddResponseHeader</td><td align="left">给响应结果中添加一个响应头</td></tr><tr><td align="left">RemoveResponseHeader</td><td align="left">从响应结果中移除有一个响应头</td></tr><tr><td align="left">RequestRateLimiter</td><td align="left">限制请求的流量</td></tr></tbody></table><h3 id="1-4-2-请求头过滤器"><a href="#1-4-2-请求头过滤器" class="headerlink" title="1.4.2.请求头过滤器"></a>1.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote><p>第一步，只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb:&#x2F;&#x2F;userservice         predicates:         - Path&#x3D;&#x2F;user&#x2F;**         filters: # 过滤器        - AddRequestHeader&#x3D;Truth, Itcast is freaking awesome! # 添加请求头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><p>第二步，在userController中修改方法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 路径： &#x2F;user&#x2F;110 * * @param id 用户id * @return 用户 *&#x2F;@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id,                      @RequestHeader(&quot;Truth&quot;) String truth) &#123;    System.out.println(truth);    return userService.queryById(id);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三步，重启网关服务和user服务，并通过网关访问user用户信息 <a href="http://localhost:10010/user/3">http://localhost:10010/user/3</a></p><p>查看控制台信息，发现可以得到请求头中的信息的</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/1653321682110.png?lastModify=1653489702" alt="1653321682110"></p><h3 id="1-4-3-默认过滤器"><a href="#1-4-3-默认过滤器" class="headerlink" title="1.4.3.默认过滤器"></a>1.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb:&#x2F;&#x2F;userservice         predicates:         - Path&#x3D;&#x2F;user&#x2F;**      default-filters: # 默认过滤项      - AddRequestHeader&#x3D;Truth, Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-4-总结"><a href="#1-4-4-总结" class="headerlink" title="1.4.4.总结"></a>1.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="1-5-全局过滤器"><a href="#1-5-全局过滤器" class="headerlink" title="1.5.全局过滤器"></a><strong>1.5.全局过滤器</strong></h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="1-5-1-全局过滤器作用"><a href="#1-5-1-全局过滤器作用" class="headerlink" title="1.5.1.全局过滤器作用"></a>1.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-none"><code class="language-none">public interface GlobalFilter &#123;    &#x2F;**     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束     *&#x2F;    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="1-5-2-自定义全局过滤器"><a href="#1-5-2-自定义全局过滤器" class="headerlink" title="1.5.2.自定义全局过滤器"></a>1.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li>参数中是否有authorization，</li><li>authorization参数值是否为admin</li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        &#x2F;&#x2F; 1.获取请求参数        MultiValueMap&lt;String, String&gt; params &#x3D; exchange.getRequest().getQueryParams();        &#x2F;&#x2F; 2.获取authorization参数        String auth &#x3D; params.getFirst(&quot;authorization&quot;);        &#x2F;&#x2F; 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;            &#x2F;&#x2F; 放行            return chain.filter(exchange);        &#125;        &#x2F;&#x2F; 4.拦截        &#x2F;&#x2F; 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        &#x2F;&#x2F; 4.2.结束处理        return exchange.getResponse().setComplete();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-3-过滤器执行顺序"><a href="#1-5-3-过滤器执行顺序" class="headerlink" title="1.5.3.过滤器执行顺序"></a>1.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16c9jpqj21200d7gna.jpg" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="1-6-跨域问题"><a href="#1-6-跨域问题" class="headerlink" title="1.6.跨域问题"></a><strong>1.6.跨域问题</strong></h2><h3 id="1-6-1-什么是跨域问题"><a href="#1-6-1-什么是跨域问题" class="headerlink" title="1.6.1.什么是跨域问题"></a>1.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li>域名不同： <a href="www.taobao.com">www.taobao.com</a> 和 <a href="www.taobao.org">www.taobao.org</a> 和 <a href="www.jd.com">www.jd.com</a> 和 miaosha.jd.com</li><li>域名相同，端口不同：localhost:8080和localhost8081</li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="1-6-2-模拟跨域问题"><a href="#1-6-2-模拟跨域问题" class="headerlink" title="1.6.2.模拟跨域问题"></a>1.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l164rshjj20gm05v3z7.jpg" alt="image-20210714215713563"></p><p>放入idea的resource下，然后打开index.html点击右上角的谷歌浏览器</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16bfxlaj21eo0lzn1p.jpg" alt="1653322918256"></p><p>点击执行谷歌浏览器展示页面效果</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l165qv67j20te0c0myt.jpg" alt="1653322945983"></p><p>F12可以在浏览器控制台看到下面的错误：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714215832675.png?lastModify=1653489702" alt="image-20210714215832675"></p><p>从localhost:63342访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="1-6-3-解决跨域问题"><a href="#1-6-3-解决跨域问题" class="headerlink" title="1.6.3.解决跨域问题"></a>1.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#39;[&#x2F;**]&#39;:            allowedOrigins: # 允许哪些网站的跨域请求               - &quot;http:&#x2F;&#x2F;localhost:63342&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud微服务技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Feign远程调用</title>
      <link href="/2022/05/25/Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2022/05/25/Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Feign远程调用"><a href="#1-Feign远程调用" class="headerlink" title="1.Feign远程调用"></a><strong>1.Feign远程调用</strong></h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714174814204.png?lastModify=1653489702" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714174918088.png?lastModify=1653489702" alt="image-20210714174918088"></p><h2 id="1-1-Feign替代RestTemplate"><a href="#1-1-Feign替代RestTemplate" class="headerlink" title="1.1.Feign替代RestTemplate"></a><strong>1.1.Feign替代RestTemplate</strong></h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714175102524.png?lastModify=1653489702" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：&#x2F;user&#x2F;{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16dc9z2j20jy0br403.jpg" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="1-2-自定义配置"><a href="#1-2-自定义配置" class="headerlink" title="1.2.自定义配置"></a><strong>1.2.自定义配置</strong></h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th align="left">类型</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>feign.Logger.Level</strong></td><td align="left">修改日志级别</td><td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td align="left">feign.codec.Decoder</td><td align="left">响应结果的解析器</td><td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td align="left">feign.codec.Encoder</td><td align="left">请求参数编码</td><td align="left">将请求参数编码，便于通过http请求发送</td></tr><tr><td align="left">feign. Contract</td><td align="left">支持的注解格式</td><td align="left">默认是SpringMVC的注解</td></tr><tr><td align="left">feign. Retryer</td><td align="left">失败重试机制</td><td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="1-2-1-配置文件方式"><a href="#1-2-1-配置文件方式" class="headerlink" title="1.2.1.配置文件方式"></a>1.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><pre class="line-numbers language-none"><code class="language-none">feign:    client:    config:       userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以针对所有服务：</p><pre class="line-numbers language-none"><code class="language-none">feign:    client:    config:       default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="1-2-2-Java代码方式"><a href="#1-2-2-Java代码方式" class="headerlink" title="1.2.2.Java代码方式"></a>1.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><pre class="line-numbers language-none"><code class="language-none">public class DefaultFeignConfiguration  &#123;    @Bean    public Logger.Level feignLogLevel()&#123;        return Logger.Level.BASIC; &#x2F;&#x2F; 日志级别为BASIC    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><pre class="line-numbers language-none"><code class="language-none">@EnableFeignClients(defaultConfiguration &#x3D; DefaultFeignConfiguration .class) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><pre class="line-numbers language-none"><code class="language-none">@FeignClient(value &#x3D; &quot;userservice&quot;, configuration &#x3D; DefaultFeignConfiguration .class) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-3-Feign使用优化"><a href="#1-3-Feign使用优化" class="headerlink" title="1.3.Feign使用优化"></a><strong>1.3.Feign使用优化</strong></h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><pre class="line-numbers language-none"><code class="language-none">feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来进行debug调试来查看请求方式使用的是不是HttpClient</p><p>第一步，断点，查看userFeign接口</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l15ygnihj214a0jjwj9.jpg" alt="1653318270375"></p><p>全局搜索FeginInvocationHandler</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/1653318395262.png?lastModify=1653489702" alt="1653318395262"></p><p>进去找到invoke代理</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l15z8g97j20sy0endhx.jpg" alt="1653318794674"></p><p>在 return dispatch.get(method).invoke(args)这行打断点，然后当debug走到这的时候，执行F7或者<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16g2rgbj20ci01w744.jpg" alt="1653318856129">该按钮</p><p>然后进入</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/1653318900374.png?lastModify=1653489702" alt="1653318900374"></p><p>然后debug走到 return executeAndDecode(template, options);的时候进入到当前方法中</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/1653319052336.png?lastModify=1653489702" alt="1653319052336"></p><p>然后执行F7或者<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16g2rgbj20ci01w744.jpg" alt="1653318856129">按钮执行下一步</p><p>走过了response &#x3D; client.execute(request, options);这一步，可以看到</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l1621a9oj21040m2te5.jpg" alt="1653319122374"></p><p>可以看到client中使用的是ApacheHttpClient</p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="1-4-最佳实践"><a href="#1-4-最佳实践" class="headerlink" title="1.4.最佳实践"></a><strong>1.4.最佳实践</strong></h2><p>所谓最佳实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l169g71hj20j104zmxs.jpg" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l162kktxj20rv0bmta0.jpg" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="1-4-1-继承方式"><a href="#1-4-1-继承方式" class="headerlink" title="1.4.1.继承方式"></a>1.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l167827zj20xx0b9jsk.jpg" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</li></ul><h3 id="1-4-2-抽取方式"><a href="#1-4-2-抽取方式" class="headerlink" title="1.4.2.抽取方式"></a>1.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714214041796.png?lastModify=1653489702" alt="image-20210714214041796"></p><h3 id="1-4-3-实现基于抽取的最佳实践"><a href="#1-4-3-实现基于抽取的最佳实践" class="headerlink" title="1.4.3.实现基于抽取的最佳实践"></a>1.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714204557771.png?lastModify=1653489702" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l1659i8zj209p0520sx.jpg" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714205221970.png?lastModify=1653489702" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;cn.itcast.demo&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;feign-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16aulhlj20wn064dgx.jpg" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><pre class="line-numbers language-none"><code class="language-none">@EnableFeignClients(basePackages &#x3D; &quot;cn.itcast.feign.clients&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><p>指定需要加载的Client接口：</p><pre class="line-numbers language-none"><code class="language-none">@EnableFeignClients(clients &#x3D; &#123;UserClient.class&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud微服务技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nacos集群搭建</title>
      <link href="/2022/05/25/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/05/25/nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a><strong>Nacos集群搭建</strong></h1><h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a><strong>1.集群结构图</strong></h1><p>官方给出的Nacos集群图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13dhnzyj20ij0bljrv.jpg" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13ex8byj20ky0ji3zo.jpg" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><table><thead><tr><th align="left">节点</th><th align="left">ip</th><th align="left">port</th></tr></thead><tbody><tr><td align="left">nacos1</td><td align="left">192.168.150.1</td><td align="left">8845</td></tr><tr><td align="left">nacos2</td><td align="left">192.168.150.1</td><td align="left">8846</td></tr><tr><td align="left">nacos3</td><td align="left">192.168.150.1</td><td align="left">8847</td></tr></tbody></table><p>此处的IP是你自己服务的IP，不一定要按照我的来</p><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a><strong>2.搭建集群</strong></h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a><strong>2.1.初始化数据库</strong></h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;config_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) DEFAULT NULL,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;c_desc&#96; varchar(256) DEFAULT NULL,  &#96;c_use&#96; varchar(64) DEFAULT NULL,  &#96;effect&#96; varchar(64) DEFAULT NULL,  &#96;type&#96; varchar(64) DEFAULT NULL,  &#96;c_schema&#96; text,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_aggr&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(255) NOT NULL COMMENT &#39;group_id&#39;,  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_beta&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_tag&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_tags_relation&#96; (  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;nid&#96;),  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;group_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;his_config_info&#96; (  &#96;id&#96; bigint(64) unsigned NOT NULL,  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,  &#96;data_id&#96; varchar(255) NOT NULL,  &#96;group_id&#96; varchar(128) NOT NULL,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL,  &#96;md5&#96; varchar(32) DEFAULT NULL,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  &#96;src_user&#96; text,  &#96;src_ip&#96; varchar(50) DEFAULT NULL,  &#96;op_type&#96; char(10) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;nid&#96;),  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),  KEY &#96;idx_did&#96; (&#96;data_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;tenant_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;CREATE TABLE &#96;tenant_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;CREATE TABLE &#96;users&#96; (  &#96;username&#96; varchar(50) NOT NULL PRIMARY KEY,  &#96;password&#96; varchar(500) NOT NULL,  &#96;enabled&#96; boolean NOT NULL);CREATE TABLE &#96;roles&#96; (  &#96;username&#96; varchar(50) NOT NULL,  &#96;role&#96; varchar(50) NOT NULL,  UNIQUE INDEX &#96;idx_user_role&#96; (&#96;username&#96; ASC, &#96;role&#96; ASC) USING BTREE);CREATE TABLE &#96;permissions&#96; (    &#96;role&#96; varchar(50) NOT NULL,    &#96;resource&#96; varchar(255) NOT NULL,    &#96;action&#96; varchar(8) NOT NULL,    UNIQUE INDEX &#96;uk_role_permission&#96; (&#96;role&#96;,&#96;resource&#96;,&#96;action&#96;) USING BTREE);INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a><strong>2.2.下载nacos</strong></h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13e1gsyj20jv09r74u.jpg" alt="image-20210409212119411"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a><strong>2.3.配置Nacos</strong></h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13fhkn4j20el064dfx.jpg" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13bni9bj209r09674u.jpg" alt="image-20210409212459292"></p><p>然后添加内容：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:8845127.0.0.1:8846127.0.0.1:8847<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：此处的IP是你自己服务的IP，不一定要按照我的来！</p></blockquote><p>可以在单节点运行时，到nacos控制台查看自己的节点IP，那么这里就配置一样的IP：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13cktpbj20jq0edq3t.jpg" alt="image-20210830170229215"></p><p>然后修改application.properties文件，添加数据库配置</p><pre class="line-numbers language-none"><code class="language-none">spring.datasource.platform&#x3D;mysqldb.num&#x3D;1db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTCdb.user.0&#x3D;rootdb.password.0&#x3D;123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的数据库地址、用户名、密码请根据实际情况配置。</p><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a><strong>2.4.启动</strong></h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13efuj2j20a803imx2.jpg" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><pre class="line-numbers language-none"><code class="language-none">server.port&#x3D;8845<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos2:</p><pre class="line-numbers language-none"><code class="language-none">server.port&#x3D;8846<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos3:</p><pre class="line-numbers language-none"><code class="language-none">server.port&#x3D;8847<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后分别启动三个nacos节点：</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a><strong>2.5.nginx反向代理</strong></h2><p>找到课前资料提供的nginx安装包： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13fybvvj20a0048q2z.jpg" alt="image-20210410103253355"> </p><p>解压到任意非中文目录下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l13gwmb2j209g094t8u.jpg" alt="image-20210410103322874"> </p><p>修改conf&#x2F;nginx.conf文件，配置如下：</p><pre class="line-numbers language-none"><code class="language-none">upstream nacos-cluster &#123;    server 127.0.0.1:8845;  server 127.0.0.1:8846;  server 127.0.0.1:8847;&#125;server &#123;    listen       80;    server_name  localhost;    location &#x2F;nacos &#123;        proxy_pass http:&#x2F;&#x2F;nacos-cluster;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    nacos:      server-addr: localhost:80 # Nacos地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a><strong>2.6.优化</strong></h2><ul><li>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</li><li>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nacos注册中心的使用</title>
      <link href="/2022/05/23/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/23/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nacos注册中心"><a href="#1-Nacos注册中心" class="headerlink" title="1.Nacos注册中心"></a>1.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="15-1-认识和安装Nacos"><a href="#15-1-认识和安装Nacos" class="headerlink" title="15.1.认识和安装Nacos"></a>15.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzmnfpej20th0bxwfp.jpg" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="1-2-服务注册到nacos"><a href="#1-2-服务注册到nacos" class="headerlink" title="1.2.服务注册到nacos"></a>1.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>注意</strong>：不要忘了注释掉eureka的依赖。&#x3D;&#x3D;</p><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzoja9bj20ng08274z.jpg" alt="image-20210713231439607"></p><h2 id="1-3-服务分级存储模型"><a href="#1-3-服务分级存储模型" class="headerlink" title="1.3.服务分级存储模型"></a>1.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzktxvlj21760le76o.jpg" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzkal82j210k0ci3zn.jpg" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="1-3-1-给user-service配置集群"><a href="#1-3-1-给user-service配置集群" class="headerlink" title="1.3.1.给user-service配置集群"></a>1.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment"># 集群名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzib2inj20sz0743z0.jpg" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">-Dserver.port&#x3D;8083 -Dspring.cloud.nacos.discovery.cluster-name&#x3D;SH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzpxfmxj20tn0odgoq.jpg" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzqv68aj20z00k676x.jpg" alt="image-20210713233727923"></p><h3 id="1-3-2-同集群优先的负载均衡"><a href="#1-3-2-同集群优先的负载均衡" class="headerlink" title="1.3.2.同集群优先的负载均衡"></a>1.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-4-权重配置"><a href="#1-4-权重配置" class="headerlink" title="1.4.权重配置"></a>1.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzm71elj20y509xwfq.jpg" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzrbtl7j20kt0hr0td.jpg" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="1-5-环境隔离"><a href="#1-5-环境隔离" class="headerlink" title="1.5.环境隔离"></a>1.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzp0fiaj20tn0i2dh7.jpg" alt="image-20210714000101516"></p><h3 id="1-5-1-创建namespace"><a href="#1-5-1-创建namespace" class="headerlink" title="1.5.1.创建namespace"></a>1.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inznua1kj20fg0c5q3d.jpg" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzjdaqej20k40c7t9e.jpg" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzrspxsj20k30c1t9h.jpg" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzn4nqkj20nk0813z5.jpg" alt="image-20210714000522913"></p><h3 id="1-5-2-给微服务配置namespace"><a href="#1-5-2-给微服务配置namespace" class="headerlink" title="1.5.2.给微服务配置namespace"></a>1.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment"># 命名空间，填ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inziwhggj20fw05z0sv.jpg" alt="image-20210714000830703"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzqd7qvj20ep05ywen.jpg" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzpgu1xj20rn045q4e.jpg" alt="image-20210714000941256"></p><h2 id="1-6-Nacos与Eureka的区别"><a href="#1-6-Nacos与Eureka的区别" class="headerlink" title="1.6.Nacos与Eureka的区别"></a>1.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置为非临时实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inzlprprj212b0jugnb.jpg" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringCloud微服务技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eureka注册中心的使用</title>
      <link href="/2022/05/23/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/23/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Eureka注册中心"><a href="#1-Eureka注册中心" class="headerlink" title="1.Eureka注册中心"></a>1.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwnehkbj20xp0i03zh.jpg" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="1-1-Eureka的结构和作用"><a href="#1-1-Eureka的结构和作用" class="headerlink" title="1.1.Eureka的结构和作用"></a>1.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwt2e5yj214e0nagoy.jpg" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwqp9c0j20ws0eamz5.jpg" alt="image-20210713220509769"></p><h2 id="1-2-搭建eureka-server"><a href="#1-2-搭建eureka-server" class="headerlink" title="1.2.搭建eureka-server"></a>1.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="1-2-1-创建eureka-server服务"><a href="#1-2-1-创建eureka-server服务" class="headerlink" title="1.2.1.创建eureka-server服务"></a>1.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwwrbqwj20sz06amyf.jpg" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwvw3qaj20qi0sd7aq.jpg" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwljx82j20qi0sdgmw.jpg" alt="image-20210713221339022"></p><h3 id="1-2-2-引入eureka依赖"><a href="#1-2-2-引入eureka依赖" class="headerlink" title="1.2.2.引入eureka依赖"></a>1.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-编写启动类"><a href="#1-2-3-编写启动类" class="headerlink" title="1.2.3.编写启动类"></a>1.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>eureka</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span></span><span class="token class-name">EnableEurekaServer</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token comment">//表示Eureka服务端</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-4-编写配置文件"><a href="#1-2-4-编写配置文件" class="headerlink" title="1.2.4.编写配置文件"></a>1.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>       <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-5-启动服务"><a href="#1-2-5-启动服务" class="headerlink" title="1.2.5.启动服务"></a>1.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwod4uej212a0ljdid.jpg" alt="image-20210713222157190"></p><h2 id="1-3-服务注册"><a href="#1-3-服务注册" class="headerlink" title="1.3.服务注册"></a>1.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwotkijj20dn07fwf9.jpg" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwwbm79j20tn0odwid.jpg" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwrnen3j20cu061jrw.jpg" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwk7k49j20c804mjrp.jpg" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwjqbf2j213c05y0u2.jpg" alt="image-20210713223150650"></p><h2 id="1-4-服务发现"><a href="#1-4-服务发现" class="headerlink" title="1.4.服务发现"></a>1.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwm0jjpj20l20bsgmz.jpg" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwtk769j20t20i3ju5.jpg" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="2-Ribbon负载均衡"><a href="#2-Ribbon负载均衡" class="headerlink" title="2.Ribbon负载均衡"></a>2.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="2-1-负载均衡原理"><a href="#2-1-负载均衡原理" class="headerlink" title="2.1.负载均衡原理"></a>2.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwr5k93j215k0epgmy.jpg" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="2-2-源码跟踪"><a href="#2-2-源码跟踪" class="headerlink" title="2.2.源码跟踪"></a>2.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerInterceptor"><a href="#1）LoadBalancerInterceptor" class="headerlink" title="1）LoadBalancerInterceptor"></a>1）LoadBalancerInterceptor</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwnvllaj20o00c3jue.jpg" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwmiavcj20q107eq4t.jpg" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwtze46j20k4041754.jpg" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day01-SpringCloud01/%E8%AE%B2%E4%B9%89/md/assets/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwug2v2j20pr06cabg.jpg" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwmyyflj20go0bct9w.jpg" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwuxabxj20k407iabi.jpg" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwsmr1zj20jl04wdga.jpg" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwpbbxwj218h0k2jtx.jpg" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="2-3-负载均衡策略"><a href="#2-3-负载均衡策略" class="headerlink" title="2.3.负载均衡策略"></a>2.3.负载均衡策略</h2><h3 id="2-3-1-负载均衡策略"><a href="#2-3-1-负载均衡策略" class="headerlink" title="2.3.1.负载均衡策略"></a>2.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwvdjuuj212i0e8ac4.jpg" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="2-3-2-自定义负载均衡策略"><a href="#2-3-2-自定义负载均衡策略" class="headerlink" title="2.3.2.自定义负载均衡策略"></a>2.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="2-4-饥饿加载"><a href="#2-4-饥饿加载" class="headerlink" title="2.4.饥饿加载"></a>2.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>测试，默认采用懒加载的时候，访问<a href="http://localhost:8080/order/103%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E6%98%AF%E5%B7%AE%E4%B8%8D%E5%A4%9A1s">http://localhost:8080/order/103的第一次访问时间是差不多1s</a>,</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwq8ndkj21gn05yaaw.jpg" alt="1652356722332"></p><p>使用了饥饿加载之后，第一次访问的时间差不多是650ms左右</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2inwl5n8nj21fw05c3zd.jpg" alt="1652356816332"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud微服务技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nacos配置中心的使用</title>
      <link href="/2022/05/23/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/23/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a><strong>1.Nacos配置管理</strong></h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a><strong>1.1.统一配置管理</strong></h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16fjxesj20qc0b2aar.jpg" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l160pcn2j214q0go0ub.jpg" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l167tfmoj20rb0hq75s.jpg" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基 置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l163ylpoj21670dwdhr.jpg" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yaml # 文件后缀名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714170845901.png?lastModify=1653489702" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l1669it0j20wy0dtjto.jpg" alt="image-20210714170337448"></p><p>完整代码：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)    private String dateformat;        @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));    &#125;    &#x2F;&#x2F; ...略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在页面访问，可以看到效果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l164gfytj20f802jwef.jpg" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a><strong>1.2.配置热更新</strong></h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714171036335.png?lastModify=1653489702" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix &#x3D; &quot;pattern&quot;)public class PatternProperties &#123;    private String dateformat;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l168itk9j215t0ew414.jpg" alt="image-20210714171316124"></p><p>完整代码：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private PatternProperties patternProperties;    @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));    &#125;    &#x2F;&#x2F; 略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a><strong>1.3.配置共享</strong></h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714173233650.png?lastModify=1653489702" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714173324231.png?lastModify=1653489702" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16a1bsgj20ji0d2myp.jpg" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16097vsj20ks07lmyj.jpg" alt="image-20210714173538538"></p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714173519963.png?lastModify=1653489702" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714174313344.png?lastModify=1653489702" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16e70mpj20ij05raa7.jpg" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714174623557.png?lastModify=1653489702" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a><strong>1.4.搭建Nacos集群</strong></h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考Nacos集群搭建文章</p><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a><strong>3.Gateway服务网关</strong></h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a><strong>3.1.为什么需要网关</strong></h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714210131152.png?lastModify=1653489702" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a><strong>3.2.gateway快速入门</strong></h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l1631tktj20pa0ajq40.jpg" alt="image-20210714210919458"></p><p>引入依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;  public static void main(String[] args) &#123;    SpringApplication.run(GatewayApplication.class, args);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http:&#x2F;&#x2F;127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb:&#x2F;&#x2F;userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path&#x3D;&#x2F;user&#x2F;** # 这个是按照路径匹配，只要以&#x2F;user&#x2F;开头就符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714211908341.png?lastModify=1653489702" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16f2lupj20zl0hnwg3.jpg" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li>创建项目，引入nacos服务发现和gateway依赖</li><li>配置application.yml，包括服务基本信息、nacos地址、路由</li></ol><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则，</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a><strong>3.3.断言工厂</strong></h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">Weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a><strong>3.4.过滤器工厂</strong></h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714212312871.png?lastModify=1653489702" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">AddRequestHeader</td><td align="left">给当前请求添加一个请求头</td></tr><tr><td align="left">RemoveRequestHeader</td><td align="left">移除请求中的一个请求头</td></tr><tr><td align="left">AddResponseHeader</td><td align="left">给响应结果中添加一个响应头</td></tr><tr><td align="left">RemoveResponseHeader</td><td align="left">从响应结果中移除有一个响应头</td></tr><tr><td align="left">RequestRateLimiter</td><td align="left">限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote><p>第一步，只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb:&#x2F;&#x2F;userservice         predicates:         - Path&#x3D;&#x2F;user&#x2F;**         filters: # 过滤器        - AddRequestHeader&#x3D;Truth, Itcast is freaking awesome! # 添加请求头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><p>第二步，在userController中修改方法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 路径： &#x2F;user&#x2F;110 * * @param id 用户id * @return 用户 *&#x2F;@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public User queryById(@PathVariable(&quot;id&quot;) Long id,                      @RequestHeader(&quot;Truth&quot;) String truth) &#123;    System.out.println(truth);    return userService.queryById(id);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三步，重启网关服务和user服务，并通过网关访问user用户信息 <a href="http://localhost:10010/user/3">http://localhost:10010/user/3</a></p><p>查看控制台信息，发现可以得到请求头中的信息的</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/1653321682110.png?lastModify=1653489702" alt="1653321682110"></p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb:&#x2F;&#x2F;userservice         predicates:         - Path&#x3D;&#x2F;user&#x2F;**      default-filters: # 默认过滤项      - AddRequestHeader&#x3D;Truth, Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a><strong>3.5.全局过滤器</strong></h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-none"><code class="language-none">public interface GlobalFilter &#123;    &#x2F;**     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束     *&#x2F;    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li>参数中是否有authorization，</li><li>authorization参数值是否为admin</li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-none"><code class="language-none">package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        &#x2F;&#x2F; 1.获取请求参数        MultiValueMap&lt;String, String&gt; params &#x3D; exchange.getRequest().getQueryParams();        &#x2F;&#x2F; 2.获取authorization参数        String auth &#x3D; params.getFirst(&quot;authorization&quot;);        &#x2F;&#x2F; 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;            &#x2F;&#x2F; 放行            return chain.filter(exchange);        &#125;        &#x2F;&#x2F; 4.拦截        &#x2F;&#x2F; 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        &#x2F;&#x2F; 4.2.结束处理        return exchange.getResponse().setComplete();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16c9jpqj21200d7gna.jpg" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a><strong>3.6.跨域问题</strong></h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li>域名不同： <a href="www.taobao.com">www.taobao.com</a> 和 <a href="www.taobao.org">www.taobao.org</a> 和 <a href="www.jd.com">www.jd.com</a> 和 miaosha.jd.com</li><li>域名相同，端口不同：localhost:8080和localhost8081</li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l164rshjj20gm05v3z7.jpg" alt="image-20210714215713563"></p><p>放入idea的resource下，然后打开index.html点击右上角的谷歌浏览器</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l16bfxlaj21eo0lzn1p.jpg" alt="1653322918256"></p><p>点击执行谷歌浏览器展示页面效果</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2l165qv67j20te0c0myt.jpg" alt="1653322945983"></p><p>F12可以在浏览器控制台看到下面的错误：</p><p><img src="/Users/zhangminghao/Desktop/06-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/day02-SpringCloud02/%E8%AE%B2%E4%B9%89/md/assets/image-20210714215832675.png?lastModify=1653489702" alt="image-20210714215832675"></p><p>从localhost:63342访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#39;[&#x2F;**]&#39;:            allowedOrigins: # 允许哪些网站的跨域请求               - &quot;http:&#x2F;&#x2F;localhost:63342&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud微服务技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring底层原理学习</title>
      <link href="/2022/05/19/Spring%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/19/Spring%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中的单例bean"><a href="#Spring中的单例bean" class="headerlink" title="Spring中的单例bean"></a>Spring中的单例bean</h1><p>spring中的单例bean根所谓的单例模式并不一样,Spring的单例bean的实现是基于单例池</p><p>单例池其实就是一个Map集合,key存储的是单例对象的名字,value存储的是名字对应的对象,也就是类型</p><p>所以使用@autowire注解来进行依赖注入的时候,是先通过类型来找,如果有多个,在通过名字来找,先bytype在byname</p><p>单例bean其实指的是,一个名字对应一个对象,当我们通过getbean来获取spring容器中的bean的时候,通过名字来获取的默认都是单例的,singleton模式,如果设置了多例模式,那么创建的bean不会存储在单例池,每次get直接获取新的对象</p><h1 id="Spring创建bean使用的什么构造方法"><a href="#Spring创建bean使用的什么构造方法" class="headerlink" title="Spring创建bean使用的什么构造方法"></a>Spring创建bean使用的什么构造方法</h1><p>Spring创建Bean的时候,默认使用无参构造创建bean**(默认)**</p><p>如果没有无参构造,只有一个有参构造,则会通过有参构造中参数的类型去spring容器找对象进行注入,然后再通过有参构造进行实例化bean对象,此时还没有对构造属性赋值**(推断构造方法)**</p><p>如果在没有无参构造方法的情况下,有多个有参构造而且没有指定使用哪一个构造方法,则会报错**(推断构造方法)**</p><h1 id="Aop代理对象"><a href="#Aop代理对象" class="headerlink" title="Aop代理对象"></a>Aop代理对象</h1><p>Spring中Bean 的生命周期在初始化后,会去判断有没有进行aop切面的操作,如果有,则对这个对象创建一个代理对象,如果这个对象有实现接口,则默认使用jdk代理对象,如果没有则创建这个对象的子类,实现CGlib动态代理</p><p>代理对象有个target属性,这个属性就是被代理对象的实例化对象,直接在代理对象中通过target对象来调用方法,实现aop的效果</p><h1 id="Autowire依赖注入ByType的详细流程"><a href="#Autowire依赖注入ByType的详细流程" class="headerlink" title="@Autowire依赖注入ByType的详细流程"></a>@Autowire依赖注入ByType的详细流程</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dlr91pgsj20ne0y3k0k.jpg" alt="image-20220519123007306"></p><h1 id="Resource依赖注入ByName的详细流程"><a href="#Resource依赖注入ByName的详细流程" class="headerlink" title="@Resource依赖注入ByName的详细流程"></a>@Resource依赖注入ByName的详细流程</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dp747b0fj20i40m9dhz.jpg" alt="image-20220519142911972"></p><p>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>　　@Resource装配顺序</p><p>  　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br>    　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br>      　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br>        　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配</p><h1 id="Spring启动流程详细图解"><a href="#Spring启动流程详细图解" class="headerlink" title="Spring启动流程详细图解"></a>Spring启动流程详细图解</h1><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2dpcbv448j20w90u0gpl.jpg" alt="Spring启动流程详解" style="zoom:150%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁的学习总结</title>
      <link href="/2022/05/16/Mysql%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/16/Mysql%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL中的锁,按照锁的粒度分,分为以下三类:</p><p>1.全局锁:锁定数据库中所有表</p><p>2.表级锁:每次操作锁住整张表</p><p>3.行级锁:每次操作锁住对应的行数据</p><h1 id="全局锁-备份"><a href="#全局锁-备份" class="headerlink" title="全局锁(备份)"></a>全局锁(备份)</h1><p>全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态,后续的DML的写语句,DDL语句,已经更新操作的事务提交语句都将被阻塞</p><p>**其典型的使用场景是做全库的逻辑备份,**对所有的表进行锁定,从而获取一致性视图,保证数据的完整性</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a9nwsbtoj20sb0c4q3z.jpg" alt="image-20220516151501523"></p><p>加了全局锁后,在备份过程中,用户只能进行DQL查询操作,不能写入</p><h3 id="第一种备份操作-加全局锁"><a href="#第一种备份操作-加全局锁" class="headerlink" title="第一种备份操作,加全局锁"></a>第一种备份操作,加全局锁</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#第一步:进入mysql输入打开全局锁命令mysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.00 sec)#第二步:打开第二个cmd窗口,此时不能关闭mysql窗口,不然全局锁失效#在第二个窗口执行备份语句 (在终端执行,不是mysql内部命令)zhangminghao@localhost blog % mysqldump -uroot -proot reggie &gt; &#x2F;Users&#x2F;zhangminghao&#x2F;Desktop&#x2F;SQL&#x2F;emp.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.\#第三步:备份成功后返回第一个mysql窗口执行释放锁命令mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>特点</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aackyaj6j20qu03jaah.jpg" alt="image-20220516153844161"></p><h3 id="第二种备份操作-不加全局锁"><a href="#第二种备份操作-不加全局锁" class="headerlink" title="第二种备份操作,不加全局锁"></a>第二种备份操作,不加全局锁</h3><p>在InnoDB引擎中,我们可以在备份时加上参数 –single-transaction参数来完成不加锁的一致性数据备份</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">zhangminghao@localhost blog %   mysqldump --single-transaction -uroot -proot reggie &gt; &#x2F;Users&#x2F;zhangminghao&#x2F;Desktop&#x2F;SQL&#x2F;reggie.sqlmysqldump: [Warning] Using a password on the command line interface can be insecure.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>表级锁,每次操作锁住整张表.锁定粒度大,发生锁冲突的概率最高,并发度最低</p><p>应用在MyISAM,InnoDB,BDB等存储引擎中</p><h3 id="1-1表锁"><a href="#1-1表锁" class="headerlink" title="1.1表锁"></a>1.1表锁</h3><h4 id="1-2对于表锁-分为两类"><a href="#1-2对于表锁-分为两类" class="headerlink" title="1.2对于表锁,分为两类"></a>1.2对于表锁,分为两类</h4><p>​    ①.表共享<strong>读锁</strong>(read lock):读锁不会阻塞开启读锁的客户端的写操作,但是会阻塞其他客户端的写操作,释放锁后才解除阻塞状态.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aau0dv7ij20kw04t0td.jpg" alt="image-20220516155528866"></p><p>   ②.表独占锁<strong>写锁</strong>(write lock):写锁不会阻塞上锁的客户端的读和写,但是会阻塞其他客户端的读和写,阻塞到客户端A释放锁,才能解除阻塞状态.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ab18a527j20kd04tq3i.jpg" alt="image-20220516160224869"></p><h4 id="1-3语法"><a href="#1-3语法" class="headerlink" title="1.3语法"></a>1.3语法</h4><p>​    1.加锁:lock tables 表名… read&#x2F;write</p><pre><code> 2.释放锁:unlock tables/客户端断开连接.</code></pre><h3 id="2-1元数据锁"><a href="#2-1元数据锁" class="headerlink" title="2.1元数据锁"></a>2.1元数据锁</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acmvdflbj20wp08rq4r.jpg" alt="image-20220516165749161"></p><p>在MySQL 5.7中，针对MDL，引入了一张新表performance_schema.metadata_locks，该表可对外展示MDL的相关信息，包括其作用对象，类型及持有等待情况。</p><h4 id="2-2开启MDL的instrument"><a href="#2-2开启MDL的instrument" class="headerlink" title="2.2开启MDL的instrument"></a>2.2<strong>开启MDL的instrument</strong></h4><p>但是相关instrument并没有开启（MySQL 8.0是默认开启的），其可通过如下两种方式开启，</p><p><strong>临时生效</strong></p><p>修改<code>performance_schema.setup_instrume nts表</code>，但实例重启后，又会恢复为默认值。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE  performance_schema.setup_instruments SET ENABLED &#x3D; &#39;YES&#39;, TIMED &#x3D; &#39;YES&#39; WHERE NAME &#x3D; &#39;wait&#x2F;lock&#x2F;metadata&#x2F;sql&#x2F;mdl&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>永久生效</strong></p><h4 id="2-3在配置文件中设置"><a href="#2-3在配置文件中设置" class="headerlink" title="2.3在配置文件中设置"></a>2.3在配置文件中设置</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[mysqld]performance- schema -instrument&#x3D; &#39;wait&#x2F;lock&#x2F;metadata&#x2F;sql&#x2F;mdl&#x3D;ON&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-4元数据锁的执行流程"><a href="#2-4元数据锁的执行流程" class="headerlink" title="2.4元数据锁的执行流程"></a>2.4元数据锁的执行流程</h4><p>第一步:通过performance_schema.metadata_locks查看元数据锁状态</p><pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#查看元数据锁状态mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;+-------------+--------------------+----------------+-------------+---------------+| object_type | object_schema      | object_name    | lock_type   | lock_duration |+-------------+--------------------+----------------+-------------+---------------+| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |+-------------+--------------------+----------------+-------------+---------------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步:<strong>开启事务</strong>后,写一条<strong>查询语句</strong>,元数据锁表中会增加一条共享读锁</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;+-------------+--------------------+----------------+-------------+---------------+| object_type | object_schema      | object_name    | lock_type   | lock_duration |+-------------+--------------------+----------------+-------------+---------------+| TABLE       | reggie             | employee       | SHARED_READ | TRANSACTION   |   --------------&gt;共享读锁| TABLE       | performance_schema | metadata_locks | SHARED_READ | TRANSACTION   |+-------------+--------------------+----------------+-------------+---------------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果commit提交了事务,那么元数据中的共享读锁会消失</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abyhhqodj21430a6n0x.jpg" alt="image-20220516163422539"></p><p>第三步:如果在没有提交事务之前,在另一个客户端对该表进行修改,会增加排他锁,但是排他锁跟其他所都是互斥的,所以会造成阻塞.    </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2aceptxmoj213c0dq0vz.jpg" alt="image-20220516164958973"></p><p>此时在左边客户端再次查询元数据</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acjams3nj217r0gw0wy.jpg" alt="image-20220516165423051"></p><p>提交事务后</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2acl0vhj6j213j0f5dk5.jpg" alt="image-20220516165602410"></p><h3 id="3-1意向锁"><a href="#3-1意向锁" class="headerlink" title="3.1意向锁"></a>3.1意向锁</h3><h4 id="3-2为什么要加意向锁"><a href="#3-2为什么要加意向锁" class="headerlink" title="3.2为什么要加意向锁?"></a>3.2为什么要加意向锁?</h4><p>先看一下现象:</p><p>加入客户端A在修改表中数据时,开启事务后通过id来修改数据,因为id是主键,所以会自动上行锁</p><p>这个时候客户端B想对该表上表锁的时候,必须判断该表是否有表锁,就必须从第一条开始遍历检查,以及行锁的类型</p><p>来判断能不能加表锁,此时数据量大的时候,性能极底 ,如下图所示:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ad1ve4xmj20w40a3gn7.jpg" alt="image-20220516171213695"></p><p><strong>所以为了避免DML执行时,加的行锁与表锁冲突,在InnoDB中引如了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表的检查.</strong></p><p>可以通过以下sql,查看意向锁及行锁的加锁情况:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3意向共享锁-IS"><a href="#3-3意向共享锁-IS" class="headerlink" title="3.3意向共享锁(IS)"></a>3.3意向共享锁(IS)</h4><p>与表锁共享锁(read)兼容,与表锁排他锁(write)互斥.</p><h4 id="3-4意向排他锁-IX"><a href="#3-4意向排他锁-IX" class="headerlink" title="3.4意向排他锁(IX)"></a>3.4意向排他锁(IX)</h4><p>与表锁共享锁(read)及排他锁(write)都互斥,意向锁之间不会互斥.</p><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>行级锁,每次操作锁住对应的行数据.锁定粒度最小,发生锁冲突的概率底,并发度最高.</p><p>应用在InnoDB存储引擎中</p><p>InnoDB的数据是基于索引组织的**,行锁是通过对索引上的索引项来实现的**,而不是对记录加的锁.</p><p><strong>如果条件的字段没有索引那么行锁会升级为表锁🔒</strong></p><p>对于行级锁主要分为以下三类:</p><h3 id="1-行锁的分类"><a href="#1-行锁的分类" class="headerlink" title="1)行锁的分类"></a>1)行锁的分类</h3><h4 id="1-1行锁-Record-Lock"><a href="#1-1行锁-Record-Lock" class="headerlink" title="1.1行锁(Record Lock)"></a>1.1行锁(Record Lock)</h4><p>锁定单个行记录的锁,防止其他事务对此进行update和delete.在RC.RR隔离级别下都支持.</p><blockquote><p><strong>自己的理解:</strong></p><p><strong>行锁就是锁住聚集索引索引对应的行数据如果是从二级索引开始上锁</strong></p><p><strong>那么要通过索引对应的主键回表查询到聚集索引对应的行数据</strong></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afb9euuzj20mr03rmxt.jpg" alt="image-20220516183027448"></p><h4 id="1-2间隙锁-Gap-Lock"><a href="#1-2间隙锁-Gap-Lock" class="headerlink" title="1.2间隙锁(Gap Lock)"></a>1.2间隙锁(Gap Lock)</h4><p>锁定索引记录间隙(不含该记录),确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读.</p><p>在RR隔离级别下都支持</p><p>​       <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afehj6x7j20qo03kgmb.jpg" alt="image-20220516183333703"></p><h4 id="1-3临键锁-Next-Key-Lock"><a href="#1-3临键锁-Next-Key-Lock" class="headerlink" title="1.3临键锁(Next-Key Lock)"></a>1.3临键锁(Next-Key Lock)</h4><p>行锁和间隙锁组合,同时锁住数据,并锁住数据前面的间隙Gap.在RR隔离级别下支持**(行锁和间隙锁的组合)**</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2affu842oj20qo03qgmb.jpg" alt="image-20220516183451619"></p><h3 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2)行锁"></a>2)行锁</h3><p>InnoDB实现了一下两种类型的行锁:</p><h4 id="2-1共享锁-S"><a href="#2-1共享锁-S" class="headerlink" title="2.1共享锁(S)"></a>2.1共享锁(S)</h4><p>允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁.</p><p>简单理解就是,共享锁之间是兼容的,共享锁和排他锁是互斥的</p><h4 id="2-2排他锁-X"><a href="#2-2排他锁-X" class="headerlink" title="2.2排他锁(X)"></a>2.2排他锁(X)</h4><p>允许获取排他锁的事务更新数据,组织其他事务获得相同的数据集的共享锁和排他锁. </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afl6o5dnj20nc055jrl.jpg" alt="image-20220516183959691"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afpo7dhqj20wg065mxu.jpg" alt="image-20220516184418623"></p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2afysg3ltj20vs03k3z6.jpg" alt="image-20220516185304652"></p><hr><h4 id="3-间隙锁-x2F-临键锁-演示"><a href="#3-间隙锁-x2F-临键锁-演示" class="headerlink" title="3)间隙锁&#x2F;临键锁-演示"></a>3)间隙锁&#x2F;临键锁-演示</h4><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag1wtzlvj20q303j3yx.jpg" alt="image-20220516185604366"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ag21w7q8j20x8011t91.jpg" alt="image-20220516185612478"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2agddsvkuj20ji0exmyw.jpg" alt="image-20220516190705735"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的Sql优化</title>
      <link href="/2022/05/13/Mysql%E7%9A%84Sql%E4%BC%98%E5%8C%96/"/>
      <url>/2022/05/13/Mysql%E7%9A%84Sql%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h1><ul><li><p>insert优化</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5gdckvkj20ep0bzq3q.jpg" alt="image-20220513213453462"></p></li></ul><p>经量减少网络之间的I&#x2F;O传输,可以提高性能</p><ul><li>大批量插入数据</li></ul><p>如果需要一次性大批量插入数据,使用insert语句插入性能较低,此时可以使用MYSQL数据库提供的load指令进行插入.操作如下;</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g91h2dj20vn06ftar.jpg" alt="image-20220513213651727"></p><pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#客户端连接服务器时,加上参数 --local-infilemysql --local-infile -u root -p#设置全局参数local_infile为1.开启从本地加载文件导入数据的开关(默认关闭的)set global local_infile &#x3D; 1;mysql&gt; select @@local_infile    -&gt; ;+----------------+| @@local_infile |+----------------+|              1 |     -------------&gt;设置为1+----------------+1 row in set (0.00 sec)#执行load指令将准备好的数据,加载到表就诶够中load data local infeil &#39;&#x2F;root&#x2F;sql.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;       #文件位置                     到那张表           字段用什么分隔              每一行用什么分隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>主键顺序插入性能高于乱序插入</strong></p><h1 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h1><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>​    在InnoDB存储引擎中,表数据都是根据主键顺序存放的,这种存储方式的表称为<strong>索引组织表</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5g5lvquj20tg0ca75y.jpg" alt="image-20220516093022006"></p><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,可以填充一半,也可以填充100%.每个页包含了2-N行数据(如果一行数据过多,会行溢出),根据主键排列</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fy2n63j20wj0580tf.jpg" alt="image-20220516093248234"></p><p>如果主键不是顺序插入,那么新插入过来的数据,会找出比自己小一级的那个页,截取50%的内容</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fva5qcj20uj0af0tf.jpg" alt="image-20220516093713899"></p><p>并开辟一个新的页空间,然后和截取的那一部分一同存入新的页空间中,最后被截取的那部分页再重新指向那段新的页空间.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fstyg2j20w808v757.jpg" alt="image-20220516093818505"></p><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>当删除一行记录时,实际上记录并没有被屋里删除,只是记录被标记为删除,并且它的空间变得允许其他记录声明使用.</p><p>当页中删除的记录达到了MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找靠近的页(前或后)看看是否可以合并,以优化空间使用.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fo5ng1j20w10333z9.jpg" alt="image-20220516094302614"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fmeqh8j20ww058dgi.jpg" alt="image-20220516094319791"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5fhtxesj20xs09gmyn.jpg" alt="image-20220516094410407"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#添加索引的时候设置(默认百分之50)create index ix_person_birthday on tempdb.person(birthday) comment &#39;MERGE_THRESHOLD&#x3D;48&#39;#可以从information_schema中查询索引页的合并阀值select * from INNODB_INDEXES where name in (&#39;ix_person_name&#39;,&#39;ix_person_birthday&#39;) ;+----------+--------------------+----------+------+----------+---------+-------+-----------------+| INDEX_ID | NAME               | TABLE_ID | TYPE | N_FIELDS | PAGE_NO | SPACE | MERGE_THRESHOLD |+----------+--------------------+----------+------+----------+---------+-------+-----------------+|      147 | ix_person_name     |     1059 |    0 |        2 |       5 |     2 |              45 ||      148 | ix_person_birthday |     1059 |    0 |        2 |       6 |     2 |              48 |+----------+--------------------+----------+------+----------+---------+-------+-----------------+2 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="主键的设计原则"><a href="#主键的设计原则" class="headerlink" title="主键的设计原则"></a>主键的设计原则</h1><p>1.满足业务需求的情况下,尽量降低主键的长度,主键长度过长,当二级索引较多时,会占用大量的磁盘空间,而且在搜索的时候会耗费大量的磁盘IO,所以要尽量降低主键的长度</p><p>2.插入数据时,尽量选择顺序插入,选择使用AUTO_INCREMENT自增主键,如果不是顺序插入,可能会出现页分裂现象</p><p>3.尽量不要用UUID做主键或者其他自然主键,如身份证号,因为这些数据都是无序的,就会导致页分裂,数据过长,检索时间增加,也会增加磁盘IO</p><p>4.在业务操作时,避免对主键的修改,应为修改主键也会改变对应的索引结构,代价很大</p><h1 id="mysql8-0新特性——-gt-order-by优化"><a href="#mysql8-0新特性——-gt-order-by优化" class="headerlink" title="mysql8.0新特性——-&gt;order by优化"></a>mysql8.0新特性——-&gt;order by优化</h1><p>1.Using filesort:通过表的索引或全表扫描,读取满足条件的数据行,然后再排序缓冲区sort buffer中完成排序操作,所有不是通过索引直接返回结果的排序都叫FileSort排序</p><p>2,Using index:通过有序索引顺序扫描直接返回的有序数据,这种情况下即为Using index,不需要额外排序,操作小效率高</p><h3 id="新特性一-Backward-index-scan关键字"><a href="#新特性一-Backward-index-scan关键字" class="headerlink" title="新特性一:Backward  index scan关键字"></a>新特性一:Backward  <em>index</em> <em>scan</em>关键字</h3><p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong>Using index</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们创建联合索引进行<strong>升序查询</strong>时,通过explain查看执行计划可以发现EXtra是<strong><em>Backward</em> <em>index</em> <em>scan</em>,Using index</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc ,id_number  asc;+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Backward index scan,Using index |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在8.0中,对于反向扫描,有一个专门的词进行描述“<em><strong>Backward* <em>index</em> *scan</strong></em>“反向索引扫描,5.7版本没有</p><h3 id="新特性二-支持反向索引"><a href="#新特性二-支持反向索引" class="headerlink" title="新特性二:支持反向索引"></a>新特性二:支持反向索引</h3><p>当我们向通过一个字段升序ASC,一个字段降序DESC,或者反之,需要通过创建索引的时候指定,不然会出现全表扫描Using filesort关键字</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by phone asc  ,id_number desc;+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+1 row in set, 1 warning (0.00 sec)#按照上面需求创建降序联合索引create index  idx_phone_id_numbe on employee(phone asc,id_number desc); #-------&gt; 指定那个字段降序 #再次查询索引信息发现Collation字段A代表ASC,D代表DESC mysql&gt; show index from employee;+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| employee |          0 | PRIMARY              |                   1 | id          | A         |          15 |     NULL | NULL   |      | BTREE      |         |               || employee |          1 | idx_phone_id_number  |            1 | phone       | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               || employee |          1 | idx_phone_id_number  |            2 | id_number       | D        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>Mysql5.7</strong>中支持此语法,但是设置降序索引时,还是创建的升序,并没有改变</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index  idx_phone_id_numbe on employee(phone asc,id_number desc)mysql&gt; show index from employee;+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| employee |          0 | PRIMARY              |                   1 | id          | A         |          15 |     NULL | NULL   |      | BTREE      |         |               || employee |          1 | idx_phone_id_number  |            1 | phone       | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               || employee |          1 | idx_phone_id_number  |            2 | id_number       | A        |           5 |     NULL | NULL   | YES  | BTREE      |         |               |+----------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图解:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5f3m94kj20wv074gms.jpg" alt="image-20220516105542348"></p><h3 id="ORDER-BY注意事项"><a href="#ORDER-BY注意事项" class="headerlink" title="ORDER BY注意事项"></a>ORDER BY注意事项</h3><p><strong>事项一</strong>:根据排序字段建立合适的索引,多字段排序时,<strong>应当遵循最左前缀法则</strong>,不然虽然会走索引但是会出现<strong>Using filesort</strong></p><p>降低了查询效率.<strong>(前提是索引覆盖)</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select phone,id_number from employee order by id_number,phone ;+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+| id | select_type | table    | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra                       |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+|  1 | SIMPLE      | employee | NULL       | index | NULL          | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using filesort |+----+-------------+----------+------------+-------+---------------+---------------------+---------+------+------+----------+-----------------------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事项二</strong>:如果没有遵循最左前缀也没有达到索引覆盖条件,则会全表扫描,<strong>索引尽量要索引覆盖</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select * from employee order by id_number,phone ;+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using filesort |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事项三</strong>:多字段排序时,一个升序一个降序,此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)</p><p><strong>事项四</strong>:如果不可避免的出现filesort,大数据量排序时,<strong>可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</strong>,如果在排序时,占满了256k的排序缓冲区,则会涉及到磁盘文件当中进行排序,会降低性能,可以适量增大</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#默认排序缓冲区大小sort_buffer_size为256kmysql&gt; show variables like &#39;sort_buffer_size&#39;;+------------------+--------+| Variable_name    | Value  |+------------------+--------+| sort_buffer_size | 262144 |+------------------+--------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h1><p>1,在分组时,也可以通过索引来提高效率,如果没有索引则会出现 <strong>Using temporary</strong>临时表关键字,效率低下</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select name,count(*) from employee group by name;+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+|  1 | SIMPLE      | employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using temporary; Using filesort |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.分组操作时,索引的使用也是满足最左前缀法则的</p><p>情况一:索引没有满足最左前缀,但满足索引覆盖(Using index; Using temporary; Using filesort)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; mysql&gt; explain select  id_number,count(*) from employee group by id_number;+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                                        |+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index; Using temporary; Using filesort |+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>情况二:索引满足最左前缀,也满足索引覆盖(Using index )</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; explain select  phone,count(*) from employee group by phone;+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+| id | select_type | table    | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra       |+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+|  1 | SIMPLE      | employee | NULL       | index | idx_phone_id_number | idx_phone_id_number | 93      | NULL |   15 |   100.00 | Using index |+----+-------------+----------+------------+-------+---------------------+---------------------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h1><p>一个常见有非常头疼的问题就是limit 200000,10 ,此时mysql排序前200000,10 记录,仅仅返回200000,200010的记录,其他记录丢弃,查询排序的代价非常大</p><p>优化思路:一般分页查询时,通过创建覆盖所以,能够比较好的提高性能,可以通过覆盖索引加子查询形式优化.</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from tb_sku t,(select id from tb_sku order by id limit 200000,10)  a  where t.id &#x3D; a.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysql官方给出的优化方案</p><h1 id="Count优化"><a href="#Count优化" class="headerlink" title="Count优化"></a>Count优化</h1><h3 id="COUNT的几种用法"><a href="#COUNT的几种用法" class="headerlink" title="COUNT的几种用法"></a>COUNT的几种用法</h3><p>![image-20220516113046371](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220516113046371.png)</p><h1 id="update优化-InnoDB中索引-行锁-表锁的关系"><a href="#update优化-InnoDB中索引-行锁-表锁的关系" class="headerlink" title="update优化(InnoDB中索引-行锁-表锁的关系)"></a>update优化(InnoDB中索引-行锁-表锁的关系)</h1><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p>Mysql中的InnoDB引擎<strong>默认是行级锁</strong>,当一个客户端通过主键id修改一个条数据时,这条数据会被锁上,另一个客户端通过<strong>同一个ID修改</strong>这个被锁住的数据时,就会堵塞**(如果是不同id则不会阻塞)**</p><p>客户端A:条件相同</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ewvch5j20jj078q43.jpg" alt="image-20220516114611297"></p><p>客户端B:条件相同</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ei8t8gj20l108j40e.jpg" alt="image-20220516114824459"></p><p>等待一段时间后会抛出:ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction(等待超时)</p><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>当一个客户端通过名字name修改一个条数据时,这条数据会被锁上,另一个客户端修改<strong>另一条数据</strong>通过<strong>另一个名字name修改,发现也会阻塞</strong>,这是为什么呢????</p><blockquote><p>因为InnoDB的行锁针对索引加锁,不是针对记录加的锁,并且改索引不能失效,否则会从行锁升级为表说</p><p>也就是只要你的条件不是索引字段,那么这一次操作则会锁住整张表</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis使用</title>
      <link href="/2022/05/12/Redis%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/12/Redis%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>Redis入门</li><li>Redis数据类型</li><li>Redis常用命令</li><li>在Java中操作Redis</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis"></a>1.1 什么是Redis</h3><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件，它是「<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice」的首字母缩写，也就是「远程字典服务」。</p><ul><li><input disabled="" type="checkbox"> 基于内存存储，读写性能高</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sbs9ygj20b106v74l.jpg" alt="image-20210927090555559"></p><ul><li><input disabled="" type="checkbox"> 适合存储热点数据（热点商品、资讯、新闻）</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5scrk8rj20bk07o0tn.jpg" alt="image-20210927090604994"></p><ul><li><input disabled="" type="checkbox"> 企业应用广泛</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sdng30j20c007o74l.jpg" alt="image-20210927090612540"></p><h3 id="1-2-使用Redis能做什么"><a href="#1-2-使用Redis能做什么" class="headerlink" title="1.2 使用Redis能做什么"></a>1.2 使用Redis能做什么</h3><ul><li>数据缓存</li><li>消息队列</li><li>注册中心</li><li>发布订阅</li></ul><h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-Redis简介"><a href="#2-1-Redis简介" class="headerlink" title="2.1 Redis简介"></a>2.1 Redis简介</h3><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. 翻译为：Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p><p>官网：<a href="https://redis.io/">https://redis.io</a></p><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><p>关系型数据库(RDBMS)：</p><ul><li>Mysql</li><li>Oracle</li><li>DB2</li><li>SQLServer</li></ul><p>非关系型数据库(NoSql)：</p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h3 id="2-2-Redis下载与安装"><a href="#2-2-Redis下载与安装" class="headerlink" title="2.2 Redis下载与安装"></a>2.2 Redis下载与安装</h3><h4 id="2-2-1-Redis下载"><a href="#2-2-1-Redis下载" class="headerlink" title="2.2.1 Redis下载"></a>2.2.1 Redis下载</h4><p>Redis安装包分为windows版和Linux版：</p><ul><li>Windows版下载地址：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>Linux版下载地址： <a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li></ul><p>下载后得到下面安装包：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sj9t3rj20ug02jq34.jpg" alt="image-20210927092053283"></p><h4 id="2-2-2-Redis安装"><a href="#2-2-2-Redis安装" class="headerlink" title="2.2.2 Redis安装"></a>2.2.2 Redis安装</h4><p><strong>1）在Linux中安装Redis</strong></p><p>在Linux系统安装Redis步骤：</p><ol><li>将Redis安装包上传到Linux</li><li>解压安装包，命令：&#x3D;&#x3D;tar -zxvf redis-4.0.0.tar.gz -C &#x2F;usr&#x2F;local&#x3D;&#x3D;</li><li>安装Redis的依赖环境gcc，命令：&#x3D;&#x3D;yum install -y gcc-c++&#x3D;&#x3D;</li><li>进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0，进行编译，命令：&#x3D;&#x3D;make&#x3D;&#x3D;</li><li>进入redis的src目录进行安装，命令：&#x3D;&#x3D;make install&#x3D;&#x3D;</li></ol><p>安装后重点文件说明：</p><blockquote><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-server：Redis服务启动脚本</p><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-cli：Redis客户端脚本</p><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;redis.conf：Redis配置文件</p></blockquote><p><strong>2）在Windows中安装Redis</strong></p><p>Redis的Windows版属于绿色软件，直接解压即可使用，解压后目录结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sl2swwj20sp0bqq48.jpg" alt="image-20210927093112281"></p><h3 id="2-3-Redis服务启动与停止"><a href="#2-3-Redis服务启动与停止" class="headerlink" title="2.3 Redis服务启动与停止"></a>2.3 Redis服务启动与停止</h3><p><strong>1）Linux系统中启动和停止Redis</strong></p><p>执行Redis服务启动脚本文件&#x3D;&#x3D;redis-server&#x3D;&#x3D;：</p><p><code>路径：</code></p><p><code>/usr/local/redis-4.0.0/src/redis-server</code></p><p><code>/usr/local/redis-4.0.0/src/redis-cli</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5spmhpoj216c0k4jxz.jpg" alt="image-20210927094452556"></p><p>通过启动日志可以看到，Redis默认端口号为&#x3D;&#x3D;6379&#x3D;&#x3D;。</p><p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p><p>通过&#x3D;&#x3D;redis-cli&#x3D;&#x3D;可以连接到本地的Redis服务，默认情况下不需要认证即可连接成功。</p><p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p><p><strong>2）Windows系统中启动和停止Redis</strong></p><p>Windows系统中启动Redis，直接双击redis-server.exe即可启动Redis服务，redis服务默认端口号为6379</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqhzd8j20xz0hrdix.jpg" alt="image-20210927100421213"></p><p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p><p>双击&#x3D;&#x3D;redis-cli.exe&#x3D;&#x3D;即可启动Redis客户端，默认连接的是本地的Redis服务，而且不需要认证即可连接成功。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sqsuvzj20xz0hr0t8.jpg" alt="image-20210927100319016"></p><p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p><h3 id="2-4-Redis配置文件"><a href="#2-4-Redis配置文件" class="headerlink" title="2.4 Redis配置文件"></a>2.4 Redis配置文件</h3><p>前面我们已经启动了Redis服务，默认情况下Redis启动后是在前台运行，而且客户端不需要密码就可以连接到Redis服务。如果我们希望Redis服务启动后是在后台运行，同时希望客户端认证通过后才能连接到Redis服务，应该如果做呢？</p><p>此时就需要修改Redis的配置文件：</p><ul><li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li><li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li></ul><p><strong>通过修改Redis配置文件可以进行如下配置：</strong></p><p><strong>1）</strong>设置Redis服务后台运行</p><p>​    将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p><p>​    注意：Windows版的Redis不支持后台运行。</p><p><strong>2）</strong>设置Redis服务密码</p><p>​    将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p><p><strong>3）</strong>设置允许客户端远程连接Redis服务</p><p>​    Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p><p><strong>解释说明：</strong></p><blockquote><p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p><p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p><p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p><p>requirepass：设置Redis的连接密码</p><p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p></blockquote><p><strong>注意</strong>：修改配置文件后需要重启Redis服务配置才能生效，&#x3D;&#x3D;并且&#x3D;&#x3D;启动Redis服务时需要显示的指定配置文件：</p><p>1）Linux中启动Redis服务</p><pre class="line-numbers language-none"><code class="language-none"># 进入Redis安装目录cd &#x2F;usr&#x2F;local&#x2F;redis-4.0.0# 启动Redis服务，指定使用的配置文件.&#x2F;src&#x2F;redis-server .&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2）Windows中启动Redis服务</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ssqiloj20xz0e4dit.jpg" alt="image-20210927104929169"></p><p>由于Redis配置文件中开启了认证校验，即客户端连接时需要提供密码，此时客户端连接方式变为：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5sti807j20ny09uq3j.jpg" alt="image-20210927105909600"></p><p><strong>解释说明：</strong></p><blockquote><p>-h：指定连接的Redis服务的ip地址</p><p>-p：指定连接的Redis服务的端口号</p><p>-a：指定连接的Redis服务的密码</p></blockquote><h2 id="3-Redis数据类型"><a href="#3-Redis数据类型" class="headerlink" title="3. Redis数据类型"></a>3. Redis数据类型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set &#x2F; zset</li></ul><h3 id="3-2-Redis-5种常用数据类型"><a href="#3-2-Redis-5种常用数据类型" class="headerlink" title="3.2 Redis 5种常用数据类型"></a>3.2 Redis 5种常用数据类型</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5svuyd2j20od0e50tf.jpg" alt="image-20210927111819871"></p><p><strong>解释说明：</strong></p><blockquote><p>字符串(string)：普通字符串，常用</p><p>哈希(hash)：适合存储对象</p><p>列表(list)：按照插入顺序排序，可以有重复元素</p><p>集合(set)：无序集合，没有重复元素</p><p>有序集合(sorted set &#x2F; zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</p></blockquote><h2 id="4-Redis常用命令"><a href="#4-Redis常用命令" class="headerlink" title="4. Redis常用命令"></a>4. Redis常用命令</h2><h3 id="4-1-字符串string操作命令"><a href="#4-1-字符串string操作命令" class="headerlink" title="4.1 字符串string操作命令"></a>4.1 字符串string操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value                              设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p><h3 id="4-2-哈希hash操作命令"><a href="#4-2-哈希hash操作命令" class="headerlink" title="4.2 哈希hash操作命令"></a>4.2 哈希hash操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t21hlmj20m503jmx3.jpg" alt="image-20210927113014567"></p><h3 id="4-3-列表list操作命令"><a href="#4-3-列表list操作命令" class="headerlink" title="4.3 列表list操作命令"></a>4.3 列表list操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t3ub6oj20nh042t8n.jpg" alt="image-20210927113312384"></p><p>list特点：双端阻塞队列</p><p>操作技巧：FIFO，先进先出。</p><h3 id="4-4-集合set操作命令"><a href="#4-4-集合set操作命令" class="headerlink" title="4.4 集合set操作命令"></a>4.4 集合set操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t66f4mj20ma03xgli.jpg" alt="image-20210927113632472"></p><h3 id="4-5-有序集合sorted-set操作命令"><a href="#4-5-有序集合sorted-set操作命令" class="headerlink" title="4.5 有序集合sorted set操作命令"></a>4.5 有序集合sorted set操作命令</h3><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5t72qyej20ng04pt8n.jpg" alt="image-20210927114003383"></p><h3 id="4-6-通用命令"><a href="#4-6-通用命令" class="headerlink" title="4.6 通用命令"></a>4.6 通用命令</h3><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><p><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </p></li><li><p><strong>EXISTS</strong> key  检查给定 key 是否存在</p></li><li><p><strong>TYPE</strong> key  返回 key 所储存的值的类型</p></li><li><p><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</p></li><li><p><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</p><p><code>keys * 引发的宕机事故：</code><a href="https://blog.csdn.net/u014756578/article/details/91951793">https://blog.csdn.net/u014756578/article/details/91951793</a></p></li></ul><h2 id="5-在Java中操作Redis"><a href="#5-在Java中操作Redis" class="headerlink" title="5. 在Java中操作Redis"></a>5. 在Java中操作Redis</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span><span class="token punctuation">;</span><span class="token comment">/** * 使用Jedis操作Redis */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//1 获取连接</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//2 执行具体的操作</span>        jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//jedis.del("username");</span>        jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"myhash"</span><span class="token punctuation">,</span><span class="token string">"addr"</span><span class="token punctuation">,</span><span class="token string">"bj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> hValue <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hget</span><span class="token punctuation">(</span><span class="token string">"myhash"</span><span class="token punctuation">,</span> <span class="token string">"addr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3 关闭连接</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-Spring-Data-Redis"><a href="#5-3-Spring-Data-Redis" class="headerlink" title="5.3 Spring Data Redis"></a>5.3 Spring Data Redis</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tadff7j21810r67b7.jpg" alt="image-20210927143741458"></p><p>maven坐标：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.data<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Boot提供了对应的Starter，maven坐标：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><h4 id="5-3-2-使用方式"><a href="#5-3-2-使用方式" class="headerlink" title="5.3.2 使用方式"></a>5.3.2 使用方式</h4><h5 id="5-3-2-1-环境搭建"><a href="#5-3-2-1-环境搭建" class="headerlink" title="5.3.2.1 环境搭建"></a>5.3.2.1 环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.itheima<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springdataredis_demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步：编写启动类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">App</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三步：配置application.yml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> springdataredis_demo  <span class="token comment">#Redis相关配置</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token comment">#password: 123456</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token comment">#操作的是0号数据库</span>    <span class="token key atrule">jedis</span><span class="token punctuation">:</span>      <span class="token comment">#Redis连接池配置</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span> <span class="token comment">#最大连接数</span>        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> 1ms <span class="token comment">#连接池最大阻塞等待时间</span>        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment">#连接池中的最大空闲连接</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token comment">#连接池中的最小空闲连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><p>第四步：提供配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">CachingConfigurerSupport</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span></span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token class-name">StringRedisSerializer</span><span class="token punctuation">;</span><span class="token comment">/** * Redis配置类 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> redisTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><p>第五步：提供测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringDataRedisTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-2-操作字符串类型数据"><a href="#5-3-2-2-操作字符串类型数据" class="headerlink" title="5.3.2.2 操作字符串类型数据"></a>5.3.2.2 操作字符串类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 操作String类型数据*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//存值</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"city123"</span><span class="token punctuation">,</span><span class="token string">"beijing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"city123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值，同时设置过期时间</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span><span class="token string">"value1"</span><span class="token punctuation">,</span><span class="token number">10l</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值，如果存在则不执行任何操作</span>    <span class="token class-name">Boolean</span> aBoolean <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"city1234"</span><span class="token punctuation">,</span> <span class="token string">"nanjing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aBoolean<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-3-操作哈希类型数据"><a href="#5-3-2-3-操作哈希类型数据" class="headerlink" title="5.3.2.3 操作哈希类型数据"></a>5.3.2.3 操作哈希类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 操作Hash类型数据*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">HashOperations</span> hashOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值</span>    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hashOperations<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token punctuation">,</span><span class="token string">"bj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    <span class="token class-name">String</span> age <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> hashOperations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获得hash结构中的所有字段</span>    <span class="token class-name">Set</span> keys <span class="token operator">=</span> hashOperations<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//获得hash结构中的所有值</span>    <span class="token class-name">List</span> values <span class="token operator">=</span> hashOperations<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-4-操作列表类型数据"><a href="#5-3-2-4-操作列表类型数据" class="headerlink" title="5.3.2.4 操作列表类型数据"></a>5.3.2.4 操作列表类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 操作List类型的数据*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">ListOperations</span> listOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值</span>    listOperations<span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    listOperations<span class="token punctuation">.</span><span class="token function">leftPushAll</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> mylist <span class="token operator">=</span> listOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> value <span class="token operator">:</span> mylist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//获得列表长度 llen</span>    <span class="token class-name">Long</span> size <span class="token operator">=</span> listOperations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> lSize <span class="token operator">=</span> size<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//出队列</span>        <span class="token class-name">String</span> element <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> listOperations<span class="token punctuation">.</span><span class="token function">rightPop</span><span class="token punctuation">(</span><span class="token string">"mylist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-5-操作集合类型数据"><a href="#5-3-2-5-操作集合类型数据" class="headerlink" title="5.3.2.5 操作集合类型数据"></a>5.3.2.5 操作集合类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 操作Set类型的数据*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">SetOperations</span> setOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值</span>    setOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myset <span class="token operator">=</span> setOperations<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> o <span class="token operator">:</span> myset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//删除成员</span>    setOperations<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    myset <span class="token operator">=</span> setOperations<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> o <span class="token operator">:</span> myset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-6-操作有序集合类型数据"><a href="#5-3-2-6-操作有序集合类型数据" class="headerlink" title="5.3.2.6 操作有序集合类型数据"></a>5.3.2.6 操作有序集合类型数据</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 操作ZSet类型的数据*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testZset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">ZSetOperations</span> zSetOperations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForZSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//存值</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">11.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">12.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">13.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//修改分数</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">incrementScore</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//删除成员</span>    zSetOperations<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取值</span>    myZset <span class="token operator">=</span> zSetOperations<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> myZset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-2-7-通用操作"><a href="#5-3-2-7-通用操作" class="headerlink" title="5.3.2.7 通用操作"></a>5.3.2.7 通用操作</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 通用操作，针对不同的数据类型都可以操作*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//获取Redis中所有的key</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//判断某个key是否存在</span>    <span class="token class-name">Boolean</span> itcast <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>itcast<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//删除指定key</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"myZset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取指定key对应的value的数据类型</span>    <span class="token class-name">DataType</span> dataType <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token string">"myset"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dataType<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis相关技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的常用命令</title>
      <link href="/2022/05/12/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/12/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="停止防火墙"><a href="#停止防火墙" class="headerlink" title="#停止防火墙"></a>#停止防火墙</h4><p>systemctl stop firewalld</p><h4 id="禁用防火墙开机启动"><a href="#禁用防火墙开机启动" class="headerlink" title="#禁用防火墙开机启动"></a>#禁用防火墙开机启动</h4><p>systemctl disable firewalld</p><h4 id="停止网络管理器"><a href="#停止网络管理器" class="headerlink" title="#停止网络管理器"></a>#停止网络管理器</h4><p>systemctl stop NetworkManager</p><h4 id="禁止开机自启"><a href="#禁止开机自启" class="headerlink" title="#禁止开机自启"></a>#禁止开机自启</h4><p>systemctl disable NetworkManager</p><h4 id="加压jdk"><a href="#加压jdk" class="headerlink" title="#加压jdk"></a>#加压jdk</h4><p>tar -zxvf jdk-8u171-linux-x64.tar.gz -C &#x2F;usr&#x2F;local</p><h4 id="配置jdk的环境变量"><a href="#配置jdk的环境变量" class="headerlink" title="#配置jdk的环境变量"></a>#配置jdk的环境变量</h4><p>echo ‘JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p><h4 id="重新加载文件"><a href="#重新加载文件" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p><h4 id="查看jdk版本"><a href="#查看jdk版本" class="headerlink" title="#查看jdk版本"></a>#查看jdk版本</h4><p>java -version</p><h4 id="解压tomcat"><a href="#解压tomcat" class="headerlink" title="#解压tomcat"></a>#解压tomcat</h4><p>tar -zxvf apache-tomcat-7.0.57.tar.gz -C &#x2F;usr&#x2F;local</p><h4 id="卸载mariadb数据库"><a href="#卸载mariadb数据库" class="headerlink" title="#卸载mariadb数据库"></a>#卸载mariadb数据库</h4><p>rpm -e –nodeps  <code>rpm -qa | grep mariadb</code></p><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="#创建文件夹"></a>#创建文件夹</h4><p>mkdir &#x2F;usr&#x2F;local&#x2F;mysql</p><h4 id="解压mysql"><a href="#解压mysql" class="headerlink" title="#解压mysql"></a>#解压mysql</h4><p>tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C &#x2F;usr&#x2F;local&#x2F;mysql</p><h4 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="#安装依赖环境"></a>#安装依赖环境</h4><p>yum install -y net-tools perl libaio openssl gcc pcre-devel zlib-devel openssl vim openssl-devel</p><h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="#安装mysql"></a>#安装mysql</h4><p>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-common-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-devel-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-client-5.7.25-1.el7.x86_64.rpm<br>rpm -ivh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql-community-server-5.7.25-1.el7.x86_64.rpm</p><h4 id="开启mysql服务"><a href="#开启mysql服务" class="headerlink" title="#开启mysql服务"></a>#开启mysql服务</h4><p>systemctl start mysqld</p><h4 id="查看临时密码"><a href="#查看临时密码" class="headerlink" title="#查看临时密码"></a>#查看临时密码</h4><p>cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</p><h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="#登录数据库"></a>#登录数据库</h4><p>mysql -uroot -p</p><pre><code>set global validate_password_length=4;set global validate_password_policy=LOW;set password = password(&#39;root&#39;);grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;flush privileges;</code></pre><h4 id="修改MySQL编码"><a href="#修改MySQL编码" class="headerlink" title="#修改MySQL编码"></a>#修改MySQL编码</h4><p>vim &#x2F;etc&#x2F;my.cnf</p><pre><code>[client]default_character_set=utf8[mysql]default_character_set=utf8[mysqld]character_set_server=utf8</code></pre><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="#重启服务"></a>#重启服务</h4><p>systemctl restart mysqld</p><h4 id="查看数据库编码"><a href="#查看数据库编码" class="headerlink" title="#查看数据库编码"></a>#查看数据库编码</h4><p>mysql -uroot -proot -e “show variables like ‘%char%’;”</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="#安装git"></a>#安装git</h4><p>yum install -y git</p><h4 id="解压maven"><a href="#解压maven" class="headerlink" title="#解压maven"></a>#解压maven</h4><p>tar -zxvf apache-maven-3.5.4-bin.tar.gz -C &#x2F;usr&#x2F;local</p><h4 id="配置maven环境变量"><a href="#配置maven环境变量" class="headerlink" title="#配置maven环境变量"></a>#配置maven环境变量</h4><p>echo ‘MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4’ &gt;&gt; &#x2F;etc&#x2F;profile<br>echo ‘PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile</p><h4 id="重新加载文件-1"><a href="#重新加载文件-1" class="headerlink" title="#重新加载文件"></a>#重新加载文件</h4><p>source &#x2F;etc&#x2F;profile</p><h4 id="查看maven版本"><a href="#查看maven版本" class="headerlink" title="#查看maven版本"></a>#查看maven版本</h4><p>mvn -v</p><h4 id="删除settings文件"><a href="#删除settings文件" class="headerlink" title="#删除settings文件"></a>#删除settings文件</h4><p>rm -rf &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p><h4 id="拷贝settings文件"><a href="#拷贝settings文件" class="headerlink" title="#拷贝settings文件"></a>#拷贝settings文件</h4><p>cp &#x2F;root&#x2F;settings.xml  &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4&#x2F;conf&#x2F;settings.xml</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="#本地仓库"></a>#本地仓库</h4><p>mv &#x2F;root&#x2F;repo &#x2F;usr&#x2F;local</p><h4 id="修改静态IP"><a href="#修改静态IP" class="headerlink" title="#修改静态IP"></a>#修改静态IP</h4><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32</p><p> BOOTPROTO&#x3D;static<br> IPADDR&#x3D;192.168.100.100<br> GATEWAY&#x3D;192.168.100.2<br> NETMASK&#x3D;255.255.255.0<br> DNS1&#x3D;8.8.8.8</p><h4 id="重启网卡"><a href="#重启网卡" class="headerlink" title="#重启网卡"></a>#重启网卡</h4><p>systemctl restart network</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NEGINX学习总结</title>
      <link href="/2022/05/11/NGINX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/11/NGINX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-概述"><a href="#Nginx-概述" class="headerlink" title="Nginx-概述"></a>Nginx-概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q6nrd7j206t01pgli.jpg" alt="image-20210829234142590"> </p><p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</p><p>Nginx是由<strong>伊戈尔·赛索耶夫</strong>为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>官网：<a href="https://nginx.org/">https://nginx.org/</a></p><h3 id="4-2-下载和安装"><a href="#4-2-下载和安装" class="headerlink" title="4.2 下载和安装"></a>4.2 下载和安装</h3><h4 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h4><p>在Nginx的官网的下载页面中(<a href="http://nginx.org/en/download.html)%EF%BC%8C%E5%B0%B1%E5%B1%95%E7%A4%BA%E4%BA%86%E5%BD%93%E5%89%8DNginx%E7%89%88%E6%9C%AC%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82">http://nginx.org/en/download.html)，就展示了当前Nginx版本，并提供了下载的连接。</a> 如下： </p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5q8htihj217c0inwk1.jpg" alt="image-20210829234623737" style="zoom:80%;" /> <p>在本项目中，我们所学习的Nginx选择的是稳定版本的1.16这个版本，我们可以直接从官网下载</p><h4 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2 安装"></a>4.2.2 安装</h4><p><strong>1). 安装依赖包</strong></p><p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p><pre class="line-numbers language-none"><code class="language-none">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2). 下载Nginx安装包</strong></p><pre class="line-numbers language-none"><code class="language-none">yum install wgetwget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>wget : </p><p>​    wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。</p></blockquote><p>执行完wget指令后，就会在当前所在目录看到下载下来的文件。</p><p><strong>3). 解压nginx压缩包</strong></p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4). 配置Nginx编译环境</strong></p><pre class="line-numbers language-none"><code class="language-none">cd nginx-1.16.1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明: </p><p>​    –prefix 指定的目录，就是我们安装Nginx的目录。</p><p><strong>5). 编译&amp;安装</strong></p><pre class="line-numbers language-none"><code class="language-none">make &amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-目录结构"><a href="#4-3-目录结构" class="headerlink" title="4.3 目录结构"></a>4.3 目录结构</h3><p>安装完Nginx后，我们可以切换到Nginx的安装目录(&#x2F;usr&#x2F;local&#x2F;nginx)，先来熟悉一下Nginx的目录结构，如下图：</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qd1z0zj21310jl78b.jpg" alt="image-20210830000933352" style="zoom:90%;" /> <blockquote><p>备注： </p><p>​    上述我们用到的一个指令 tree，该指令可以将我们指定的目录以树状结构展示出来。如果没有这个指令，可以通过以下指令进行安装。</p><p>​    yum install tree</p></blockquote><p>重点目录和文件如下: </p><table><thead><tr><th>目录&#x2F;文件</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>conf</td><td>配置文件的存放目录</td><td></td></tr><tr><td>conf&#x2F;nginx.conf</td><td>Nginx的核心配置文件</td><td>conf下有很多nginx的配置文件，我们主要操作这个核心配置文件</td></tr><tr><td>html</td><td>存放静态资源(html, css, )</td><td>部署到Nginx的静态资源都可以放在html目录中</td></tr><tr><td>logs</td><td>存放nginx日志(访问日志、错误日志等)</td><td></td></tr><tr><td>sbin&#x2F;nginx</td><td>二进制文件，用于启动、停止Nginx服务</td><td></td></tr></tbody></table><h2 id="5-Nginx-命令"><a href="#5-Nginx-命令" class="headerlink" title="5. Nginx-命令"></a>5. Nginx-命令</h2><h3 id="5-1-常用命令"><a href="#5-1-常用命令" class="headerlink" title="5.1 常用命令"></a>5.1 常用命令</h3><p>Nginx中，我们的二进制可执行文件(nginx)存放在sbin目录下，虽然只有一个可执行文件，但是我们可以通过该指令配合不同的参数达到更加强大的功能。接下来，我们就演示一下Nginx常见指令, 在执行下面的指令时,都需要在&#x3D;&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;&#x3D;&#x3D;目录下执行。</p><p><strong>1). 查看版本</strong></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qdraafj213002d0t9.jpg" alt="image-20210830223435585"> </p><p><strong>2). 检查配置文件</strong></p><p>修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf&#x2F;nginx.conf文件配置的是否有错误，命令如下：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qfj1shj211z03u75q.jpg" alt="image-20210830223511878"> </p><p><strong>3). 启动</strong></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qglixpj2139036t9x.jpg" alt="image-20210830224019661"> </p><p>注意： nginx服务启动后，默认就会有两个进程。</p><p>启动之后，我们可以直接访问Nginx的80端口， <a href="http://192.168.200.200/">http://192.168.200.200</a></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qiatq9j20wg07e0u8.jpg" alt="image-20210830224605952" style="zoom:80%;" /> <blockquote><p>注意：</p><p>​    要想正常访问Nginx，需要关闭防火墙或开放指定端口号，执行的指令如下： </p><p>​    A. 关闭防火墙</p><p>​        systemctl stop firewalld</p><p>​    B. 开放80端口</p><p>​        firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p><p>​        firewall-cmd –reload</p></blockquote><p><strong>4). 停止</strong></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -s stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止之后，我们可以查看nginx的进程： </p><pre class="line-numbers language-none"><code class="language-none">ps -ef|grep nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qkle8hj21550330tk.jpg" alt="image-20210830224121489"> </p><p><strong>5). 重新加载</strong></p><p>当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>在上述我们在使用nginx命令在进行服务的启动、停止、重新加载时，都需要用到一个指令nginx，而这个指令是在nginx&#x2F;sbin目录下的，我们每一次使用这个指令都需要切换到sbin目录才可以，使用相对繁琐。那么我们能不能在任意目录下都可以执行该指令来操作nginx呢？答案是可以的，配置nginx的环境变量即可。</p><p>通过vim编辑器，打开&#x2F;etc&#x2F;profile文件, 在PATH环境变量中增加nginx的sbin目录，如下： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qmhcirj20v302wt9b.jpg" alt="image-20210830225544343"> </p><p>修改完配置文件之后，需要执行 source &#x2F;etc&#x2F;profile 使文件生效。 接下来，我们就可以在任意目录下执行nginx的指令了，如： </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qoam9sj2127043t9y.jpg" alt="image-20210830225702899"> </p><h2 id="6-Nginx-应用"><a href="#6-Nginx-应用" class="headerlink" title="6. Nginx-应用"></a>6. Nginx-应用</h2><p>介绍了并安装了Nginx之后，本章节将要讲解的是Nginx的使用，我们主要从以下四个方面进行讲解。</p><h3 id="6-1-配置文件结构"><a href="#6-1-配置文件结构" class="headerlink" title="6.1 配置文件结构"></a>6.1 配置文件结构</h3><p>nginx的配置文件(conf&#x2F;nginx.conf)整体上分为三部分: 全局块、events块、http块。这三块的分别配置什么样的信息呢，看下表： </p><table><thead><tr><th>区域</th><th>职责</th></tr></thead><tbody><tr><td>全局块</td><td>配置和nginx运行相关的全局配置</td></tr><tr><td>events块</td><td>配置和网络连接相关的配置</td></tr><tr><td>http块</td><td>配置代理、缓存、日志记录、虚拟主机等配置</td></tr></tbody></table><p>具体结构图如下: </p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5qun39kj20rf0k7dj8.jpg" alt="image-20210830230827686" style="zoom:80%;" /> <blockquote><p>在全局块、events块以及http块中，我们经常配置的是http块。</p><p>在http块中可以包含多个server块,每个server块可以配置多个location块。</p></blockquote><h3 id="6-2-部署静态资源"><a href="#6-2-部署静态资源" class="headerlink" title="6.2 部署静态资源"></a>6.2 部署静态资源</h3><h4 id="6-2-1-介绍"><a href="#6-2-1-介绍" class="headerlink" title="6.2.1 介绍"></a>6.2.1 介绍</h4><p><strong>Nginx可以作为静态web服务器来部署静态资源</strong>。这里所说的静态资源是指在服务端真实存在，并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p><p><strong>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</strong></p><p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;#监听端口</span><span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;#服务器名称</span><span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;#匹配客户端请求url</span><span class="token attr-name">        root</span> <span class="token attr-value">html;#指定静态资源根目录</span><span class="token attr-name">        index</span> <span class="token attr-value">index.html;#指定默认首页</span>    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-2-测试"><a href="#6-2-2-测试" class="headerlink" title="6.2.2 测试"></a>6.2.2 测试</h4><p>在资料中，我们提供了一个静态的html文件，我们需要将这个文件部署到nginx中，然后通过nginx访问html静态资源。</p><p><strong>1). 将静态资源上传到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html 目录</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r16sh0j213v04qmyi.jpg" alt="image-20210830232238402"> </p><p><strong>2). 启动nginx</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r27gfuj214609dadc.jpg" alt="image-20210830232419462"> </p><p><strong>3). 访问</strong></p><p><a href="http://192.168.100.100/hello.html">http://192.168.100.100/hello.html</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r4itx5j20g605daa9.jpg" alt="image-20220220180550093"> </p><p><a href="http://192.168.100.100/">http://192.168.100.100</a> ， 访问该地址，访问的是nginx的默认首页</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r6eu4aj20lv0a8ta8.jpg" alt="image-20220220180207165"></p><p><strong>4). 配置首页</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r5ooaij20lv0a8ta8.jpg" alt="image-20210830232720821"> </p><p>如果我们需要将hello.html作为nginx的首页，可以修改location的index指令，配置为hello.html，如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r9td6ij214609dadc.jpg" alt="image-20210830233019489"> </p><p>配置完毕后，我们可以通过指令，来检查配置文件是否配置正确： nginx -t</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5r82i9mj214609dadc.jpg" alt="image-20210830233122708"> </p><p>配置文件修改了，我们需要重新加载一下，才可以生效： </p><pre class="line-numbers language-none"><code class="language-none">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5). 访问</strong></p><p><a href="http://192.168.100.100/">http://192.168.100.100</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5radelvj20h4054weq.jpg" alt="image-20220220180805583"> </p><h3 id="6-3-反向代理"><a href="#6-3-反向代理" class="headerlink" title="6.3 反向代理"></a>6.3 反向代理</h3><h4 id="6-3-1-概念介绍"><a href="#6-3-1-概念介绍" class="headerlink" title="6.3.1 概念介绍"></a>6.3.1 概念介绍</h4><p>1). 正向代理</p><p>正向代理服务器是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p><strong>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径</strong>。</p><p>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rdb0ajj20h507imxi.jpg" alt="image-20210830233450415"> </p><p>2). 反向代理</p><p>反向代理服务器位于用户与目标服务器之间，<strong>但是对于用户而言，反向代理服务器就相当于目标服务器</strong>，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。<strong>用户不需要知道目标服务器的地址，也无须在用户端作任何设定，对于用户来说，访问反向代理服务器是完全无感知的。</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rewzahj20of09o754.jpg" alt="image-20210830233634695"> </p><p>那么在本小节，我们就是要使用nginx来作为反向代理服务器使用。 在nginx中，我们可以在nginx.conf中配置反向代理: </p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://192.168.100.200:8080; #反向代理配置，将请求转发到指定服务</span>    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置的含义为: 当我们访问nginx的80端口时，</p><p>根据反向代理配置，会将请求转发到 <a href="http://192.168.100.200:8080/">http://192.168.100.200:8080</a> 对应的服务上。</p><h4 id="6-3-2-测试"><a href="#6-3-2-测试" class="headerlink" title="6.3.2 测试"></a>6.3.2 测试</h4><p>需求: 在192.168.100.200这台服务器中部署了java应用，运行端口为8080，并提供了一个可访问的链接 &#x2F;hello。现在我们需要在访问nginx时，通过nginx将请求转发到192.168.100.200:8080的服务。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rgs9s9j20rc06vq3j.jpg" alt="image-20210830235803013" style="zoom:67%;" /> <p><strong>1). 在192.168.100.200 部署服务并启动</strong></p><p>将资料中提供的 helloworld-8080.jar 上传到服务器端，并通过指令 java -jar helloworld-8080.jar 运行服务。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rmlqi8j21g40hu48d.jpg" alt="image-20210831000152199"> </p><p><strong>2). 在192.168.100.100中的nginx.conf中配置反向代理</strong></p><p>进入nginx的安装目录，并编辑配置文件nginx.conf:</p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;vim nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">&#123;</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">localhost;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://192.168.100.200:8080; #反向代理配置，将请求转发到指定服务</span>    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3). 检查配置文件，并重新加载</strong></p><pre class="line-numbers language-none"><code class="language-none">nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rnv8hxj213u02dmy1.jpg" alt="image-20210831001021252"> </p><pre class="line-numbers language-none"><code class="language-none">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4). 访问</strong> </p><p><a href="http://192.168.100.100/">http://192.168.100.100</a></p><h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><h4 id="6-4-1-概念介绍"><a href="#6-4-1-概念介绍" class="headerlink" title="6.4.1 概念介绍"></a>6.4.1 概念介绍</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p><p><strong>应用集群：</strong>将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p><p><strong>负载均衡器：</strong>将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rogb0lj213u02dmy1.jpg" alt="image-20210831080743617" style="zoom:80%;" />  <p>此处的负载均衡器，我们将会使用Nginx来实现，而Nginx的负载均衡是基于反向代理的，只不过此时所代理的服务器不是一台，而是多台。</p><h4 id="6-4-2-测试"><a href="#6-4-2-测试" class="headerlink" title="6.4.2 测试"></a>6.4.2 测试</h4><p><strong>1). 将资料中提供的两个jar包，上传到 192.168.100.200 服务器上</strong></p><table><thead><tr><th>jar</th><th>运行端口</th><th>请求链接</th><th>响应数据</th></tr></thead><tbody><tr><td>![image-20220511211247384](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211247384.png)</td><td>8080</td><td>&#x2F;hello</td><td>8080</td></tr><tr><td>![image-20220511211258476](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220511211258476.png)</td><td>8081</td><td>&#x2F;hello</td><td>8081</td></tr></tbody></table><blockquote><p>我们在测试时，并没有那么多服务器，我们可以在一台服务器中启动多个服务，运行在不同的端口号上进行测试。</p></blockquote><p><strong>2). 运行上传上来的两个jar包，运行端口分别是 8080 ， 8081</strong></p><p>由于我们执行 java -jar 指令会占用前台窗口，所以我们可以采用后台模式运行。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nohup java -jar helloworld-8080.jar &amp;&gt; helloworld-8080.log &amp;nohup java -jar helloworld-8081.jar &amp;&gt; helloworld-8081.log &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3). 在nginx中配置负载均衡</strong></p><p>打开nginx的配置文件nginx.conf并增加如下配置: </p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#upstream指令可以定义一组服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">targetserver&#123;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8080;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8081;</span>&#125;<span class="token attr-name">server</span> <span class="token attr-value">&#123;</span><span class="token attr-name">    listen</span> <span class="token attr-value">      80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value"> localhost;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ &#123;</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://targetserver;</span>    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的配置位置如下: </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rsejyxj20qc08s0tf.jpg" alt="image-20220220182717939"> </p><p><strong>4). 重新加载nginx配置文件,访问</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试时,我们直接访问nginx(<a href="http://192.168.100.100/">http://192.168.100.100</a>), 此时nginx会根据负载均衡策略,将请求转发到后面的两台服务器。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5s04giaj20p403omxc.jpg" alt="image-20220220182548353"> </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5rrfbfhj20ow03v74g.jpg" alt="image-20220220182613070"> </p><p>在上述的测试过程中，我们看到请求均衡的转发到了8080和8081，因为模式的负载均衡策略是&#x3D;&#x3D;轮询&#x3D;&#x3D;。</p><p><font color="red" size="5">注意: 上述所有涉及到的端口号，都需要在对应的服务器的防火墙中开放，或者彻底关闭防火墙</font></p><h4 id="6-4-3-负载均衡策略"><a href="#6-4-3-负载均衡策略" class="headerlink" title="6.4.3 负载均衡策略"></a>6.4.3 负载均衡策略</h4><p>处理上述默认的轮询策略以外，在Nginx中还提供了其他的负载均衡策略，如下： </p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th>特点</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td><td></td></tr><tr><td>weight</td><td>权重方式</td><td>根据权重分发请求,权重大的分配到请求的概率大</td></tr><tr><td>ip_hash</td><td>依据ip分配方式</td><td>根据客户端请求的IP地址计算hash值， 根据hash值来分发请求, 同一个IP发起的请求, 会发转发到同一个服务器上</td></tr><tr><td>least_conn</td><td>依据最少连接方式</td><td>哪个服务器当前处理的连接少, 请求优先转发到这台服务器</td></tr><tr><td>url_hash</td><td>依据url分配方式</td><td>根据客户端请求url的hash值，来分发请求, 同一个url请求, 会发转发到同一个服务器上</td></tr><tr><td>fair</td><td>依据响应时间方式</td><td>优先把请求分发给处理请求时间短的服务器</td></tr></tbody></table><p>权重的配置： </p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#upstream指令可以定义一组服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">targetserver&#123;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8080 weight=10;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.100.200:8081 weight=5;</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置的weight权重是相对的，在上述的配置中，效果就是，在大数据量的请求下，最终8080接收的请求数是8081的两倍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库主从复制</title>
      <link href="/2022/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8CShardingJDBC/"/>
      <url>/2022/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8CShardingJDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL主从复制"><a href="#1-MySQL主从复制" class="headerlink" title="1. MySQL主从复制"></a>1. MySQL主从复制</h2><p>MySQL数据库默认是支持主从复制的，不需要借助于其他的技术，我们只需要在数据库中简单的配置即可。接下来，我们就从以下的几个方面，来介绍一下主从复制：</p><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的 <strong>二进制日志</strong> 功能。就是一台或多台MySQL数据库（slave，即<strong>从库</strong>）从另一台MySQL数据库（master，即<strong>主库</strong>）进行日志的复制，然后再解析日志并应用到自身，最终实现 <strong>从库</strong> 的数据和 <strong>主库</strong> 的数据保持一致。MySQL主从复制是<strong>MySQL数据库自带功能</strong>，无需借助第三方工具。</p><blockquote><p><strong>二进制日志：</strong> </p><p>​    二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句,包括改密码，<strong>但是不包括数据查询语句</strong>。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该<strong>binlog</strong>实现的。<strong>默认MySQL是未开启该日志的。</strong></p></blockquote><p><strong>MySQL的主从复制原理如下：</strong> </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5jw19fkj20fk0amq3k.jpg" alt="image-20220511204640329"></p><p><strong>MySQL复制过程分成三步：</strong></p><p>1). MySQL master 将数据变更写入二进制日志( binary log)</p><p>2). slave将master的binary log拷贝到它的中继日志（relay log）</p><p>3). slave重做中继日志中的事件，将数据变更反映它自己的数据</p><h3 id="1-2-主库配置"><a href="#1-2-主库配置" class="headerlink" title="1.2 主库配置"></a>1.2 主库配置</h3><p> <strong>1)修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong>**</p><p>在[mysqld]下面增加配置: </p><pre class="line-numbers language-none"><code class="language-none">log-bin&#x3D;mysql-bin   #[必须]启用二进制日志server-id&#x3D;100       #[必须]服务器唯一ID(唯一即可)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k0049hj20jp0a3q4f.jpg" alt="image-20220511205023685"></p><p><strong>2)重启Mysql服务</strong></p><p>执行指令： </p><pre class="line-numbers language-none"><code class="language-none">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k3zn92j20uo01ujro.jpg" alt="image-20210825115853116"> </p><p><strong>3). 创建数据同步的用户并授权</strong></p><p>登录mysql，并执行如下指令，创建用户并授权：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">'xiaoming'</span><span class="token variable">@'%'</span> identified <span class="token keyword">by</span> <span class="token string">'Root@123456'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>&#x3D;&#x3D;注：上面SQL的作用是创建一个用户 xiaoming ，密码为 Root@123456 ，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。&#x3D;&#x3D;</strong></p><blockquote><p>MySQL密码复杂程度说明: </p><p>​    <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k6qbwrj20ei03ejrt.jpg" alt="image-20210825144818269"> </p><p>​    目前mysql5.7默认密码校验策略等级为 MEDIUM , 该等级要求密码组成为: 数字、小写字母、大写字母 、特殊字符、长度至少8位</p></blockquote><p><strong>4). 登录Mysql数据库，查看master同步状态</strong></p><p>执行下面SQL，记录下结果中<strong>File</strong>和<strong>Position</strong>的值</p><pre class="line-numbers language-none"><code class="language-none">show master status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5k927f8j20xe04fab1.jpg" alt="image-20210825120355600"> </p><p><strong>&#x3D;&#x3D;注：上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作&#x3D;&#x3D;</strong></p><h3 id="1-3从库配置"><a href="#1-3从库配置" class="headerlink" title="1.3从库配置"></a>1.3从库配置</h3><p><strong>1). 修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong></p><pre class="line-numbers language-none"><code class="language-none">server-id&#x3D;200 #[必须]服务器唯一ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kbw5z0j207p02ajrc.jpg" alt="image-20220220175414871"> </p><p><strong>2). 重启Mysql服务</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3). 登录Mysql数据库，设置主库地址及同步位置</strong></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">change master to master_host&#x3D;&#39;8.130.21.14&#39;,master_user&#x3D;&#39;xiaoming&#39;,master_password&#x3D;&#39;Root@123456&#39;,master_log_file&#x3D;&#39;mysql-bin.000001&#39;,master_log_pos&#x3D;441;start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>参数说明： </p><p>​    A. master_host : 主库的IP地址</p><p>​    B. master_user : 访问主库进行主从复制的用户名(上面在主库创建的)</p><p>​    C. master_password : 访问主库进行主从复制的用户名对应的密码</p><p>​    D. master_log_file : 从哪个日志文件开始同步(上述查询master状态中展示的有)</p><p>​    E. master_log_pos : 从指定日志文件的哪个位置开始同步(上述查询master状态中展示的有)</p></blockquote><p><strong>4). 查看从数据库的状态</strong></p><pre class="line-numbers language-none"><code class="language-none">show slave status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过状态信息中的 Slave_IO_running 和 Slave_SQL_running 可以看出主从同步是否就绪，如果这两个参数全为Yes，表示主从同步已经配置完成。</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kjp6sxj210y0ofgrt.jpg" alt="image-20210825142313382"></p><blockquote><p>MySQL命令行技巧： </p><p>​    \G : 在MySQL的sql语句后加上\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行。即将查到的结构旋转90度变成纵向；</p></blockquote><h2 id="2-读写分离案例"><a href="#2-读写分离案例" class="headerlink" title="2. 读写分离案例"></a>2. 读写分离案例</h2><h3 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h3><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作<strong>，能够有效的避免由数据更新导致的行锁</strong>，使得整个系统的查询性能得到极大的改善。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5klfhcej20tn0b0jsg.jpg" alt="image-20210825145647274"> </p><p>通过读写分离,就可以降低单台数据库的访问压力, 提高访问效率，也可以避免单机故障。</p><p>主从复制的结构，我们在第一节已经完成了，那么我们在项目中，如何通过java代码来完成读写分离呢，如何在执行select的时候查询从库，而在执行insert、update、delete的时候，操作主库呢？这个时候，我们就需要介绍一个新的技术 ShardingJDBC。</p><h3 id="2-2-ShardingJDBC介绍"><a href="#2-2-ShardingJDBC介绍" class="headerlink" title="2.2 ShardingJDBC介绍"></a>2.2 ShardingJDBC介绍</h3><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p><p>Sharding-JDBC具有以下几个特点： </p><p>1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</p><p>2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</p><p>3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</p><h3 id="2-3-读写分离配置"><a href="#2-3-读写分离配置" class="headerlink" title="2.3 读写分离配置"></a>2.3 读写分离配置</h3><p>1). 在pom.xml中增加shardingJdbc的maven坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.shardingsphere<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>sharding-jdbc-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0.0-RC1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). 在application.yml中增加数据源的配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">shardingsphere</span><span class="token punctuation">:</span>    <span class="token key atrule">datasource</span><span class="token punctuation">:</span>      <span class="token key atrule">names</span><span class="token punctuation">:</span>        master<span class="token punctuation">,</span>slave      <span class="token comment"># 主数据源</span>      <span class="token key atrule">master</span><span class="token punctuation">:</span>        <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource        <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver        <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.100.100<span class="token punctuation">:</span>3306/rw<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>        <span class="token key atrule">username</span><span class="token punctuation">:</span> root        <span class="token key atrule">password</span><span class="token punctuation">:</span> root      <span class="token comment"># 从数据源</span>      <span class="token key atrule">slave</span><span class="token punctuation">:</span>        <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource        <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver        <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//192.168.100.200<span class="token punctuation">:</span>3306/rw<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span><span class="token number">8</span>        <span class="token key atrule">username</span><span class="token punctuation">:</span> root        <span class="token key atrule">password</span><span class="token punctuation">:</span> root    <span class="token key atrule">masterslave</span><span class="token punctuation">:</span>      <span class="token comment"># 读写分离配置</span>      <span class="token key atrule">load-balance-algorithm-type</span><span class="token punctuation">:</span> round_robin <span class="token comment">#轮询</span>      <span class="token comment"># 最终的数据源名称</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> dataSource      <span class="token comment"># 主库数据源名称</span>      <span class="token key atrule">master-data-source-name</span><span class="token punctuation">:</span> master      <span class="token comment"># 从库数据源名称列表，多个逗号分隔</span>      <span class="token key atrule">slave-data-source-names</span><span class="token punctuation">:</span> slave    <span class="token key atrule">props</span><span class="token punctuation">:</span>      <span class="token key atrule">sql</span><span class="token punctuation">:</span>        <span class="token key atrule">show</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#开启SQL显示，默认false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置解析: </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kqiiudj21e50de44v.jpg" alt="image-20210825162910711"> </p><p>3). 在application.yml中增加配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">main</span><span class="token punctuation">:</span>    <span class="token key atrule">allow-bean-definition-overriding</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该配置项的目的,就是如果当前项目中存在同名的bean,后定义的bean会覆盖先定义的。</p><p>spring中(spring.main.allow-bean-definition-overriding) 分析：<a href="https://blog.csdn.net/liubenlong007/article/details/87885567">https://blog.csdn.net/liubenlong007/article/details/87885567</a></p><p>&#x3D;&#x3D;如果不配置该项，项目启动之后将会报错：&#x3D;&#x3D; </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5kncntaj20tn0b0jsg.jpg" alt="image-20210825163737687"> </p><p>报错信息表明，在声明 org.apache.shardingsphere.shardingjdbc.spring.boot 包下的SpringBootConfiguration中的dataSource这个bean时出错, 原因是有一个同名的 dataSource 的bean在com.alibaba.druid.spring.boot.autoconfigure包下的DruidDataSourceAutoConfigure类加载时已经声明了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5koge4cj21e706ydim.jpg" alt="image-20210825164147056"> </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5krkhptj210y0ofgrt.jpg" alt="image-20210825164227927"> </p><p>而我们需要用到的是 shardingjdbc包下的dataSource，所以我们需要配置上述属性，让后加载的覆盖先加载的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的学习总结</title>
      <link href="/2022/05/11/JVM%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/11/JVM%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><ul><li>定义</li></ul><p>​    java 程序运行环境(java二进制字节码的运行环境)</p><ul><li>好处</li></ul><p>​    一次编写,到处运行</p><p>​    自动内存管理,垃圾回收功能</p><p>​    数组下标越界检查</p><p>​    多态</p><ul><li>比较</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5weo104j20mx0dx406.jpg" alt="image-20220511191019291"></p><h1 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5whivtvj20qs0e8ta9.jpg" alt="image-20220511192331436"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wj7543j20tl0gqgon.jpg" alt="WechatIMG244"></p><h1 id="内存结构之程序计数器-寄存器"><a href="#内存结构之程序计数器-寄存器" class="headerlink" title="内存结构之程序计数器(寄存器)"></a>内存结构之程序计数器(寄存器)</h1><p>作用:</p><p>​       记住下一条JVM指令的执行地址</p><p>特点:</p><p>​      线程私有随着线程创建而创建,随着线程销毁而销毁,每个线程都有自己的程序计数器</p><p>​      是一块比较小的内存空间,不会存在内存溢出</p><p>实现</p><p>​       计数器在物理上是通过寄存器来实现的</p><h1 id="内存结构之虚拟机栈"><a href="#内存结构之虚拟机栈" class="headerlink" title="内存结构之虚拟机栈"></a>内存结构之虚拟机栈</h1><p>线程运行时需要的内存空间,称为虚拟机栈</p><p>每个栈由多个栈帧(Frame)组成,对应着每次方法调用时所占用的内存</p><p>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法,也就是栈的最顶部</p><p>栈帧出栈时会释放掉携带的资源</p><p>问题辨析:</p><p>1.垃圾回收是否涉及栈内存?</p><p>​    不需要,因为方法调用产生的栈帧内存会随着方法调用的结束后弹出栈并且自动释放资源,被自动回收</p><p>2.栈内存分配越大越好吗?</p><p>​    并不是,每个栈内存大小初始值一般都是1024KB,除了windows系统会根据虚拟内存影响内存大小,栈内存越大</p><p>线程数越少,线程数少了就会影响执行效率,一般让栈内存扩大只是为了一些方法的递归调用,不容易栈溢出.并不会因为</p><p>栈内存越大,执行效率越高,反而会让线程减少,降低执行效率.(一般采用默认大小就可以了)</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wmfr7xj20bu0600t2.jpg" alt="image-20220511201653094"></p><p>3.方法内的局部变量是否线程安全?</p><p>​    首先要看,这个变量是对外共享的,还是对每个线程私有的,比如两个线程同时调用一个方法,方法中的局部变量是static修饰的,那么这个变量是共享的,因为静态变量只加载一次存在于静态区域,线程也就自然不安全,如果这个变量是个普通的局部变量,那么不会有线程安全问题,因为每个线程调用方法时都会生成对应线程的的栈帧.</p><p>​      <strong>如果方法内部局部变量没有逃离方法的作用访问,他是线程安全的</strong></p><p>​      <strong>如果局部变量引用了对象,并逃离了方法的作用范围,需要考虑线程安全问题</strong></p><h1 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h1><p>1.栈帧过多导致栈内存溢出</p><p>2.栈帧过大导致栈内存溢出</p><h1 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h1><h3 id="案例1-cpu占用过多"><a href="#案例1-cpu占用过多" class="headerlink" title="案例1:cpu占用过多"></a>案例1:cpu占用过多</h3><p>定位</p><p>1.用top定位那个进程对cpu的占用过高</p><p>2.通过Linux命令查看是哪条线程引起的cup占用过高</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看进程对cup占用情况-------&gt;只能定位进程,不能定位线程zhangminghao@zhangminghaodeMacBook-Pro ~ % topPID    COMMAND      %CPU TIME     #TH   #WQ   #PORT MEM    PURG   CMPRS  PGRP1704   FinalShell            63.3 02:14:05       150      0       1030  1364M       0B     360M   1704368    WindowServer     35.1 73:51.63        21        5       2665+ 379M-  43M+     57M       3681687   iTerm2                 30.8 04:04.45 8      5       314     54M    3536K     6608K       1687#查看线程对cup的占用情况#H:进程里的线程数#eo:需要展示的字段zhangminghao@zhangminghaodeMacBook-Pro ~ %  ps H -eo pid,tid,%cpu | grep 进程id    #利用jdk提供的工具命令,可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号zhangminghao@zhangminghaodeMacBook-Pro ~ % jstack 进程id   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过进程id的16进制来找出对应的线程,知道了是那个那个程序运行出了问题</strong></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wpm1lsj210b0ipn1g.jpg" alt="image-20220512203716530" style="zoom: 50%;" /><p><strong>通过信息找到java代码中的行号,检查到cpu占用过高的原因</strong></p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wr4cotj20c2076t96.jpg" alt="image-20220512203955346"  /><h3 id="案例2-运行很长时间没有结果"><a href="#案例2-运行很长时间没有结果" class="headerlink" title="案例2:运行很长时间没有结果"></a>案例2:运行很长时间没有结果</h3><p> 1,通过jstack 进程id命令查看线程执行信息</p><p>2.观察最后的输出结果(发现死锁问题)</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ws4yldj20t30g9dit.jpg" alt="image-20220512210643175"></p><h1 id="本地方法栈Native-Method-Stack"><a href="#本地方法栈Native-Method-Stack" class="headerlink" title="本地方法栈Native Method Stack"></a>本地方法栈Native Method Stack</h1><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>​    本地方法Native Method ,指的是那些不是JAVA代码编写的方法</p><h3 id="本地方法的作用"><a href="#本地方法的作用" class="headerlink" title="本地方法的作用"></a>本地方法的作用</h3><p>​    JAVA代码是受限制的,有时候不能直接跟底层操作系统打交道,需要调用一些 用C或者C++编写的本地方法来间接调用执行.</p><h1 id="Heap堆"><a href="#Heap堆" class="headerlink" title="Heap堆"></a>Heap堆</h1><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>​    通过new关键字,创建的对象都会使用堆内存,堆内存默认大小是4个G </p><h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><p>​    它是线程共享的,堆中对象都需要考虑线程安全问题</p><p>​    有垃圾回收机制</p><h3 id="堆内存的溢出问题"><a href="#堆内存的溢出问题" class="headerlink" title="堆内存的溢出问题"></a>堆内存的溢出问题</h3><p>​    java.lang.OutofMemoryError:Java heap space</p><h1 id="堆内存溢出的原因"><a href="#堆内存溢出的原因" class="headerlink" title="堆内存溢出的原因"></a>堆内存溢出的原因</h1><p>堆内存不是有垃圾回收机制吗,为什么还会有内存溢出的问题呢,原因是,堆内存的垃圾回收机制是在对象应用完毕后,才会自动回收,如果一个对象一直被引用,而且内存越来越大,就会导致堆内存溢出问题发发生,如以下代码:    </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>一直在做死循环做添加操作<span class="token punctuation">,</span>且是引用中状态<span class="token punctuation">,</span>导致堆不能垃圾回收            <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                a <span class="token operator">=</span> a<span class="token operator">+</span>a<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span>最终输出<span class="token number">26</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#异常信息<span class="token class-name">Exception</span> in thread <span class="token string">"main"</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> heap spaceat <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">3332</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>AbstractStringBuilder</span><span class="token punctuation">.</span><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token class-name">AbstractStringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">124</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>AbstractStringBuilder</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">AbstractStringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">448</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>StringBuilder</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">136</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test<span class="token punctuation">.</span></span>Test</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆内存默认为4G,通过设置堆内存空间为8m,发现在i值到达17的时候就内存溢出了,所以可以通过这种方式,尽早的暴露出内存溢出的问题:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5wvth3wj218o0u0tej.jpg" alt="image-20220513203904487"></p><h1 id="堆的内存诊断jmap"><a href="#堆的内存诊断jmap" class="headerlink" title="堆的内存诊断jmap"></a>堆的内存诊断jmap</h1><h3 id="1-jps工具"><a href="#1-jps工具" class="headerlink" title="1.jps工具:"></a>1.jps工具:</h3><p>​    是 java 提供的一个用来显示当前所有 java 进程的 pid 的命令,可以查看当前系统中有那些JAVA进程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">zhangminghao<span class="token annotation punctuation">@localhost</span> java<span class="token operator">-</span><span class="token class-name">Spring</span> <span class="token operator">%</span> jps <span class="token number">1488</span> <span class="token number">1956</span> <span class="token class-name">Jps</span><span class="token number">1684</span> <span class="token class-name">Launcher</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-jmap工具"><a href="#2-jmap工具" class="headerlink" title="2.jmap工具"></a>2.jmap工具</h3><p>​        jmap（Java Virtual Machine Memory Map）是JDK提供的一个可以生成Java虚拟机的堆转储快照dump文件的命令行工具。除此以外，jmap命令还可以查看finalize执行队列、Java堆和方法区的详细信息，比如空间使用率、当前使用的什么垃圾回收器、分代情况等等</p><p>​     查看堆内存占用情况heao进程id——&gt;&gt;jmap -heap 进程id</p><h3 id="3-jconsole工具"><a href="#3-jconsole工具" class="headerlink" title="3,jconsole工具"></a>3,jconsole工具</h3><p>​     图形界面的,多功能的检测工具,可以连续检测</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">zhangminghao<span class="token annotation punctuation">@localhost</span> java<span class="token operator">-</span><span class="token class-name">Spring</span> <span class="token operator">%</span> jconsole<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ww8dmgj20qf0713zs.jpg" alt="image-20220513210926906"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引(核心)</title>
      <link href="/2022/05/10/Mysql%E7%B4%A2%E5%BC%95-%E6%A0%B8%E5%BF%83/"/>
      <url>/2022/05/10/Mysql%E7%B4%A2%E5%BC%95-%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的概述"><a href="#索引的概述" class="headerlink" title="索引的概述"></a>索引的概述</h1><p>索引是帮助Mysql高效获取数据的一个有序的数据结构</p><p>优缺点</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tqtt6gj20r504ajru.jpg" alt="image-20220510102517966" style="zoom:150%;" /><h1 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h1><p>Mysql的索引是在存储引擎实层实现的,不同的存储索引有不同的结构,主要包括以下几种</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5trrd5nj20r907gdgr.jpg" alt="image-20220510102752768"></p><p>不同存储引擎支持的索引结构</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ts6jk2j20r407j3yx.jpg" alt="image-20220510102843612"></p><p><strong>平常所说的索引,如果没有特别指明,都是值B+树结构组织的索引</strong></p><h1 id="各个数据结构的优缺点"><a href="#各个数据结构的优缺点" class="headerlink" title="各个数据结构的优缺点"></a>各个数据结构的优缺点</h1><ul><li>二叉树和红黑树</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tu4tlzj20rz0cg3zr.jpg" alt="image-20220510103435512"></p><ul><li>B树(多路平衡查找树)</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txaoxkj20tc0cg3zw.jpg" alt="image-20220510103600779"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5txsdvfj20ry0c575o.jpg" alt="image-20220510104003733"><strong>B-Tree(B树)总结:①指针比key多一个②当key等于最大度数时(违背x阶时)中间元素向上分类</strong></p><ul><li>B+树</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5tz7djwj20ri08ydgp.jpg" alt="image-20220510104651047"></p><p><strong>B+Tree数相对于B-Tree区别:</strong></p><p><strong>①:所有数据都会出现在叶子节点</strong></p><p><strong>②:叶子节点行程一个单项链表的结构</strong></p><ul><li>Hash</li></ul><p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u4lqq4j20sc0cedht.jpg" alt="image-20220510105739506"></p><p>  索引特点:</p><p>  1.Hash索引只能用于对等比较(&#x3D;,in),不支持范围查询(between,&gt;,&lt;,…),因为存储顺序不一致</p><p>  2.无法利用索引完成排序操作</p><p>  3.查询效率高,通常只需要一次检索就可以了,效率通常要高于B+Tree树(这里的通常指的是,没有哈希碰撞的前提下)</p><p>​    存储引擎支持:</p><p>​    在Mysql中,支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能,hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的.</p><h1 id="Mysql中的B-树索引"><a href="#Mysql中的B-树索引" class="headerlink" title="Mysql中的B+树索引"></a>Mysql中的B+树索引</h1><p>Mysql索引数据结构对经典的B+Tree进行了优化,在原B+Tree的基础上,增加了一个指向相邻叶子节点的链表指针,就形成了带有顺序指针的B+Tree,提高区间访问的性能**(就是叶子节点的单向链表变成了双向链表)**</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u5j8fhj20rj09075i.jpg" alt="image-20220510105526048"></p><h1 id="为什么InnoDB存储引擎选择使用B-Tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-Tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+Tree索引结构"></a>为什么InnoDB存储引擎选择使用B+Tree索引结构</h1><p>①相对于二叉树,层级更少,搜索效率更高</p><p>②对于B-Tree,无论是叶子节点还是非叶子节点,都会保存数据,这样导致一页(磁盘块,一个节点一个磁盘块,16kb)中存储的键值减少,指针跟着减少,要同样保存大量数据,只能增加树的高度,导致性能降低(B+Tree只有叶子节点才会存储行数据,其他节点只起到了索引的作用,除了叶子节点,其他的页只存放key和索引,因为不存储数据,所以可以存放更多的索引和key,也就可以降低树的高度,层级变小,从而增加查询效率)<strong>而且在mysql中对b+树索引进行了优化,对叶子节点的单项链表变成了双向链表,便于范围搜索和排序</strong></p><p>③相对于Hash索引(只能进行等值匹配),B+Tree支持范围匹配及排序操作</p><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u92miej20r3077t9f.jpg" alt="image-20220510113432105"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5u9yambj20rd0ac75g.jpg" alt="image-20220510112749285"></p><p><strong>就会隐式的定义一个 rowid 作为聚集索引</strong></p><h1 id="InnoDB—-gt-回表查询"><a href="#InnoDB—-gt-回表查询" class="headerlink" title="InnoDB—-&gt;回表查询"></a>InnoDB—-&gt;回表查询</h1><p>如果想要执行类似于:selecy*from where name &#x3D; ‘Arm’ 这种sql语句,那么mysql先回根据二级索引找到对应的主键,或者带有唯一约束的值,然后通过主键或者唯一约束的值来通过聚集索引来查询对应row(行数据)</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uc5k8yj20xs0h80uo.jpg" alt="image-20220510115518828"></p><h1 id="InnoDB主键索引的B-Tree高度为多高呢"><a href="#InnoDB主键索引的B-Tree高度为多高呢" class="headerlink" title="InnoDB主键索引的B+Tree高度为多高呢?"></a>InnoDB主键索引的B+Tree高度为多高呢?</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5udhri1j20jl0hidhd.jpg" alt="image-20220510123359487"></p><p><strong>可以得出,用innodb来存储2000多万条数据,树也只有三层,大大的提高了检索效率!</strong></p><h1 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h1><ul><li><p>创建索引:<strong>构建B+Tree的数据结构,构建一次,一劳永逸,空间换时间</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">* create index idx_user_name on tb_user(name);* create unique index idx_user_phone on tb_user(phone);* create index idx_user_pro_age_sta on tb_user(profession,age,status); ---&gt; 创建联合索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查看索引:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">show index from tb_user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除索引:</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">drop index idx_user_phone on tb_user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>SQL语句的优化一般优化的是查询语句,在优化查询语句中索引占主导地位</strong></p></li></ul><h1 id="sql优化性能分析"><a href="#sql优化性能分析" class="headerlink" title="sql优化性能分析"></a>sql优化性能分析</h1><ul><li><p>SQL的执行频率</p><blockquote><p>Mysql客户端链接成功后,通过Show[session|global] status 命令可以提供服务器状态信息,通过如下命令,可以查看当前数据库的insert,update,delete,select的访问频次</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SHOW GLOBAL STATUS LIKE 'COM_______' <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span><span class="token number">7</span>个下划线代表<span class="token number">7</span>个字符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uhipaej20e109qmxx.jpg" alt="image-20220510125834554"></p></blockquote></li></ul><p><strong>如果我们使用执行频率查看到当前数据库select查询的执行频次占据绝大部分,我们就需要对当前数据库来进行优化</strong></p><ul><li><p>慢查询日志</p></li><li><blockquote><p>  慢查询日志记录了所有执行时间超过指定参数(long_query_time,单位:妙,默认10妙)的所有sql语句的日志,我们可以通过查询慢查询日志,来定位执行效率比较低的语句,来做对应的优化处理.</p><p>  Mysql的慢查询日志默认没有开启,需要在Mysql的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询慢查询日志是否开启mysql&gt; show variables like &#39;slow_query_log&#39;;+----------------+-------+| Variable_name  | Value |+----------------+-------+| slow_query_log | OFF   |  -------&gt;可以看到默认开关是关闭的+----------------+-------+1 row in set (0.01 sec)#可以在&#x2F;etc&#x2F;my.cnf中配置一下信息#开启Mysql慢查询日志开关slow_query_log&#x3D;1#设置慢查询日志的时间为2妙,sql语执行时间超过2秒,就会视为慢查询,记录慢查询日志long_query_time&#x3D;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完毕后,可以通过一下命令重启Mysql服务器进行测试,查询慢日志文件中记录的信息&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-show.log</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#重启mysql服务  systemctl restart mysqld; #进入mysql继续用命令查看当前慢日志开关mysql&gt; show variables like &#39;slow_query_log&#39;;+----------------+-------+| Variable_name  | Value |+----------------+-------+| slow_query_log | ON    | -------&gt;可以看到开关从OFF变成了ON,表示已经开启慢查询日志+----------------+-------+1 row in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当慢查询日志开启后,慢查询日志的位置在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;的目录下,文件名教localhost-slow.log</strong></p><p><strong>注意:但是只用慢查询日志的话,只能锁定一些自己定义的慢查询时间(设定的预设时间),来查到查询慢的sql语句,比较笼统,如果有的sql语句在1.98s或者1.99s其实也是属于慢查询,但是因为配置的原因并不会记录到慢查询日志中去,所以这个时候就要用到profiling工具来辅助sql调优</strong></p></blockquote></li><li><p>Profile详情</p><blockquote><p>show profiles 能够在做SQL优化的时候帮助我们了解时间都耗费到哪里去了.通过have_profiling参数,能够看到Mysql是否支持</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#profile操作mysql&gt; SELECT @@have_profiling;+------------------+| @@have_profiling |+------------------+| YES              |    ---------&gt;可以看到当前数据库支持profile+------------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持是支持,但是还要检查一下profiling是否是开启状态,<strong>默认是关闭的</strong>,可以通过session&#x2F;global级别开启profiling:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看是否开启了profiling开关mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+|           0 |     ------&gt;可以看到默认是关闭的+-------------+1 row in set, 1 warning (0.00 sec)#设置profiling的开关mysql&gt; set profiling &#x3D; 1;   ---------&gt;设置开关为1,就是打开Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+|           1 |     ---------------&gt;再次查看发现,profiling开关已经被开启了+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个时候就可以通过一下语句来查询,每个查询的sql语句的详细执行情况了</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看每一条sql的耗时的基本情况mysql&gt; show profiles;   +----------+------------+--------------------+| Query_ID | Duration   | Query              |+----------+------------+--------------------+|        1 | 0.00013000 | select @@profiling ||        2 | 0.00011800 | SELECT DATABASE()  ||        3 | 0.00166125 | show databases     ||        4 | 0.00015150 | show tables        ||        5 | 0.00024825 | show tables        ||        6 | 0.00024200 | select * from user ||        7 | 0.00013325 | select * from DISH ||        8 | 0.00027600 | select * from dish |+----------+------------+--------------------+8 rows in set, 1 warning (0.00 sec)#查看指定的query_id的SQL语句各个阶段的耗时情况 mysql&gt; show profile for query 3;   -------&gt;根据从show profiles中查询的基本情况的query_id来查看该语句各个阶段的耗时详情+----------------------+----------+| Status               | Duration |+----------------------+----------+| starting             | 0.000031 || checking permissions | 0.000010 || Opening tables       | 0.000028 || init                 | 0.000006 || System lock          | 0.000004 || optimizing           | 0.000003 || statistics           | 0.000009 || preparing            | 0.000007 || executing            | 0.001503 |    ----------&gt;可以发现在执行的时候耗时最长| Sending data         | 0.000019 || end                  | 0.000003 || query end            | 0.000004 || closing tables       | 0.000003 || removing tmp table   | 0.000005 || closing tables       | 0.000003 || freeing items        | 0.000013 || cleaning up          | 0.000012 |+----------------------+----------+17 rows in set, 1 warning (0.00 sec)#还可以在show profile for query语句中的profile后面加上cup关键字 ,就可以查询到cup的耗时情况mysql&gt; show profile cpu  for query 3;+----------------------+----------+----------+------------+| Status               | Duration | CPU_user | CPU_system |   ---------&gt;可以看到比上面的结果多了一个CPU_user的的字段信息+----------------------+----------+----------+------------+| starting             | 0.000031 | 0.000013 |   0.000015 || checking permissions | 0.000010 | 0.000005 |   0.000005 || Opening tables       | 0.000028 | 0.000013 |   0.000015 || init                 | 0.000006 | 0.000002 |   0.000003 || System lock          | 0.000004 | 0.000002 |   0.000002 || optimizing           | 0.000003 | 0.000001 |   0.000002 || statistics           | 0.000009 | 0.000005 |   0.000005 || preparing            | 0.000007 | 0.000003 |   0.000003 || executing            | 0.001503 | 0.000000 |   0.000286 || Sending data         | 0.000019 | 0.000000 |   0.000015 || end                  | 0.000003 | 0.000000 |   0.000003 || query end            | 0.000004 | 0.000000 |   0.000004 || closing tables       | 0.000003 | 0.000000 |   0.000003 || removing tmp table   | 0.000005 | 0.000000 |   0.000005 || closing tables       | 0.000003 | 0.000000 |   0.000003 || freeing items        | 0.000013 | 0.000000 |   0.000012 || cleaning up          | 0.000012 | 0.000000 |   0.000012 |+----------------------+----------+----------+------------+17 rows in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>explain执行计划:</p><p>可以模拟 优化器 执行SQL查询语句，并不会去真正的执行这条SQL，从而知道 MySQL 是如何处理你的SQL语句的。可用来分析你的查询语句或是表结构的性能瓶颈。<strong>从而评判sql语句的执行性能</strong></p><blockquote><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#使用explain模拟优化器mysql&gt; explain select * from dish; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | dish  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   26 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>expalin执行计划各个字段的含义:</p><p><strong>id:</strong></p><p>select查询的序列号,表示查询中执行select子句或者是操作表的顺序(id相同,执行顺序从上到下:id不同,值越大,越先执行)</p><p><strong>select_type:</strong></p><p>表示SELECT的类型,常见的取值有SIMPLE(简单表,即不实用表连接或者子查询),PRIMARY(主查询),PRIMARY(主查询,即外层的查询),UNION(UNION中搞得第二个或者后面的查询语句),SUBQUERY(SELECT&#x2F;WHERE之后包含了子查询)等</p><p><strong>type:</strong></p><p>表示连接类型,性能由好到差的连接类型为NULL,system,const,eq_ref,ref,range,index,all.</p><p><strong>possible_key:</strong></p><p>显示可能应用在这张表上的索引,一个或者多个</p><p><strong>key</strong></p><p>实际使用的索引,如果为null,则没有使用索引.</p><p><strong>key_len</strong></p><p>表示索引中使用的字节数,该值为索引字段最大可能长度,并非实际使用长度,在不损失精确性的前提下,长度越长越好.</p><p><strong>rows</strong></p><p>MYSQL认为必须要执行查询的行数,在Innodb引擎的表中,是一个估计值,可能并不总是准确的.</p><p><strong>filtered</strong></p><p>表示返回结果的行数占需读取行数的百分比,filtered的值越大越好</p><p><strong>Extra</strong></p><p>该语句没有查询出来的字段,会在额外字段中展示</p><p>using index condition  回表查询</p><p>using index 索引覆盖</p><p>using where 全表扫描</p><p>需重点关注以下字段信息:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uo0um1j20uv046t9s.jpg" alt="image-20220510144105150"></p></blockquote></li></ul><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ul><li><p>验证索引效率</p><p>在不用默认主键的聚合索引通过普通字段查询数据时,1000万条数据需要耗时20多s</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uq1th2j21420a6ad4.jpg" alt="image-20220510145621792"></p></li></ul><p>​    这个时候我们针对刚刚的字段来创建对应的索引,构造该字段的B+Tree索引数据结构(为1000万条的数据构造数据结构是非常耗时的经过1min11s的时间终于构建成功)</p><p>​        <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uqwe9ej20b201ut8q.jpg" alt="image-20220510145924020"></p><p>此时查询一下当前表的索引,发现刚刚创建的索引已经构建成功<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ut08o0j212p088abo.jpg" alt="image-20220510150140764"></p><p>这个时候我们再次查询一下刚刚的sql语句</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5uvpvx4j20er0bgq41.jpg" alt="image-20220510150423765"></p><p><strong>可以看到再次执行时,只用了0.01s的时间,这就是索引对于查询效率的提升</strong></p><h1 id="无效索引"><a href="#无效索引" class="headerlink" title="无效索引"></a>无效索引</h1><ul><li>没有遵守最左前缀法则</li></ul><p>如果索引了多列(联合索引),要遵守最左前缀法则.最左前缀法则指的是查询从索引的最左列开始,并且不跳过索引中的列,如果跳跃某一列,索引将部分失效(后面的字段索引失效) —-&gt;必须包含最左边的列,不然会失效,导致全表扫描</p><ul><li>范围查询</li></ul><p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引会失效(<strong>但是&lt;&#x3D;,&gt;&#x3D;索引会生效</strong>)</p><ul><li>索引列运算</li></ul><p>不要在索引列上进行运算操作,索引将失效</p><ul><li>字符串不加引号</li></ul><p>字符串类型字段使用时,不加引号,会发生隐式转换,索引将失效</p><ul><li>模糊查询</li></ul><p>如果仅仅是尾部模糊匹配,索引不会失效.如果是头部模糊匹配,索引失效.(例如: ‘xx%’可以  ‘%xx’不可以)</p><ul><li>or连接条件</li></ul><p>用or分割开的条件,如果or前的条件中的列有索引,而后面的列没有索引,那么涉及的索引都不会被用到,索引失效(只有两侧都有索引的时候,索引才会剩生效)—–&gt;解决方法,只需要在没有索引的一方建立索引即可 </p><h1 id="select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题"><a href="#select-联合索引-or关键字遇到的问题—-不走索引查询-最左原则失效问题" class="headerlink" title="select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?"></a>select * +联合索引+or关键字遇到的问题—-不走索引查询+最左原则失效问题?</h1><p><strong>有个问题,select * 的时候用 or 且满足左右两边都是索引的情况下按道理来说可以用到索引但是如果是联合索引,则不会走索引查询,而是全表扫描,如果是两边都是单个索引就会合并索引走二级索引+回表查询,如果所有字段都有索引,那么就会索引覆盖,直接走二级索引,符合索引覆盖</strong></p><ul><li><strong>数据分布影响</strong> —–重点</li></ul><p>如果MYSQL评估使用索引比全表更慢,则不使用索引.(比如查询一个比最小数据大的所有数据,因此本来就是要走全表扫描的,索引还不如直接走全表扫描来的快,也就不会走索引)</p><ul><li><strong>关于字段是否有null</strong> —重点</li></ul><p><strong>在where后面进行null值判断,导致索引失效的原因并不是null本身,而是mysql根据数据分布来自动判断是否用索引,比如一个字段里绝大多数都是null,这个时候你查询字段里为null的值,mysql会认为全表扫描比索引来的更快,所以不会使用索引,如果一个字段里的null是极少数的,那么当你查询字段里为null的值的数据的时候,mysql会判断全表扫描的性能要低于索引查询,这个时候就会使用索引!</strong></p><p>因为在判断时候,联合索引必须要有最左前缀,如果用or,就不能保证有最左前缀,所以直接全表扫描!</p><h1 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h1><p>SQL提示,是优化数据库的一个重要手段,简单来说,就是在SQL语句中加入一些认为的提示来达到优化操作的目的.</p><p>当单列索引存在与联合索引中的时候,Mysql会自动选择一个效率高的索引,如果想要使用其他索引的话,那就需要在sql语句中指定要用的索引,sql语句如下:</p><p><strong>use index(索引名)—–&gt;建议(MySQL不一定执行,会自动判断)</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#默认情况下mysql&gt; explain select * from dish where name &#x3D; &#39;梅菜扣肉&#39;;+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys                          | key           | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name,idx_dish_name_price_code | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+----------------------------------------+---------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)#给mysql建议使用索引情况下----&gt;mysql会自动判断,如果建议的索引效率低,则不会执行建议的索引mysql&gt; explain select * from dish use   index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ignore index(索引名)——&gt;表示忽略某个索引,也就是不用的索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#忽略联合索引索引,会执行另外的索引mysql&gt; explain select * from dish ignore  index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key           | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | dish  | NULL       | const | idx_dish_name | idx_dish_name | 194     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>force index(索引名)——&gt;强制Mysql执行某个索引</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#强制使用联合索引mysql&gt; explain select * from dish force  index(idx_dish_name_price_code) where name &#x3D; &#39;梅菜扣肉&#39;;+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys            | key                      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | dish  | NULL       | ref  | idx_dish_name_price_code | idx_dish_name_price_code | 194     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>尽量使用覆盖索引(查询使用了索引,并且需要返回的列,在索引中已经全部能够找到),减少select * .</p><p>覆盖索引的白话:就是要查询的字段都是设置了索引,建议直接覆盖所索引,就不需要回表查询了!</p><p>如果要查询的字段中包含没有索引的字段,那么会在二级索引找到有索引字段的值后拿到挂在叶子节点底下的主键值获取者约束唯一字段的值去聚集函数中进行回表查询,如下图所示:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v1fz2cj20wx0f60vb.jpg" alt="image-20220510171143926"></p><p>解决方案:就是将没有加入索引的字段也加上索引,实现索引覆盖效果,效率提高,尽量不用select * 不然大概率都会进行回表查询,性能就会下降</p><h1 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h1><p>当字段类型为字符串(varcahr,text等)时,有时候需要索引很长的字符串,这会让索引变得很大,查询时,浪费大量的磁盘IO,影响查询效率.此时可以只将字符串的一部分前缀,建立索引,这样可以大大节约索引空间,从而提高索引效率</p><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#创建前缀索引create index idx_xxxx on table_name(colum(n));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前缀长度:<br>可以根据索引的有选择性来决定,而选择性是指不重复的索引值(基数)和数据表的记录总数的比值,索引选择性越高则查询效率越高,唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的. </p><pre class="line-numbers language-MYSQL" data-language="MYSQL"><code class="language-MYSQL">#查询email中不为空的数据select count( email)&#x2F;count(*) from tb_user;#查询email中不重复的数据select count(distinct email) from tb_user;#查询emai中不重复数据的选择性 &#x2F;不重复数据&#x2F;总条目数select count(distinct email)&#x2F;count(*) from tb_user;#查询emai中不重复数据的选择性 &#x2F;不重复数据&#x2F;总条目数的前5个字符(降低索引的体积)select count(distinct substring(email,1,5))&#x2F;count(*) from tb_user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v3t7zuj20xu0fjwh6.jpg" alt="image-20220510212318350"></p><h1 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v95x4hj20wb0e4dij.jpg" alt="image-20220510220527020"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5v9t2zpj20xb0f2q50.jpg" alt="image-20220510220551724"></p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>1.针对数据量大,且查询比较频繁的表建立索引</p><p>2.针对常作为查询条件(where),排序(order by),分组(group by)操作的字段建立索引</p><p>3.尽量选择区分度高的列作为索引,尽量建立唯一索引,区分度越高,使用的效率就越高.</p><p>4.如果是字符串类型的字段,字段的长度较长,可以针对于字段的特点,建立前缀索引</p><p>5.尽量使用联合索引,减少单例索引,查询时,联合索引很多时候可以覆盖索引,节省存储空间,避免回表,提高查询效率.</p><p>6.要控制索引的数量,索引并不是多多益善,索引越多,维护索引结构的代价就越大,会影响增删改的效率</p><p>7.如果索引列不能存储NULL值,请再创建表使用NOT NULL约束它.当优化器知道每列是否包含NULL值时,可以更好的确定那个索引最有效的用于查询.</p><h1 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h1><p>1.索引概述</p><blockquote><p>索引是高效获取数据的数据结构,它是有序的</p></blockquote><p>2.索引结构</p><blockquote><p>B+Tree:所有的数据都会出现在叶子节点,而且叶子节点形成了一个双向链表</p><p>Hash:检索性能高,直接算出哈希值定位到检索数据,如果存在哈希碰撞,则会形成链表,在寻着链表找对应的值,检索性能比较高,但是缺点就是只能进行等值(精确)匹配,不支持范围查询,和索引的排序—-&gt;(memory引擎使用)</p></blockquote><p>3.索引分类</p><blockquote><p>主键索引,唯一索引,常规索引,全文索引</p><p>在innodb引擎中,根据索引的存储结构分为两类:聚集索引,二级索引</p><p>聚集索引:必须存在,且只能有一个,最大特点就是这个B+Tree叶子节点的数据是这一行的数据,默认主键索引就是聚集索引,没有主键会选择第一个唯一索引作为聚集索引</p><p>二级索引:B+Tree叶子节点的底下挂的是主键</p></blockquote><p>4.索引语法</p><blockquote><p>create [unique] index xxx on xxx(xxx);</p><p>Show index from xxxx;</p><p>Drop index xxx on xxx;</p></blockquote><p>5.SQL性能分析</p><blockquote><p>执行频次,慢查询日志,profile,explain</p></blockquote><p>6.索引使用</p><blockquote><p> 联合索引:必须严格遵守最左前缀法则</p><p>索引失效</p><p>SQL提示</p><p>覆盖索引</p><p>前缀索引</p><p>单例&#x2F;联合索引</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql存储引擎</title>
      <link href="/2022/05/10/Mysql%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/05/10/Mysql%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL体系结构-连接层"><a href="#MYSQL体系结构-连接层" class="headerlink" title="MYSQL体系结构:连接层"></a>MYSQL体系结构:连接层</h1><p>最上层是一些客户端的链接服务,主要完成一些类似于链接处理,授权认证,及相关的安全方案.服务器也会安全接入的每个客户端验证它所具有的操作权限</p><h1 id="MYSQL体系结构-服务层"><a href="#MYSQL体系结构-服务层" class="headerlink" title="MYSQL体系结构:服务层"></a>MYSQL体系结构:服务层</h1><p>第二层架构主要完成大多数的核心服务功能,如SQL接口,并完成缓存查询,Sql的分析和优化,部分内置函数的执行.所有跨存储引擎的功能也是在这一层实现的,如过程,函数等</p><h1 id="MYSQL体系结构-引擎层"><a href="#MYSQL体系结构-引擎层" class="headerlink" title="MYSQL体系结构:引擎层"></a>MYSQL体系结构:引擎层</h1><p>存储引擎真正的负责了Mysql中数据的存储和提取,服务器通过API和存储引擎进行通信.不同的存储引擎距有不同的功能,这样我们可以根据自己的需要,来选取核实的存储引擎.存储引擎是可插拔式的</p><h1 id="MYSQL体系结构-存储层"><a href="#MYSQL体系结构-存储层" class="headerlink" title="MYSQL体系结构:存储层"></a>MYSQL体系结构:存储层</h1><p>主要是将数据存储在文件系统上,并且完成与存储引擎的交互</p><h1 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h1><p>存储引擎就是存储数据,建立索引,更新&#x2F;查询数据等技术的实现方式.</p><p>指定存储引擎的语句:ENGINE&#x3D;INNODB &lt;—-可替换</p><p>查看当前数据库支持的存储引擎:SHOW ENGINES</p><p>没有指定存储引擎时,默认为InnoDB</p><p><strong>存储引擎是基于表的么人不是基于库的,所以存储引擎也被称为表类型</strong></p><h1 id="InnoDB存储引擎的特点"><a href="#InnoDB存储引擎的特点" class="headerlink" title="InnoDB存储引擎的特点"></a>InnoDB存储引擎的特点</h1><p>InnoDB介绍:</p><p>InnoDB是一种兼顾高可靠性的高性能的通用存储引擎,在Mysql5.5之后,InnoDB是默认的MYSQL存储引擎</p><p>InnoDB特点:</p><p>DML(增删改操作)操作遵循ACID模型,支持事务</p><p>行级锁,提高并发访问性能</p><p>支持外检Foreign key约束,保证数据的完整性和正确性</p><p>InnoDB文件:</p><p>xxx.ibd:xxx代表的是表名,innoDB引擎的每张表都会对应这样的一个表空间文件,存储该表的表结构(frm 8.0前  ,sdi 8.0后),数据和索引. 参数:innodb_flie_per_table如果打开,代表 每一张表都代表一个表空间</p><h1 id="查看ibd文件"><a href="#查看ibd文件" class="headerlink" title="查看ibd文件"></a>查看ibd文件</h1><p>idb文件是不能直接打开的,里面记录的都是二进制数据,如果非要打开看可以使用cmd输入—–&gt;   ibd2sdi xxx.idb</p><h1 id="ibd文件存储结构"><a href="#ibd文件存储结构" class="headerlink" title="ibd文件存储结构"></a>ibd文件存储结构</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq7wjv0rj20pw0ccq4e.jpg" alt="image-20220510095308222"></p><h1 id="MyISAM存储引擎的特点"><a href="#MyISAM存储引擎的特点" class="headerlink" title="MyISAM存储引擎的特点"></a>MyISAM存储引擎的特点</h1><p>介绍:</p><p>MyISAM是MySQL早期默认的存储引擎</p><p>特点:</p><p>不支持事务,不支持外键</p><p>支持表锁,不支持行锁</p><p>访问速度快 </p><p>文件:</p><p>xxx.sdi:存储表结构信息(存储的json格式数据)</p><p>xxx.MYD:存储数据</p><p>xxx.MYI:存储索引</p><h1 id="Memory存储引擎的特点"><a href="#Memory存储引擎的特点" class="headerlink" title="Memory存储引擎的特点"></a>Memory存储引擎的特点</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq80a7hfj20mg089jrl.jpg" alt=" "></p><h1 id="三个存储引擎的区别"><a href="#三个存储引擎的区别" class="headerlink" title="三个存储引擎的区别"></a>三个存储引擎的区别</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2iq7sxlvrj20ni09eaaq.jpg" alt="image-20220510100124777"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2022/05/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/05/08/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TreeifyBin"><a href="#TreeifyBin" class="headerlink" title="TreeifyBin"></a>TreeifyBin</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//n 数组的长度，index 数组位置</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果当前数组为空，或者当前数组容量小于最小树化容量</span>            <span class="token comment">//直接扩容不进行树化</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//当当前找的节点e不为空</span>            <span class="token comment">//hd红黑树链表头，红黑树链表尾（红黑树中不仅有维护其所有节点的红黑树结构，还有所有节点的链表结构）</span>            <span class="token comment">//所以先将目前节点按链表排列好，在进行红黑树化</span>            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">//遍历列表</span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//将当前e节点装化为TreeNode</span>                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//如果tl不存在</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//则p为hd</span>                    hd <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//若存在则p的前节点指向tl</span>                    p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>                    <span class="token comment">//tl的后节点指向p</span>                    tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">//最后将tl指向p</span>                tl <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//将hd放在数组上，且hd存在，将链表进行红黑树化</span>                hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Treeify"><a href="#Treeify" class="headerlink" title="Treeify"></a>Treeify</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeify</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> next<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//根据链表进行遍历</span>                next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                x<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//如果根节点还没设置则当前节点设置为根节点root</span>                    x<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">//根节点一定是黑色的</span>                    x<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    root <span class="token operator">=</span> x<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//获取当前循环节点的key和哈希值</span>                    <span class="token class-name">K</span> k <span class="token operator">=</span> x<span class="token punctuation">.</span>key<span class="token punctuation">;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> x<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> kc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">//每次都从根节点开始循环</span>                    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">//遍历当前红黑树</span>                        <span class="token keyword">int</span> dir<span class="token punctuation">;</span>                        <span class="token comment">//获得p的hash值和key</span>                        <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>                        <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>                        <span class="token comment">//比较hash值，然后根据比较值dir决定插入左边还是右边</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>                                <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//k不是不是课比较类或者比较结果为0，使用tieBreakOrder方法比较</span>                            dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>                        p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                        <span class="token comment">//仅当当前要插入的位置上没有节点时才进行插入，否则继续向下遍历</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//设置父节点</span>                            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> xp<span class="token punctuation">;</span>                            <span class="token comment">//根据dir值设置为父节点的左右子节点</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token comment">//插入成功后平衡红黑树</span>                            root <span class="token operator">=</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//跳出当前循环</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//确保当前的root是直接落在table数组上的</span>            <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>外卖项目遇到的问题总结</title>
      <link href="/2022/04/26/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/26/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器返回页面与数据库id不一致-js与雪花算法的精度丢失问题"><a href="#浏览器返回页面与数据库id不一致-js与雪花算法的精度丢失问题" class="headerlink" title="浏览器返回页面与数据库id不一致(js与雪花算法的精度丢失问题)"></a>浏览器返回页面与数据库id不一致(js与雪花算法的精度丢失问题)</h1><p>通过观察控制台输出的SQL发现页面传递过来的员工id的值和数据库中的id值不一致，这是怎么回事呢？<br>分页查询时服务端响应给页面的数据中id的值为**19位数字(mybatisplus提供的雪花算法)**，类型为long<img src="https://s1.ax1x.com/2022/04/27/LbRRr6.png" alt="LbRRr6.png"></p><p>页面中<strong>js处理long型数字只能精确到前16位</strong>，所以最终通过ajax请求提交给服务端的时候id变为1391586184024604700</p><p><img src="https://s1.ax1x.com/2022/04/27/LbWSiQ.png" alt="LbWSiQ.png"></p><p>前面我们已经发现了问题的原因，<strong>即js对long型数据进行处理时丢失精度</strong>，导致提交的id和数据库中的id不一致。</p><p>如何解决这个问题？<br>我们可以在服务端给页面响应json数据时进行处理，将long型数据统一转为String字符串，效果如下：</p><p><img src="https://s1.ax1x.com/2022/04/27/LbRvdS.png" alt="LbRvdS.png">具体实现步骤：<br>①提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>common</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">DeserializationFeature</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">ObjectMapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>module<span class="token punctuation">.</span></span><span class="token class-name">SimpleModule</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>ser<span class="token punctuation">.</span>std<span class="token punctuation">.</span></span><span class="token class-name">ToStringSerializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>deser<span class="token punctuation">.</span></span><span class="token class-name">LocalDateDeserializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>deser<span class="token punctuation">.</span></span><span class="token class-name">LocalDateTimeDeserializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>deser<span class="token punctuation">.</span></span><span class="token class-name">LocalTimeDeserializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>ser<span class="token punctuation">.</span></span><span class="token class-name">LocalDateSerializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>ser<span class="token punctuation">.</span></span><span class="token class-name">LocalDateTimeSerializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>datatype<span class="token punctuation">.</span>jsr310<span class="token punctuation">.</span>ser<span class="token punctuation">.</span></span><span class="token class-name">LocalTimeSerializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalDate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalDateTime</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalTime</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">DeserializationFeature</span><span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">;</span><span class="token comment">/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonObjectMapper</span> <span class="token keyword">extends</span> <span class="token class-name">ObjectMapper</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEFAULT_DATE_FORMAT <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEFAULT_DATE_TIME_FORMAT <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEFAULT_TIME_FORMAT <span class="token operator">=</span> <span class="token string">"HH:mm:ss"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">JacksonObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//收到未知属性时不报异常</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//反序列化时，属性不存在的兼容处理</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDeserializationConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withoutFeatures</span><span class="token punctuation">(</span><span class="token class-name">DeserializationFeature</span><span class="token punctuation">.</span>FAIL_ON_UNKNOWN_PROPERTIES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SimpleModule</span> simpleModule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addDeserializer</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalDateTimeDeserializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_DATE_TIME_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addDeserializer</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalDateDeserializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_DATE_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addDeserializer</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalTimeDeserializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_TIME_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addSerializer</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">ToStringSerializer</span><span class="token punctuation">.</span>instance<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addSerializer</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">ToStringSerializer</span><span class="token punctuation">.</span>instance<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addSerializer</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalDateTimeSerializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_DATE_TIME_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addSerializer</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalDateSerializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_DATE_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addSerializer</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LocalTimeSerializer</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>DEFAULT_TIME_FORMAT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerModule</span><span class="token punctuation">(</span>simpleModule<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行Java对象到json数据的转换(重写WebMvcConfigurationSupport里的 extendMessageConverters方法)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">extendMessageConverters</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpMessageConverter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> converters<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MappingJackson2HttpMessageConverter</span> mappingJackson2HttpMessageConverter <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">MappingJackson2HttpMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mappingJackson2HttpMessageConverter<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JacksonObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        converters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>mappingJackson2HttpMessageConverter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。</p><p><strong>总结:因为数据库id都是采用mybatis-plus提供的雪花算法赋值,所以id值都是19位,然而将数据提供给前端页面时,js解析ID数据时,最多只能解析16位及以内的数据,所以导致了精度丢失,也就会发生页面存储数据的id与数据库的id不一致,所以当我们想通过从页面获取id对数据库中的数据做一些操作的时候就会出现问题.</strong></p><p>思路:①因为问题出现在精度丢失,那么我们可以考虑把id转换成字符串类型让页面接受.</p><p>​        ②我们可不可以将pojo类的id设为String,数据库id设置为varchar类型呢?</p><p>​        ③可以,但是不建议,因为在做业务操作的时候根据id查询的参数都是Integer类型,所以没有必要牵一发而动全身</p><p>​        ④那么就找出问题的原因,很明显原因出在返回值,在springboot框架中,我们在controller层返回给页面的数据都是springmvc框架帮我们自动封装成json数据,而spring默认处理json数据的对象,SpringMVC的消息转换器,默认会帮我们转换参数类型.</p><p>​        ⑤所以我们需要将springmvc中的消息转换器进行扩展,也就是上述提供的自定义JacksonObjectMapper类,通过自定义设定–&gt;当遇到Long类型数据是,自动转为换为字符串返回给页面存储.</p><p>​        ⑥这样就可以避免js在接受数据时精度丢失了.</p><h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><p>MD5加密:</p><p>可以使用apache的commons-codec工具类或者Spring提供的DigestUtils工具类,导不同的包就行了(工具包名字一样)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">DigestUtils</span><span class="token punctuation">;</span><span class="token comment">/** * @author zhangminghao * @Date 2022/4/26 8:19 下午 * 最难不过坚持👊🏻 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>codec<span class="token punctuation">.</span>digest<span class="token punctuation">.</span></span>DigestUtils</span><span class="token punctuation">.</span><span class="token function">md5Hex</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"apache---->"</span><span class="token operator">+</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输出:apache---->e10adc3949ba59abbe56e057f20f883e</span>        <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token class-name">DigestUtils</span><span class="token punctuation">.</span><span class="token function">md5DigestAsHex</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring---->"</span><span class="token operator">+</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输出:spring---->e10adc3949ba59abbe56e057f20f883e</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区别:apache的commons-codec的优势,拥有大部分的加密方式,而spring只有md5加密</p><p>①apache的commons-codec:</p><p>Commons codec，是项目中用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64，URL，Soundx等等。不仅是编码，也可用于解码</p><p><img src="https://s1.ax1x.com/2022/04/27/LqC4Pg.png" alt="LqC4Pg.png"></p><p>②spring的DigestUtils:</p><p>MD5加密</p><p><img src="https://s1.ax1x.com/2022/04/27/LqCfIS.png" alt="LqCfIS.png"></p><h1 id="MD5和Base64加密方式-扩充上面知识点"><a href="#MD5和Base64加密方式-扩充上面知识点" class="headerlink" title="MD5和Base64加密方式,扩充上面知识点"></a>MD5和Base64加密方式,扩充上面知识点</h1><p>1.MD5散列算法</p><p>词汇解释：<br>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法(MD5不可逆)</p><p>2.Base64</p><p>是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范(Base64 的加密算法是可逆的)</p><h1 id="用户退出销毁session"><a href="#用户退出销毁session" class="headerlink" title="用户退出销毁session"></a>用户退出销毁session</h1><p><img src="https://s1.ax1x.com/2022/04/27/LqCRVf.png" alt="LqCRVf.png"></p><h1 id="AntPathMatcher基本使用"><a href="#AntPathMatcher基本使用" class="headerlink" title="AntPathMatcher基本使用"></a>AntPathMatcher基本使用</h1><p>首先，AntPathMatcher是什么？有什么能力？<br>AntPathMather是Spring提供的用于对资源路径进行解析或者对url的字符串做匹配用的。无论是资源路径还是url字符串都是采用的是Ant格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建一个不用拦截的数组</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> urls <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token string">"/backend/**"</span><span class="token punctuation">,</span>                <span class="token string">"/front/**"</span><span class="token punctuation">,</span>                <span class="token string">"/employee/login"</span><span class="token punctuation">,</span>                <span class="token string">"/employee/logout"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//获取url路径</span>        <span class="token class-name">String</span> uri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否有非拦截路径</span>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token function">checkFilter</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用下面方法,匹配非拦截路径</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//有就放行</span>            filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkFilter</span><span class="token punctuation">(</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">,</span><span class="token class-name">String</span> uri<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">AntPathMatcher</span> antPathMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> url <span class="token operator">:</span> urls<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> antPathMatcher<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Mybatis-plus中使用自动填充的坑"><a href="#Mybatis-plus中使用自动填充的坑" class="headerlink" title="Mybatis-plus中使用自动填充的坑"></a>Mybatis-plus中使用自动填充的坑</h1><p>当我想在项目中使用MyBatis-plus中的自动填充功能用来自动填充数据的修改和创建时间时,发现数据在创建时可以自动注入,修改时不可以,这是为什么呢?</p><p>先来看看代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"start insert fill ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">strictInsertFill</span><span class="token punctuation">(</span>metaObject<span class="token punctuation">,</span> <span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">strictInsertFill</span><span class="token punctuation">(</span>metaObject<span class="token punctuation">,</span> <span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"start update fill ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">strictUpdateFill</span><span class="token punctuation">(</span>metaObject<span class="token punctuation">,</span> <span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>新增数据</strong>时的请求数据和自动执行的sql语句:</p><p><img src="https://s1.ax1x.com/2022/04/27/LqCWa8.png" alt="LqCWa8.png"></p><p><strong>修改数据</strong>时的请求数据和自动执行的sql语句:</p><p>修改数据分为2步:</p><p>①当我们点击编辑按钮的时候通过页面通过向服务器发送待编辑的id,让服务器通过id查找数据再回显到页面表单中<img src="https://s1.ax1x.com/2022/04/27/LqPGFS.png" alt="LqPGFS.png"></p><p>②修改完数据后,将数据提交给服务器,让服务端修改数据</p><p><img src="https://s1.ax1x.com/2022/04/27/LqP1df.png" alt="LqP1df.png"></p><p>发现:</p><p>①<strong>在上面的整体流程中我们发现</strong>,在执行新增数据的时候,createTime和updateTime都实现了mysq-plus提供的自动注入功能,但是在修改时,数据对应的修改时间却没有发生变化</p><p>②<strong>从请求方式发现</strong>,新增的时候,createTime和updateTime我们是没有给值的,所以传到服务器的时候,这两个值都是以null的形式传过去的,但是在修改的时候,是通过id查找数据回显到页面表单的,当我们修改基本数据后,该数据createTime和updateTime在修改前就已经被自动填充了,所以不是null</p><p>③<strong>通过SQL语句发现</strong>,当页面表单的createTime和updateTime为NULL的时候,在执行sql的时候会自动填充,反之,当页面表单的数据createTime和updateTime不为NULL的时候,服务器执行sql的时候则不会自动填充覆盖原有的值,而是将原有的值纹丝不动的设置到数据中,也就没有发生改变.</p><p>原因:</p><p>因为Mybatis-plus中的的自动填充功能的strictInsertFill和strictUpdateFill默认是被自动填充的值为NULL则自动填充,不为NULL则不自动填充</p><p>解决方式:<br>①在填充前判断metaObject中有没有需要自动填充的值,如果有则设置为null</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">Object</span> updateTime <span class="token operator">=</span> metaObject<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>metaObject<span class="token punctuation">.</span><span class="token function">hasSetter</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         metaObject<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">strictUpdateFill</span><span class="token punctuation">(</span>metaObject<span class="token punctuation">,</span> <span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②使用setFieldValByName直接设置updateTime的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"start update fill ...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="POJO-DTO-VO之间的区别"><a href="#POJO-DTO-VO之间的区别" class="headerlink" title="POJO,DTO,VO之间的区别"></a>POJO,DTO,VO之间的区别</h1><p>POJO含义:与数据库的表一一对应,用来封装从数据库查询的数据,不同的公司要求的名字不一样,比如还有po,entity,domain,model,javabean,bean,但是表达的含义都是一样的.</p><p>DTO含义:指浏览器提交参数给服务器,服务器用来封装对应参数的对象</p><p>VO含义:指服务器响应给浏览器的数据,将数据封装后传递给浏览器</p><h1 id="使用过滤器的时候-WebFilter注意事项"><a href="#使用过滤器的时候-WebFilter注意事项" class="headerlink" title="使用过滤器的时候@WebFilter注意事项"></a>使用过滤器的时候@WebFilter注意事项</h1><p>因为@WebFilter是Servlet管理,所以需要在引导类加上@ServletComponentScan,扫描到@WebFilter才能生效</p><h2 id="common-Fileupload—–-gt-MultipartFile-file"><a href="#common-Fileupload—–-gt-MultipartFile-file" class="headerlink" title="common-Fileupload—–&gt;MultipartFile file"></a>common-Fileupload—–&gt;MultipartFile file</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5ndr842j215o07mwgf.jpg" alt="image-20220430084336123"></p><h1 id="Transaction可能事务失效的地方"><a href="#Transaction可能事务失效的地方" class="headerlink" title="@Transaction可能事务失效的地方"></a>@Transaction可能事务失效的地方</h1><p>项目采用了Mybatis-plus,mapper和service都各自实现和继承了mybatis-lpus提供的的接口,所以在项目中的Service层可以直接用this调用父类serviceImpl的方法,这样可能导致被this所调用的方法事务失效,因为this直接调父类的方法,没有被代理对象所代理,但是加上@Transaction注解的方法,必须要代理对象调用时,才能实现事务保护</p><p>解决方案:自己注入自己@Autowired—&gt;xxxservice,但是需要解决循环依赖问题.</p><h1 id="做项目中加上ToDo-表示项目未完成"><a href="#做项目中加上ToDo-表示项目未完成" class="headerlink" title="做项目中加上ToDo,表示项目未完成"></a>做项目中加上ToDo,表示项目未完成</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2a5nfdafdj20cw07ugma.jpg" alt="image-20220430110948139"></p><h1 id="pojo四大特征"><a href="#pojo四大特征" class="headerlink" title="pojo四大特征"></a>pojo四大特征</h1><p>无参构造方法,get方法,set方法,实现serializable接口序列化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC使用</title>
      <link href="/2022/04/24/SpringMvc/"/>
      <url>/2022/04/24/SpringMvc/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是Mvc"><a href="#1-什么是Mvc" class="headerlink" title="1.什么是Mvc"></a>1.什么是Mvc</h1><p>①Mvc是一种软件架构的思想,将软件按照模型,视图,控制器来划分</p><blockquote><p>M:Model,模型层,指工程中的JavaBean,作用是数据处理</p><p>V:View,视图层,指工程中的html或jsp等页面,作用是与用户进行交互,展示数据</p><p>C:Controller,控制层,指工程中的servlet,作用是接受请求和响应浏览器</p></blockquote><p>②JavaBean分为两类:</p><ul><li>一类称为实体类Bean:专门存储业务数据的,如Student,User等</li><li>一类称为业务处理Bean:指Service或Dao对象,专门用于处理业务逻辑和数据访问.</li></ul><p>③Mvc的工作流程:</p><ul><li>用户通过视图层发送请求到服务器,在服务器中请求被Controller接受,Controller调用相应的Model层处理请求,处理完毕将结果返回到Controller,Controller再根据请求处理的结果找到相应的View视图,渲染数据后最终响应给浏览器</li></ul><h1 id="2-什么是SpringMvc"><a href="#2-什么是SpringMvc" class="headerlink" title="2.什么是SpringMvc"></a>2.什么是SpringMvc</h1><ul><li><p>SpringMvc是Spring的一个后续产品,是Spring的一个子项目,是基于Servlet的</p></li><li><p>SpringMvc就是Spring的Mvc模块的内容,他是Spring为表述层开发提供的一整套完整的解决方案</p></li><li><p>在SpringMcv所封装的带有功能的Servlet,把处理请求的功能都进行了封装</p></li><li><p>我们只需要使用SpringMvc提供的实现功能的代码,就可以完成请求的处理了</p></li><li><p>前台页面发送请求到服务器中,服务器来使用Servlet来接受请求处理请求,  需要根据请求地址找到相应的Servlet,其中Servlet的service(生命周期的方法之一)方法就是处理请求和响应的方法</p></li></ul><p><strong>注:三层架构为表述层(前台页面+后台Servlte)+业务逻辑层+数据访问层</strong></p><h1 id="3-springMvc的特点"><a href="#3-springMvc的特点" class="headerlink" title="3.springMvc的特点"></a>3.springMvc的特点</h1><p>①为什么有Servlet不用,要使用SpringMvc?</p><blockquote><p>SpringMvc就是一个Servlet,封装Servlet后就有了一个功能非常强大的前端控制器DispatcherServlet,原来页面发送来的请求,需要我们自己写Servlet来处理,然而使用SpringMvc后就通过SpringMvc来进行统一处理,SpringMvc会对接受请求做出响应的很多的过程进行封装,比如用原生Servlet获取请求参数,比如往域对象放值的时候,比如页面跳转和重定向的时候,那么这个时候DispatcherServle会对这些操作进行统一处理</p></blockquote><p>②特点总结:</p><ul><li><strong>spring家族原生产品</strong>,与IOC容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>,通过了功能强大的<strong>前端控制器DispatcherServlet</strong>,对请求响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>,提供<strong>全面解决方案</strong></li><li><strong>代码清新简介</strong>,大幅度提升开发效率</li><li>内部组件化程度高,可插拔式组件<strong>即插即用</strong>,想要什么功能配置相应组件即可</li><li><strong>性能卓越</strong>,尤其是和现代大型吗,超大型互联网项目需求</li></ul><h1 id="4-web-xml是什么"><a href="#4-web-xml是什么" class="headerlink" title="4.web.xml是什么?"></a>4.web.xml是什么?</h1><ul><li>web.xml是我们web工程的一个<strong>入口配置文件</strong>,在文件里我们可以注册Servlet可以注册Filter过滤器,监听器等..</li></ul><h2 id="5-为什么要在web-xml文件里面注册Servlet"><a href="#5-为什么要在web-xml文件里面注册Servlet" class="headerlink" title="5.为什么要在web.xml文件里面注册Servlet?"></a>5.为什么要在web.xml文件里面注册Servlet?</h2><ul><li>web.xml配置文件是web工程的一个入口文件,<strong>因为浏览器不能去直接访问一个类</strong>,所以要在web.xml文件里面来跟Servlet注册一个匹配路径,才能让浏览器去访问到Servlet,每当我们访问的路径符合目前所设置的匹配路径的时候,那么这个时候当前的请求就会让Servlet来接受参数并处理</li></ul><h1 id="6-为什么在web-xml中注册DispatcherServlet的而不是Servlet"><a href="#6-为什么在web-xml中注册DispatcherServlet的而不是Servlet" class="headerlink" title="6.为什么在web.xml中注册DispatcherServlet的而不是Servlet?"></a>6.为什么在web.xml中注册DispatcherServlet的而不是Servlet?</h1><ul><li>因为DispatcherServlet中封装了Servlet,配置SpringMVC的前端控制器DispatcherServlet可以对浏览器发送的请求进行统一处理,极大的简化了我们的表述层的代码!</li></ul><h1 id="7-为什么在web-xml中注册DispatcherServlet的匹配路径是-x2F-而不是-x2F"><a href="#7-为什么在web-xml中注册DispatcherServlet的匹配路径是-x2F-而不是-x2F" class="headerlink" title="7.为什么在web.xml中注册DispatcherServlet的匹配路径是&#x2F;而不是&#x2F;*?"></a>7.为什么在web.xml中注册DispatcherServlet的匹配路径是&#x2F;而不是&#x2F;*?</h1><ul><li>因为&#x2F;所配置的请求可以是&#x2F;login或.html或.js或.css方式的请求路径,但是&#x2F;不能匹配.jsp请求路径的请求</li></ul><h2 id="8-为什么不让DispatcherServlet匹配路径去匹配-jsp文件"><a href="#8-为什么不让DispatcherServlet匹配路径去匹配-jsp文件" class="headerlink" title="8.为什么不让DispatcherServlet匹配路径去匹配.jsp文件?"></a>8.为什么不让DispatcherServlet匹配路径去匹配.jsp文件?</h2><ul><li>因为<strong>JSP文件</strong>的本质就是一个<strong>Servlet文件</strong>,它是需要<strong>服务器指定的Servlet来进行特殊处理</strong>的,所以.jsp文件不需要DispatcherServlet来处理,如果路径能够匹配.jsp文件的话,那么这个.jsp文件的请求也会被当前的SpringMVC来进行处理,那SpringMVC会把当前这个.jps的请求当做一个<strong>普通的请求来处理</strong>,而不会找到相对于的jsp页面,所以要用&#x2F;来排除.jsp页面的请求路径给排除掉,然后<strong>其他的请求</strong>都要交给我们的<strong>前端控制器DispatcherServlet来进行处理</strong></li></ul><h1 id="9-x2F-代表什么"><a href="#9-x2F-代表什么" class="headerlink" title="9.&#x2F;*代表什么?"></a>9.&#x2F;*代表什么?</h1><ul><li>&#x2F;*代表所有请求路径,包括.jsp页面的请求,一般适用于注册Filter过滤器的匹配路径</li></ul><h1 id="10-框架是什么"><a href="#10-框架是什么" class="headerlink" title="10.框架是什么?"></a>10.框架是什么?</h1><ul><li>配置文件+jar包</li></ul><h1 id="11-SpringMVC配置方式①-默认配置方式"><a href="#11-SpringMVC配置方式①-默认配置方式" class="headerlink" title="11.SpringMVC配置方式①:默认配置方式"></a>11.SpringMVC配置方式①:默认配置方式</h1><p>此配置作用下,SpringMVC的配置文件<strong>默认文件位于WEB-INF</strong>下,<strong>默认名称为<servlet-name>-servlet.xml</strong>,例如:一下配置所对应SpringMVC的配置文件位于WEB-INF下,文件名为springMVC-servlet.xml</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--配置SpringMVC的前端控制器,对浏览器发送的请求进行统一处理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--配置ServletMapping映射路径--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--        设置springMvc的核心控制器所能处理的请求的请求路径        /所配置的请求可以是/login或.html或.js或.css方式的请求路径        ,但是/不能匹配.jsp请求路径的请求        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注:此配置方式不好,我们学习了maven工程后,配置文件应该统一放在resource资源路径下面,因为WEB-INF下只放页面和静态资源</strong></p><h1 id="12-SpringMVC配置方式②-扩展配置方式"><a href="#12-SpringMVC配置方式②-扩展配置方式" class="headerlink" title="12.SpringMVC配置方式②:扩展配置方式"></a>12.SpringMVC配置方式②:扩展配置方式</h1><ul><li>可以通过init-param初始化参数标签设置SpringMVC配置文件的位置和名称:</li></ul><blockquote><p> 初始化时设置参数,将DispatcherServlet的父类FrameworkServlet中的**contextConfigLocation(上下文配置路径)**参数路径设置为自定义路径(classpath:文件名.xml) —–&gt;classpath对应的类路径也就是java包和resource包</p></blockquote><ul><li>可以通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间:</li></ul><blockquote><p> 因为DispatcherServlet就是一个Servlet,所以声明周期和Servlet是一样的,默认都是在第一次访问的时候进行初始化,但是DispatcherServlet封装了对请求过程所有的处理,所以初始化中要执行很多的内容,如果把众多的处理内容放在第一次访问的时候初始化,就会严重的影响第一次访问的速度</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--配置SpringMVC的前端控制器,对浏览器发送的请求进行统一处理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--配置SpringMVC配置文件的位置和名称--></span>        <span class="token comment">&lt;!--初始化时设置参数,将DispatcherServlet的父类DispatcherServlet        的contextConfigLocation参数路径设置为自定义路径--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--上下文配置路径--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:springMVC.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--将前端控制器DispatcherServlet的初始化时间提前到服务器启动时            因为DispatcherServlet封装了对请求过程所有的处理,所以初始化中要执行很多的内容            如果把众多的内容放在第一次访问的时候初始化,就会严重的影响第一次访问的速度        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--配置ServletMapping映射路径--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--        设置springMvc的核心控制器所能处理的请求的请求路径        /所配置的请求可以是/login或.html或.js或.css方式的请求路径        ,但是/不能匹配.jsp请求路径的请求        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件上传三要素"><a href="#文件上传三要素" class="headerlink" title="文件上传三要素"></a>文件上传三要素</h1><p>![image-20220429090202460](&#x2F;Users&#x2F;zhangminghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220429090202460.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot高级</title>
      <link href="/2022/04/22/springboot%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/04/22/springboot%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot最重要的两个功能"><a href="#SpringBoot最重要的两个功能" class="headerlink" title="SpringBoot最重要的两个功能"></a>SpringBoot最重要的两个功能</h1><p>1.版本锁定(mybatis为什么没有锁定,因为mybatis开发的比较晚)</p><p>2.自动装配</p><h1 id="SpringBoot默认静态资源的存放目录是什么"><a href="#SpringBoot默认静态资源的存放目录是什么" class="headerlink" title="@SpringBoot默认静态资源的存放目录是什么?"></a>@SpringBoot默认静态资源的存放目录是什么?</h1><ul><li>从以下图片可以得知SpringBoot默认静态资源的存放目录为:classpath:&#x2F;resource&#x2F;,classpath:&#x2F;static&#x2F;,classpath:&#x2F;public&#x2F;</li></ul><p>①当启动引导类时,引导类会自动装配,加载spring.factories文件</p><p><img src="https://s1.ax1x.com/2022/04/25/LILA3Q.png" alt="LILA3Q.png"></p><p>②在文件里读取到WebMvcAutoConfiguration时</p><p><img src="https://s1.ax1x.com/2022/04/25/LILnH0.png" alt="LILnH0.png"></p><p>③会通过@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)来判断容器里是否有WebMvcConfigurationSupport这个类</p><p><img src="https://s1.ax1x.com/2022/04/25/LILQ4U.png" alt="LILQ4U.png"></p><p>④如果没有WebMvcConfigurationSupport,那么会创建WebMvcAutoConfiguration,并且在构造方法执行时将找到resourceProperties并赋值</p><p><img src="https://s1.ax1x.com/2022/04/25/LIL1CF.png" alt="LIL1CF.png"></p><p>⑤通过this.resourceProperties.getStaticLocations调用方法,得到类中的默认资源常量添加到资源路径中</p><p><img src="https://s1.ax1x.com/2022/04/25/LILgbt.png" alt="LILgbt.png"></p><p>⑥通过Resources类中可以看到资源常量是一个字符串数组存储,最终赋值给staticLocations的变量,并且通过get方法可以获取到</p><p><img src="https://s1.ax1x.com/2022/04/25/LILWUf.png" alt="LILWUf.png"></p><p><strong>总结:所以当我们没有通过继承WebMvcConfigurationSupport的方式来配置自定义静态资源访问路径时,默认访问路径为classpath:&#x2F;resource&#x2F;,classpath:&#x2F;static&#x2F;,classpath:&#x2F;public&#x2F;</strong></p><h1 id="WebMvcConfigurationSupport和WebMvcConfiguration什么关系"><a href="#WebMvcConfigurationSupport和WebMvcConfiguration什么关系" class="headerlink" title="WebMvcConfigurationSupport和WebMvcConfiguration什么关系?"></a>WebMvcConfigurationSupport和WebMvcConfiguration什么关系?</h1><p>查看源码注释上查到的解释是，在spring中配置WebMvc时有两种方法，<br>1.继承WebMvcConfigurationSupport或者子类DelegatingWebMVcconfiguration，重写里面相应的方法<br>2.继承WebMvcConfigurer的子抽象类WebMvcConfigurerAdapter(已经过时了)，也是重写里面相应的方法，但是需要在配置类上添加@EnableWebMvc注解。那这两个类直接是什么关系呢？</p><p>3.实现WebMvcConfigurer(因为2已经过时了)，也是重写里面相应的方法，但是需要在配置类上添加@EnableWebMvc注解。</p><p>  细心的开发者会发现，WebMvcConfigurationSupport中那些子类可以重写的空方法在WebMvcConfigurer都有，这说明WebMvcConfigurer只是WebMvcConfigurationSupport的一个扩展类，它并没有扩展新功能，只是为让用户更方便安全的添加自定义配置，为什么说是安全呢？<br>因为如果直接继承WebMvcConfigurationSupport，那么用户可以重写默认的配置，如果对原理不是很清楚地开发者不小心重写了默认的配置，springmvc可能相关功能就无法生效，是一种不安全的行为。但如果是继承WebMvcConfigurerAdapter，那么开发者是在默认配置的基础上添加自定义配置，相对来说更安全一些，只不过要多加一个@EnableWebMvc注解。从这个角度来说，最佳实践还是继承WebMvcConfigurerAdapter</p><p><strong>为什么WebMvcConfigurer实现要加@EnableWebMvc?</strong></p><blockquote><p>@EnableWebMvc注解类上导入了DelegatingWebMvcConfiguration类，该类是WebMvcConfigurationSupport的子类，该类除了实例化WebMvcConfigurationSupport实例以外，另一个作用就是收集BeanFactory中所有WebMvcConfigurer的实现，汇集到WebMvcConfigurerComposite中，在WebMvcConfigurationSupport实例化过程中会分别调用这些实现，将相应的实例传入这些实现中，供开发者在此基础上添加自定义的配置。这也就是在WebMvcConfigurerAdapter子类上要加@EnableWebMvc的原因，因为要先实例化WebMvcConfigurationSupport。*</p></blockquote><p><strong>为什么可以存在多个WebMvcConfigurer的实现?</strong></p><blockquote><p> 一般来讲一个应用中一个WebMvcConfigurer的已经足够，设计成收集多个是不是有些多余？从springboot的autoconfigure机制来看并不多余，反而更灵活，比如我要写一个mybatis的AutoConfiguration和JPA的AutoConfiguration，我就可以在不同的AutoConfiguration里面定义一个WebMvcConfigurer的实现，里面只配置与mybatis或JPA相关的配置，这样需要那个启用那个，不需要人工通过注释代码来转换mybatis和JPA，注意：在springboot下自定义的WebMvcConfigurer实现配置类上是不需要添加@EnableWebMvc的，因为springboot已经实例化了WebMvcConfigurationSupport，如果添加了该注解，默认的WebMvcConfigurationSupport配置类是不会生效的，也就是以用户定义的为主，一般建议还是不覆盖默认的好。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring的细节整理</title>
      <link href="/2022/04/21/spring%E7%9A%84%E7%BB%86%E8%8A%82%E6%95%B4%E7%90%86/"/>
      <url>/2022/04/21/spring%E7%9A%84%E7%BB%86%E8%8A%82%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="spring中-Resource和-Autowired的区别"><a href="#spring中-Resource和-Autowired的区别" class="headerlink" title="spring中@Resource和@Autowired的区别"></a>spring中@Resource和@Autowired的区别</h1><blockquote><p>spring中，@Resource和@Autowired都是做bean的注入时使用。使用过程中，有时候@Resource 和 @Autowired可以替换使用；有时，则不可以。<br>    下面，根据自己的学习，整理下这两个注解使用中的共同点和不同点，及用法上的不同。<br>     共同点<br>     @Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。<br>    不同点<br>@Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。<br>@Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p></blockquote><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><p><strong>BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似</strong></p><blockquote><p>1.BeanFactory</p><p>BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p><p>2.FactoryBean</p><p>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<br>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T>的形式</p></blockquote><h1 id="什么是JDBCTemplate"><a href="#什么是JDBCTemplate" class="headerlink" title="什么是JDBCTemplate?"></a>什么是JDBCTemplate?</h1><p><strong>spring框架对JDBC进行封装,使用JDBCTemplate方便实现对数据库操作</strong></p><h1 id="spring事务管理API"><a href="#spring事务管理API" class="headerlink" title="spring事务管理API"></a>spring事务管理API</h1><p><strong>spring提供一个PlatformTransactionManager接口,代表事务管理器,这个接口针对不同操作数据库的框架提供不同的实现类</strong></p><p>[<img src="https://s1.ax1x.com/2022/04/21/LgAMz4.md.png" alt="LgAMz4.md.png"></p><p>如:DataSourceTransactionManager针对的是整合的是mybatis框架和JDBCTemplate(jdbc模板)</p><p>​    HibernateTransactionManager针对的是Hibernate框架等等…</p><h1 id="Transaction中的六大属性之pripagation-事务的传播行为"><a href="#Transaction中的六大属性之pripagation-事务的传播行为" class="headerlink" title="@Transaction中的六大属性之pripagation:事务的传播行为"></a>@Transaction中的六大属性之pripagation:事务的传播行为</h1><p>1)多事务方法直接进行调用,这个过程中事务是如何进行管理的</p><p>2)一共七个参数,主要记住Requireds和Required_New这两个</p><p><strong>详见spring总结章</strong></p><h1 id="Transaction中的六大属性之ioslation-事务的隔离级别"><a href="#Transaction中的六大属性之ioslation-事务的隔离级别" class="headerlink" title="@Transaction中的六大属性之ioslation:事务的隔离级别"></a>@Transaction中的六大属性之ioslation:事务的隔离级别</h1><p>1)事务特性有隔离性,多事务操作之间不会产生影响.不考虑隔离性产生很多问题</p><p>2)有三个读问题:<strong>脏读—-不可重复读—-幻(虚)读</strong></p><ul><li><p>脏读:一个未提交事务读取到另一个未提交事务的数据</p></li><li><p>不可重复读:一个为提交事务读取到另一个提交事务修改数据(mysql隔离级别默认可重复读)</p></li><li><p>幻读: 一个未提交事务读取到另一个提交事务添加数据</p><p>解决方案:  通过设置事务隔离级别,解决读问题.(1,4基本不用)</p><p>[<img src="https://s1.ax1x.com/2022/04/21/LgAKWF.md.png" alt="LgAKWF.md.png"></p></li></ul><h1 id="Transaction中的六大属性之timeout-事务的超时时间"><a href="#Transaction中的六大属性之timeout-事务的超时时间" class="headerlink" title="@Transaction中的六大属性之timeout:事务的超时时间"></a>@Transaction中的六大属性之timeout:事务的超时时间</h1><p>1)事务需要在一定时间内进行提交,如果不提交则进行回滚</p><p>2)默认值是-1,设置时间以秒为单位进行计算(-1代表不限超时时间)</p><h1 id="Transaction中的六大属性之readOnly-是否只读"><a href="#Transaction中的六大属性之readOnly-是否只读" class="headerlink" title="@Transaction中的六大属性之readOnly:是否只读"></a>@Transaction中的六大属性之readOnly:是否只读</h1><p>1)读:查询操作,写:添加修改删除操作</p><p>2)readOnly默认值是false,表示可以进行查询,可以添加修改删除操作</p><p>3)设置readOnly值是true,设置成true之后,只能查询</p><h1 id="Transaction中的六大属性之rollbackFor和noRollbackfor-回滚和不回滚"><a href="#Transaction中的六大属性之rollbackFor和noRollbackfor-回滚和不回滚" class="headerlink" title="@Transaction中的六大属性之rollbackFor和noRollbackfor:回滚和不回滚"></a>@Transaction中的六大属性之rollbackFor和noRollbackfor:回滚和不回滚</h1><p>1)设置查询那些异常进行事务回滚</p><p>2)@Transaction默认只对RuntimeException进行回滚,如果是编译时期异常则需要手动设置</p><p><strong>注:不要手动抓异常(dont try catch!!!!)不然会回滚失效,详见spring总结的文章!</strong></p><h1 id="过滤器Filter和拦截器Interceptor的区别"><a href="#过滤器Filter和拦截器Interceptor的区别" class="headerlink" title="过滤器Filter和拦截器Interceptor的区别"></a>过滤器Filter和拦截器Interceptor的区别</h1><ul><li><p>接口方面的区别</p><blockquote><p>过滤器实现的是Filter接口,拦截器实现的是HandlerInterceptor接口</p><p>Filter—–&gt;Servlet提供             HandlerInterceptor——&gt;spring提供    </p></blockquote></li><li><p>方法层面的区别</p></li><li><blockquote><p>过滤器的前后过滤是在doFilter方法内完成的</p><p>拦截器提供三个方法preHandle,postHandle,afterCompletion</p></blockquote></li><li><p>放行的区别</p></li><li><blockquote><p>过滤器调用filterChain.doFilter的时候放行</p><p>拦截器需要在preHandler中返回true表示放行,false表示不放行</p></blockquote></li><li><p>被管理方式的区别</p><blockquote><p>过滤器是tomcat创建管理</p><p>拦截器是spring创建管理的</p><p><strong>注意:如果用springboot,那么都是spring管理,应为tomcat已经被内置了,主导权在spring</strong></p></blockquote></li><li><p>管理范围的区别(仅限于使用springboot之前)</p><blockquote><p>过滤器范围大,拦截器范围小,但是在springboot中是一样大,因为所有的bean都是spring管理</p></blockquote></li></ul><h1 id="ApplicationContext是什么"><a href="#ApplicationContext是什么" class="headerlink" title="ApplicationContext是什么"></a>ApplicationContext是什么</h1><p>如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的身躯了。</p><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。</p><p>Context我们通常解释为上下文环境，用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”</p><h1 id="各种依赖"><a href="#各种依赖" class="headerlink" title="各种依赖"></a>各种依赖</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>validation校验框架起步依赖<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>validation<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>lombok<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>projectlombok<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>lombok<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>加入运维工具依赖<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>actuator<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>pagehelper<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>pagehelper<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>pagehelper<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">1.3</span><span class="token number">.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>切点表达式<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>aspectj<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>aspectjweaver<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>jackson<span class="token operator">--</span><span class="token operator">></span>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>jackson<span class="token operator">-</span>databind<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="application-yml配置文件"><a href="#application-yml配置文件" class="headerlink" title="application.yml配置文件"></a>application.yml配置文件</h1><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#设置端口号</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token comment"># 配置数据源</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/brand_demo<span class="token punctuation">?</span>serverTimezone=Asia/Shanghai    <span class="token key atrule">username</span><span class="token punctuation">:</span> root    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>  <span class="token key atrule">main</span><span class="token punctuation">:</span>    <span class="token key atrule">allow-circular-references</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 运行set方式循环依赖</span>   <span class="token key atrule">sql</span><span class="token punctuation">:</span> <span class="token comment">#sql语句初始化,用于测试的时候</span>    <span class="token key atrule">init</span><span class="token punctuation">:</span>      <span class="token key atrule">mode</span><span class="token punctuation">:</span> always      <span class="token key atrule">schema-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>scheme.sql <span class="token comment">#如果名称是shcema.sql就不用配置</span>      <span class="token key atrule">data-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>data.sql <span class="token comment">#如果名称是data.sql就不用配置</span><span class="token comment"># mybatis配置</span><span class="token comment"># 开启驼峰命名</span><span class="token key atrule">mybatis</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment">#配置springboot日志级别，输出运行过程中的SQL语句</span><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">level</span><span class="token punctuation">:</span>    <span class="token key atrule">com.itheima.mapper</span><span class="token punctuation">:</span> debug    <span class="token key atrule">org.springframework.jdbc.support.JdbcTransactionManager</span><span class="token punctuation">:</span> debug<span class="token comment">#分页合理化</span><span class="token key atrule">pagehelper</span><span class="token punctuation">:</span>  <span class="token key atrule">reasonable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoint</span><span class="token punctuation">:</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span>      <span class="token key atrule">show-details</span><span class="token punctuation">:</span> always  <span class="token comment">#设置mybatis的驼峰命名自动映射</span><span class="token key atrule">mybatis</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>           <span class="token comment">#设置mybatis-plus全局配置   </span><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tb_  <span class="token comment">#设置表名前缀为tb_</span>      <span class="token key atrule">id-type</span><span class="token punctuation">:</span> auto  <span class="token comment">#设置主键按自动增长赋值(默认为雪花算法,适合分布式数据库项目)</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl     <span class="token comment">#log显示sql语句</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>CAS  比较并设置   version</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring的总结和一些问题</title>
      <link href="/2022/04/15/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0Spring%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/15/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0Spring%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring解耦"><a href="#Spring解耦" class="headerlink" title="Spring解耦"></a>Spring解耦</h2><p>Spring的一大作用就是能够降低代码耦合,让程序的扩展性更好.</p><h1 id="Spring的注解"><a href="#Spring的注解" class="headerlink" title="Spring的注解"></a>Spring的注解</h1><blockquote><ul><li><p>将自定义Bean交给Spring管理可以使用哪些注解？</p><p>@component  作用:把标注此注解的类交给Spring容器来创建对象</p><p>@Controller    作用:把标注此注解的类交给Spring容器来创建对象(用在controller层)</p><p>@Service         作用:把标注此注解的类交给Spring容器来创建对象(用在service层)</p><p>@Repository    作用:把标注此注解的类交给Spring容器来创建对象（都是由Spring内置的mybatis来创建所以基本不用）(用在dao层)</p></li></ul></blockquote><blockquote><ul><li>Bean的范围</li></ul></blockquote><blockquote><p> @Scope</p></blockquote><blockquote><ul><li><p>@Autowired和@Value注解有什么区别？</p><p>@Autowired    作用:从Spring容器中,根据成员变量类型找一个对象,然后赋值给该成员变量,可以使用在成员变量、成员set方法、构造方法参数上</p><p>@Value只能使用在成员变量，还可以结合EL表达式获取配置文件中的属性参数</p></li></ul></blockquote><blockquote><ul><li><p>用什么注解定义切面类？Spring通知有几种？</p><p>@Aspect                 作用:注解用来定义切面类</p><p>@Around                作用:环绕通知</p><p>@Before                  作用:前置通知，在目标方法执行前执行</p><p>@AfterReturning      作用:后置通知，在目标方法执行后，且没有异常时才执行</p><p>@AfterThrowing      作用:异常通知，在目标方法执行后，且出现异常时才执行</p><p>@After                     作用:最终通知，在目标方法执行后，且无论是否出现异常都执行</p></li></ul></blockquote><h1 id="AOP常用术语"><a href="#AOP常用术语" class="headerlink" title="AOP常用术语"></a>AOP常用术语</h1><p>1)切面:就是那些重复的,公共的,通用的功能称为切面,例如:日志,事务,权限</p><p>2)连接点:就是目标方法,因为在目标方法中要实现目标方法的功能和切面功能</p><p>3)切入点(Pointcut):来指定切入的位置,多个连接点构成切入点,切入点可以是一个目标方法,可以是一个类中所有方法,可以是某个包下的所有类中的方法.</p><p>4)目标对象:操作谁,谁就是目标对象.</p><p>5)通知(Advice):来指定切入的时机,是在目标方法执行前还是执行后还是出错时,还是环绕目标方法切入切面功能.</p><h1 id="什么是AspectJ框架"><a href="#什么是AspectJ框架" class="headerlink" title="什么是AspectJ框架"></a>什么是AspectJ框架</h1><p>1.Spring框架一般都是基于AspectJ实现Aop操作</p><p>2AspectJ不是spring组成部分,独立AOP框架,一般吧AspectJ和Spring框架一起使用,进行aop操作.</p><p>3.AspectJ是一个优秀的面向切面的框架,它扩展了JAVA语言,提供了强大的切面实现.它因为是基于java语言开发的,所以无缝扩展.</p><h1 id="AspectJ常见通知类型"><a href="#AspectJ常见通知类型" class="headerlink" title="AspectJ常见通知类型"></a>AspectJ常见通知类型</h1><ul><li>AspectJ中常用的通知有四种类型:</li></ul><p>1)前置通知@Before</p><p>2)后置通知@AfterReturning</p><p>3)异常通知@AfterThrowing</p><p>4)环绕通知@Around</p><p>5)最终通知@After</p><p>6)定义切入点@Pointcut(了解) </p><h1 id="AspectJ-的切入点表达式（掌握）"><a href="#AspectJ-的切入点表达式（掌握）" class="headerlink" title="AspectJ 的切入点表达式（掌握）"></a>AspectJ 的切入点表达式（掌握）</h1><p>规范的公式：<br>execution(访问权限 方法返回值 方法声明（参数〉异常类型）<br>简化后的公式：<br>execution(方法返回值 方法声明（参数））<br>用到的符号：</p><p>*代码任意个任意的字符(通配符）<br>..如果出现在方法的参数中,则代表任意参数<br>如果出现在路径中,则代表本路径及其所有的子路径</p><h1 id="Bean的作用域-scope"><a href="#Bean的作用域-scope" class="headerlink" title="Bean的作用域(scope)"></a>Bean的作用域(scope)</h1><p>在类上使用@scope注解定义Bean的作用域,Spring支持五种作用域,后三种在web环境才生效.</p><ul><li><blockquote><p>@scope(“singleton”) - 容器内同 id 的 bean 只有一个实例（默认） </p></blockquote></li><li><blockquote><p>@scope(“prototype”) - 每次使用该 bean 时会创建新的实例</p></blockquote></li><li><p>@scope(“request”) - 在 web 环境中，每个请求范围内会创建新的实例</p></li><li><p>@scope(“session”) - 在 web 环境中，每个会话范围内会创建新的实例</p></li><li><p>@scope(“application”)- 在 web 环境中，每个应用范围内会创建新的实例</p><ul><li>注:singleton和prototype区别</li></ul><p>第一 ,singleton单实例,protptype多实例</p><p>第二,设置scope值是singleton时候,加载spring配置文件时就会创建单实例对象</p><p>​        设置scpe值是prototype时候,不是在加载spring配置文件的时候创建对象,</p><p>在调用getBean方法时候创建多实例对象</p></li></ul><h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><blockquote><p> 1.生命周期</p><p>​    从对象创建到对象销毁的过程</p><p>2.bean生命周期的七步</p><p>​    1).通过构造器创建bean实例(无参数构造)</p><p>​    2).为bean的属性设置值和对其他bean引用(调用set方法)</p><p>​    2.1)把bean实例传递bean后置处理器的方法postProcessBeforeInitialization</p><p>​    3).调用bean的初始化的方法(需要进行配置初始化的方法)</p><p>​     3.1)把bean实例传递bean后置处理器的方法postProcessAfterInitialization</p><p>​    4).bean可以使用了(对象获取到了)<br>​    5).当容器关闭的时候,调用bean的销毁的方法(需要进行配置销毁方法)</p><p>3.后置处理器如何创建</p><p>   创建类,实现接口beanpostProcessor,创建后置处理器</p></blockquote><ul><li>标注了&#x3D;&#x3D;<strong>@PostConstruct</strong>&#x3D;&#x3D;的方法是初始化方法,会&#x3D;&#x3D;<strong>在bean实例被创建之后</strong>&#x3D;&#x3D;调用.</li><li>标注了**@PreDestroy** 的方法是销毁方法,**&#x3D;&#x3D;singleton范围的bean&#x3D;&#x3D;**的销毁方法会在Spring&#x3D;&#x3D;在容器关闭前被调用&#x3D;&#x3D;.</li><li>延迟初始化<ul><li>默认情况下singleton范围的bean是容器创建时就会&#x3D;&#x3D;<strong>创建</strong>&#x3D;&#x3D;</li><li>如果希望&#x3D;&#x3D;<strong>用到时才创建</strong>&#x3D;&#x3D;,可以使用 &#x3D;&#x3D;<strong>@Lazy</strong>&#x3D;&#x3D; 注解标注在类上来延迟创建(懒汉单例)</li></ul></li></ul><h1 id="扩展-返回数据库自增长键值注解"><a href="#扩展-返回数据库自增长键值注解" class="headerlink" title="扩展:返回数据库自增长键值注解"></a>扩展:返回数据库自增长键值注解</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>keyProperty <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>  需要数据库自增长的键值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="扩展-初始化库"><a href="#扩展-初始化库" class="headerlink" title="扩展:初始化库"></a>扩展:初始化库</h1><p>把DDL和DML的sql分别存储于resources下的schema.sql和data.sql这两个文件中,然后在application.properties中配置</p><blockquote><p>spring.sql.init.mode&#x3D;always</p><p>spring.sql.init.mode&#x3D;UTF-8 </p></blockquote><h2 id="Spring中编译异常导致事务回滚失效问题"><a href="#Spring中编译异常导致事务回滚失效问题" class="headerlink" title="Spring中编译异常导致事务回滚失效问题"></a>Spring中编译异常导致事务回滚失效问题</h2><p>为什么当我们用@Transactional注解来进行事务的管理的时候,如果出现编译时异常,发现事务还是提交了,没有回滚?</p><ul><li><p>原因:</p><p>–&gt; spring默认只有抛出运行时异常(即RuntimException及子类)或Error及子类时,才回回滚事务</p><p>–&gt; 如果抛出的是其他编译时期异常,则仍会提交事务</p><blockquote><p>解决方法:配置@Transaction(rollbackFor &#x3D; xxxException.class)</p></blockquote></li></ul><h1 id="Spring捕捉异常导致的回滚失效问题"><a href="#Spring捕捉异常导致的回滚失效问题" class="headerlink" title="Spring捕捉异常导致的回滚失效问题"></a>Spring捕捉异常导致的回滚失效问题</h1><ul><li><p>原因:</p><p>–&gt;事务提交,回滚,都是代理对象调用事务通知来完成的,如果代理对象不知道出现了异常,也就没有机会执行回滚操作</p><p>–&gt;自己try-catch异常,意味着代理对象认为[没有发生异常],因此也会提交事务</p><blockquote><p>解决方法:业务方法内不要捕获异常,或者将捕获的异常重新抛出</p></blockquote><h1 id="Transactional-Propagation-事务的传播行为"><a href="#Transactional-Propagation-事务的传播行为" class="headerlink" title="@Transactional(Propagation)事务的传播行为"></a>@Transactional(Propagation)事务的传播行为</h1><ul><li>当我们使用@Transactional开启事务的时候,如果事务内部需要调用另一个事务,那么他们用的是同一个事务吗?</li></ul><blockquote><p>如果没有设置参数,则默认是使用同一个事务,则一次事务创建(create new transaction),一次事务提交(commit)</p><ul><li>默认参数为:</li></ul><p>@Transactional(propagation &#x3D; propagation.REQUIRED)   有则加入,无则创建</p><ul><li>如果无论如何都想开启新事务,这是用以下参数:</li></ul><p>@Transactional(propagation &#x3D; propagation.REQUIRES_NEW) 总是需要一个新事物 </p></blockquote><h1 id="Transactional事务传播行为失效"><a href="#Transactional事务传播行为失效" class="headerlink" title="@Transactional事务传播行为失效"></a>@Transactional事务传播行为失效</h1><blockquote><p>事务传播行为失效是为在同一个类中,一个事务方法调另一个事务方法,此时被调用的方法实际上是this执行的,不是spring注入的代理对象,@Transactional底层是由spring创建的代理对象调用的AOP通知执行的事务逻辑,如果是this.方法名就不是代理对象调用了,而是被代理对象自己调用自己方法,所以被调用@Transaction事务注解也就不会生效了.</p></blockquote><blockquote><p>解决方法:底层原因跟循环依赖一样,只需要在配置文件配置:main.allow.circular&#x3D;reference&#x3D;true即可</p><p>注意:spring2.6.0之前的版本不需要配置,有spring自动处理</p></blockquote><h1 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h1><blockquote><p>Spring2.6.0之前的版本会自动解决</p></blockquote><blockquote><p>spring2.6.0及后版本需要在配置文件开启:main.allow.circular&#x3D;reference&#x3D;true</p></blockquote><h1 id="原子性与锁失效"><a href="#原子性与锁失效" class="headerlink" title="原子性与锁失效"></a>原子性与锁失效</h1><p>当我们开启一个事务的时候,这个时候如果有多个用户想通过事务来操作数据库,我们的数据库不上锁是非常危险的,会产生线程安全问题,这个时候我们应该想到上锁,但是上锁就能解决问题吗?</p><blockquote><p>答案是不一定,这个得取决于锁的位置,如果上锁的位置在@Transactional下的方法声明上,那么此锁会失效,应为我们在使用@Transactional创建事务的时候是通过通知+切点+通知的方式来实现的,如果在方法声明上上锁的话,那么有可能当一个客户端走完这个方法的时候,这个锁会打开,然后在提交事务之前(也就是后置通知执行前)有可能会让另一个用户进入到方法内部再次执行一遍事务流程,然后两个客户端同时提交,这个时候就会产生线程安全问题,也就是并发修改异常的现象,那么我们应该如何解决锁失效的问题呢?</p><ul><li><p>方式一:可以将锁上在整个事务代码的外面,也就是当serveci层的方法内部调用的时候,将整个调用过程前面上锁,就可以将,事务代码和业务代码一起包含在内了.</p></li><li><p>方式二:可以在sql查询语句后面加一个for update(排他锁)语句,加上了此语句之后,只要当前客户端不提交事务,其他客户端就无法访问当前客户端正在操作的信息,会锁在原地等待当前用户提交事务后才能进行下一步操作,这个锁也叫做悲观锁.</p></li></ul></blockquote></li></ul><h1 id="什么是IOC？什么是DI？"><a href="#什么是IOC？什么是DI？" class="headerlink" title="什么是IOC？什么是DI？"></a>什么是IOC？什么是DI？</h1><blockquote><p>IOC：控制反转，将Bean对象的创建权交给Spring，而后从Spring容器中获取Bean对象来使用</p></blockquote><blockquote><p> DI：依赖注入，给Bean的属性赋值</p></blockquote><h1 id="请指定什么是通知、连接点、切点、切面？"><a href="#请指定什么是通知、连接点、切点、切面？" class="headerlink" title="请指定什么是通知、连接点、切点、切面？"></a>请指定什么是通知、连接点、切点、切面？</h1><blockquote><p> 通知：抽取的相同业务逻辑的代码，用来增强目标方法</p><p>连接点：目标对象的所有方法均为连接点</p><p>切点：目标对象需要增强的方法为切点</p><p>切面：通知加切点</p></blockquote><h1 id="Spring整合MyBatis流程是什么？"><a href="#Spring整合MyBatis流程是什么？" class="headerlink" title="Spring整合MyBatis流程是什么？"></a>Spring整合MyBatis流程是什么？</h1><blockquote><p>第一步：创建SpringBoot工具，pom.xml文件中添加依赖</p></blockquote><blockquote><p>第二部：在application…配置文件中配置连接参数</p></blockquote><blockquote><p>第三部：定义Mapper接口，在接口上使用@Mapper注解</p></blockquote><h1 id="配置类读取数据错误问题"><a href="#配置类读取数据错误问题" class="headerlink" title="配置类读取数据错误问题"></a>配置类读取数据错误问题</h1><p>当我们用@Configration定义配置类时,有时候从配置文件读取的数据与我们设置的数据不不符是为什么呢?</p><p>因为spring底层默认先读取系统配置文件,如果你定义的配置名与系统环境变量一样,那么有可能会读取到系统的内容..</p><h1 id="什么时候会通知失效"><a href="#什么时候会通知失效" class="headerlink" title="什么时候会通知失效"></a>什么时候会通知失效</h1><p>没有经过代理调用方法就会失效,使用@autowired注入一个代理对象来调用就可以了(循环依赖)</p><h1 id="接口WebMvcConfigurer的作用及常用的2个方法"><a href="#接口WebMvcConfigurer的作用及常用的2个方法" class="headerlink" title="接口WebMvcConfigurer的作用及常用的2个方法"></a>接口WebMvcConfigurer的作用及常用的2个方法</h1><ul><li><p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，可以自定义一些Handler，Interceptor，ViewResolver，MessageConverter</p><blockquote><p>1.1 addInterceptors：拦截器</p><p>addInterceptor：需要一个实现HandlerInterceptor接口的拦截器实例<br>addPathPatterns：用于设置拦截器的过滤路径规则；addPathPatterns(“&#x2F;**”)对所有请求都拦截<br>excludePathPatterns：用于设置不需要拦截的过滤规则<br>拦截器主要用途：进行用户登录状态的拦截，日志的拦截等</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addInterceptors</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">"/emp/toLogin"</span><span class="token punctuation">,</span><span class="token string">"/emp/login"</span><span class="token punctuation">,</span><span class="token string">"/js/**"</span><span class="token punctuation">,</span><span class="token string">"/css/**"</span><span class="token punctuation">,</span><span class="token string">"/images/**"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>2.3 addResourceHandlers：静态资源</p><p>比如，我们想自定义静态资源映射目录的话，只需重写addResourceHandlers方法即可。<br>注：如果继承WebMvcConfigurationSupport类实现配置时必须要重写该方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebMvcConfigurerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 配置静态访问资源     * @param registry     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span><span class="token class-name">ResourceHandlerRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">"/my/**"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">"classpath:/my/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addResoureHandler：指的是对外暴露的访问路径<br>addResourceLocations：指的是内部文件放置的目录</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器和Tomcat服务器之间字符集乱码的问题怎么解决?</title>
      <link href="/2022/04/04/%E7%BD%91%E9%A1%B5%E5%92%8CTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/04/04/%E7%BD%91%E9%A1%B5%E5%92%8CTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>首先说明一下:</p><p>网页的编码和解码默认都是字符集采用的是-&gt; GBK</p><p>Tomcat的编码和解码默认都是使用采用-&gt; ISO-8859-1</p><p>  但是当我们采用html编写网页时,为了展示中文数据,一般会先将网页的编码格式设置为UTF-8,这个时候网页的编码格式就是UTF-8了.</p><p><a href="https://imgtu.com/i/qqQ9yR"><img src="https://s1.ax1x.com/2022/04/04/qqQ9yR.png" alt="qqQ9yR.png" border="0" /></a></p><p>  这个时候当我们使用Tomcat的Request接受中文数据的时候,因为浏览器采用UTF-8编码,然而tomcat才用的是ISO-8859-1解码,字符集不一致,所以会导致乱码问题.</p><p>解决方式分两种情况:GET请求和POST请求(GET请求请求参数在请求行,POST请求请求参数在请求体,所以方法不同)</p><h2 id="Request请求参数参数中文乱码处理-gt-POST请求"><a href="#Request请求参数参数中文乱码处理-gt-POST请求" class="headerlink" title="Request请求参数参数中文乱码处理-&gt;POST请求:"></a>Request请求参数参数中文乱码处理-&gt;POST请求:</h2><p><a href="https://imgtu.com/i/qqQtpQ"><img src="https://s1.ax1x.com/2022/04/04/qqQtpQ.png" alt="qqQtpQ.png" border="0" /></a></p><p>解决方案:</p><p>设置输入流编码:UTF-8</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">request<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Request请求参数参数中文乱码处理-gt-GET请求"><a href="#Request请求参数参数中文乱码处理-gt-GET请求" class="headerlink" title="Request请求参数参数中文乱码处理-&gt;GET请求:"></a>Request请求参数参数中文乱码处理-&gt;GET请求:</h1><p><a href="https://imgtu.com/i/qqQ2c9"><img src="https://s1.ax1x.com/2022/04/04/qqQ2c9.png" alt="qqQ2c9.png" border="0" /></a></p><p>ps.如果使用的是Tomcat8以及以后的版本,GET请求中文不会出现乱码问题</p><p>解决办法1：针对使用tomcat7及以前版本的tomcat</p><p>对乱码的字符先使用ISO-8859-1编码，再按照UTF-8解码即可恢复原始数据。可使用jdk提供的URLEncoder、URLDecoder或者String类完成</p><p>编码(URLEncoder):</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s<span class="token operator">=</span><span class="token class-name">URLEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解码(URLDecoder):</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">username<span class="token operator">=</span><span class="token class-name">URLDecoder</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>编码(String):</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token operator">=</span>username<span class="token punctuation">.</span>getBytes <span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解码(String):</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">username<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决办法2：配置方式解决tomcat7 GET请求中文乱码问题【推荐使用】</p><p>maven tomcat7 插件配置:</p><p><a href="https://imgtu.com/i/qqQH9e"><img src="https://s1.ax1x.com/2022/04/04/qqQH9e.png" alt="qqQH9e.png" border="0" style="zoom: 50%;" /></a></p><p>本地 tomcat7 配置: conf&#x2F;server.xml</p><p><a href="https://imgtu.com/i/qqQLjA"><img src="https://s1.ax1x.com/2022/04/04/qqQLjA.png" alt="qqQLjA.png" border="0" style="zoom: 50%;" /></a></p><h1 id="Response响应数据中文乱码处理"><a href="#Response响应数据中文乱码处理" class="headerlink" title="Response响应数据中文乱码处理:"></a>Response响应数据中文乱码处理:</h1><p>​    当我们试图使用Response直接对浏览器响应中文数据时,为什么会产生乱码问题?</p><p>​    因为此时Tomcat服务器的Response对象的默认编码是ISO-8859-1,而浏览器的解码方式仍然是GBK,所以当我们将中文数据响应到页面上时其实是,Response对中文数据用了ISO-8859-1的字符集编码,而响应到浏览器那边,浏览器确是用的GBK来解码,字符集不一致,所以导致乱码</p><p>​    那么我们能不能像处理Request那样的方式来处理Response响应乱码的问题呢?</p><p>​    其实是可以的,我们可以通过设置Response的响应输出流的编码为GBK,与浏览器字符集保持一致就可以了,方式如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"GBK"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    但是此方法并不推荐,因为我们在处理请求参数时用的是UTF-8,为了保持请求和响应一致,我们应该也同样设置响应输出流的字符集为UTF-8,但是当我们设置了Response的输出流字符集为UTF-8时,与浏览器的GBK解码方式又再一次对应不上了,那么我们有没有办法能够在设置Response字符集的时候同时告诉浏览器使用同样的字符集解码吗?答案是有的,设置响应头参数即可,解决方式如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgtu.com/i/qqQzAf"><img src="https://s1.ax1x.com/2022/04/04/qqQzAf.png" alt="qqQzAf.png" border="0" style="zoom: 67%;" /></a></p><p>此时,我们的服务器和浏览器之间不管是请求还是响应都是以UTF-8的方式处理了,完美解决了乱码的问题!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中是如何实现多对一分步查询的?</title>
      <link href="/2022/04/03/Mybatis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E7%9A%84?/"/>
      <url>/2022/04/03/Mybatis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E7%9A%84?/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgtu.com/i/qHYoKH"><img src="https://s1.ax1x.com/2022/04/03/qHYoKH.png" alt="qHYoKH.png" border="0" /></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇博客</title>
      <link href="/2022/04/03/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/04/03/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>记录一下:</p><p><a href="https://imgtu.com/i/qHd7NR"><img src="https://s1.ax1x.com/2022/04/03/qHd7NR.png" alt="qHd7NR.png" border="0" /></a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/03/hello-world/"/>
      <url>/2022/04/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个简约扁平化的Hexo静态主题博客-Quiet</title>
      <link href="/2020/11/03/%E6%96%B0%E4%B8%BB%E9%A2%98%E6%96%87%E7%AB%A0/"/>
      <url>/2020/11/03/%E6%96%B0%E4%B8%BB%E9%A2%98%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Quiet </tag>
            
            <tag> 主题 </tag>
            
            <tag> 静态主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
